from log_utils import logger_print
from pyomo_environ import *
from typing import cast, Optional
from config import *
from pydantic import ValidationError
import cmath
from copy import deepcopy
import copy
from error_utils import ErrorManager
# input: negative
# output: positive
# IO: Real
import numpy as np
import math


# TODO: use StrEnum (3rd party library) to replace literals in data validation and control flows.
# TODO: implement unit conversion of device info in another file with separate datamodels (another template) instead of explicit conversion in this template (create that first (skeleton) to suppress type check error)
# ref: https://pypi.org/project/StrEnum/
{% macro IsIterable(it)%}hasattr({{it}}, "__iter__"){% endmacro %}

def getattr_with_ellipsis_fallback(obj, attrName, default=cmath.nan):
    val = getattr(obj, attrName, default)
    if val is ...:
        val = default
    return val

{% macro applyMacroWithSingleParam(_macro, paramList) %}
    {% for param in paramList%}
{{_macro(param)}}

    {% endfor%}
{% endmacro%}
{# VAR_INIT_AS_ZERO = "VAR_INIT_AS_ZERO" #}

import os
# TODO: 典型日 最终输出结果需要展开为8760
# TODO: add more "bounds" to variables
# TODO: call external processor/parser to handle DSL, simplify expressions.
{# optional comment flag for our stepwise refactor. #}
{%set SO = namespace(class_name="")%}
{% set 设计规划 = "if self.计算参数.计算类型 == '设计规划'"%}
{% set 仿真模拟 = "if self.计算参数.计算类型 == '仿真模拟'"%}
{% set 秒 = 'if self.计算参数.计算步长 == "秒"'%}
{% set 小时 = 'if self.计算参数.计算步长 == "小时"'%}
{# {% set needStorageDecayCompensation=true%} #}
{% macro stepwise_flag(class_name, flag_name) %}{% if SO.class_name == class_name %}{{' STEPWISE FLAG [{}] '.format(flag_name).center(40, "#") }}{% endif %}{% endmacro %}
from typing import Dict, List, Tuple, Union, Callable
from pydantic import conlist, conint, confloat, constr
from constants import *
{# consider to type check all variable operations #}
{# cast such type to all variables, to forbid 'var * var' #}
import pyomo.core.base
import parse
from export_format_units import *
{% set IndexedVar = "pyomo.core.base.var.IndexedVar" %}
{% set GeneralVarData = "pyomo.core.base.var._GeneralVarData" %}
{# forbid untyped code. #}
{# mark as pyright global config. #}
{# also for mypy #}
{% set normal_str = "constr(min_length=1)"%}
{% set non_neg_float = "confloat(ge=0)"%}
{% set pos_float = "confloat(gt=0)"%}
{% set non_neg_int = "conint(ge=0)"%}
{% set pos_int = "conint(gt=0)"%}
{% macro qstr(mstr)%}"{{mstr}}"{%endmacro%}
{% macro import_type_fallback(symbol)%}
try:
    from typing import {{symbol}}
except:
    from typing_extensions import {{symbol}}
{% endmacro %}
{{import_type_fallback("Literal")}}
{# 
try:
    from typing import Annotated
except:
    from typing_extensions import Annotated #}

{# from typing import Tuple #}

{% macro double_check_setattr(obj, attrName, val) %}
assert getattr({{obj}},{{attrName}}, None) is None, f"错误: 不能设置两次相同的变量名称\n重复变量: { {{attrName}} }"
{{obj}}.__setattr__({{attrName}}, {{val}})
{% endmacro %}

import rich
from pydantic import BaseModel, Field, validator
# the main code for computing.
# currently just compute microgrid
# three computation modes:
{# shall you define more string literals in enum class, and more pydantic models, union types.#}
{# from functools import lru_cache #}

{# item count is for list, length is for string.#}
{% macro tuple_type_construct(l, t) %}{{", ".join([t]*l)}}{% endmacro %}
{% macro PLField(tuple_name,tuple_size_literal,elem_name, description)%}
{% set elem_type = elem_name%}
{% if elem_name == "价格"%}
    {% set elem_type = "float"%}
{% endif%}
    {{tuple_name}}:Tuple[{{tuple_type_construct(constants[tuple_size_literal], elem_type)}}] = Field(title = f"长度为{{'{'+tuple_size_literal+'}'}}的{{elem_name}}数组", description = "{{description}}")
{% endmacro%}
{# {% macro item_constraint(l)%}min_item = {{l}}, max_item= {{l}}{% endmacro%} #}

{# ##########[PINT START]########## #}

{# import pint #}

from unit_utils import (
    unitFactorCalculator,
    ureg,
    standard_units,
    getSingleUnitConverted,
    multiplyWithUnit
)

{# ##########[PINT END]########## #}

### 计价模型 ###
import math
# 函数参数: (power, time_in_day)
# 阶梯电价: 容量下限从0开始

# TODO: 每个月的都不同 #

def 计算年化率(_贴现率, 寿命):
    # 默认贴现率单位为%
    if _贴现率 <= 0 or 寿命 <= 0:
        {# self.年化率 = 1/Life #}
        年化率 = 0 # 仿真模拟的时候 用于去除和年化率有关的目标
    else:
        贴现率 = _贴现率/100
        年化率_CT = (1+贴现率) ** 寿命

        年化率 = (贴现率*年化率_CT)/(年化率_CT - 1) 
    return 年化率

{% set 电价单位 = "元/kWh"%}
{% set 电价单位描述 = "单位: 元/kWh"%}

{% macro getFee() %}
    def getFee(self, power:float, time_in_day:float) -> float:
{% endmacro%}
{% macro getMonthIndexFromTimeInDay()%}
        current_day_index = time_in_day//每天小时数
        month_index = convertDaysToMonth(current_day_index)
{% endmacro%}
{% macro getCurrentTimeFromTimeInDay()%}
        current_time = math.floor(time_in_day%每天小时数)
{% endmacro%}
{% macro returnElectricPrice() %}
        # unit: [currency]/[time]
        # 万元/h
        return self.convert(price*power)
{% endmacro%}
{% macro getFeeWrapper()%}
{{getFee()}}
{{caller()}}
{{ returnElectricPrice() }}
{% endmacro %}
from functools import lru_cache
class 电价转换:
    @staticmethod
    @lru_cache(maxsize=1)
    def getMagnitude():
        magnitude, _ = unitFactorCalculator(ureg, standard_units, "{{电价单位}}")
        return magnitude
    @staticmethod
    def convert(value):
        # convert to standard unit
        magnitude = 电价转换.getMagnitude()
        ret = value * magnitude
        return ret

class 常数电价(BaseModel, 电价转换):
    Price:{{pos_float}} = Field(title = "电价", description = "{{电价单位描述}}")

{%call getFeeWrapper()%}
        price = self.Price
{% endcall%}

month_days = [31] * 每年月数
month_days[1] = 28
month_days[4 - 1] = month_days[6 - 1] = month_days[9 - 1] = month_days[11 - 1] = 30
assert sum(month_days) == 每年天数

def convertMonthToDays(month_index:int):
    {# cursor = month_index -1 #}
    assert month_index in range({{每年月数}})
    ret = sum(month_days[:month_index])
    return ret

def convertDaysToMonth(day_index:float):
    acc_days = 0
    for month_cursor, days_in_month in enumerate(month_days):
        acc_days += days_in_month
        if acc_days >= day_index:
            return month_cursor
    {# if day_index <365:
        return month_cursor+1 #}
    raise Exception("Invalid day index:", day_index)

class 分月电价(BaseModel, 电价转换):
    {# PriceList:Tuple[{{tuple_type_construct(每年月数, "float")}}] = Field(title = f"长度为{每年月数}的价格数组", description = "{{电价单位描述}}") #}
{{PLField("PriceList", "每年月数", "价格", 电价单位描述)}}

{%call getFeeWrapper()%}
{{getMonthIndexFromTimeInDay()}}
        price = self.PriceList[month_index]
{% endcall%}

class 分时电价(BaseModel, 电价转换):
    {# PriceList: Tuple[{{tuple_type_construct(每天小时数, "float")}}] = Field(title = f"长度为{每天小时数}的价格数组", description = "{{电价单位描述}}") #}
{{PLField("PriceList", "每天小时数", "价格", 电价单位描述)}}
{# 
    @validator("PriceList")
    def checkPriceList(cls, val):
        assert len(val) == 24
        return val #}

{%call getFeeWrapper()%}
{{getCurrentTimeFromTimeInDay()}}
        price = self.PriceList[current_time]
{% endcall%}

class 分时分月电价(BaseModel, 电价转换):
    {# PriceStruct:Tuple[{{tuple_type_construct(每年月数, "分时电价")}}] = Field(title = f"长度为{每年月数}的分时电价数组", description = "{{电价单位描述}}") #}
{{PLField("PriceStruct", "每年月数", "分时电价", 电价单位描述)}}
{# {%call getFeeWrapper()%} #}
{{ getFee()}}
{{getMonthIndexFromTimeInDay()}}
        _分时电价 = self.PriceStruct[month_index]
        ret = _分时电价.getFee(power,time_in_day)
        return ret
{# {{getCurrentTimeFromTimeInDay()}} #}
        {# price = _分时电价.PriceList[current_time]
{% endcall%} #}

class 计价阶梯(常数电价):
    LowerLimit : {{non_neg_float}} = Field(title = "功率下限")

class 阶梯电价(BaseModel):
    PriceStruct: conlist(计价阶梯, min_items=1) = Field(title = "长度不定的计价阶梯列表", description = "{{电价单位描述}}")

    @validator("PriceStruct")
    def checkPriceStruct(cls, v: List[计价阶梯]):
        v.sort(key = lambda x: x.LowerLimit)
        assert v[0].LowerLimit == 0
        return v
    
{{getFee()}}
        for index, elem in enumerate(self.PriceStruct):
            if elem.LowerLimit <= power:
                if index+1 == len(self.PriceStruct) or self.PriceStruct[index+1].LowerLimit >= power:
                    return elem.getFee(power, time_in_day)
        logger_print(self)
        raise Exception("Unable to get electricity price with power:", power)

class 分时阶梯电价(BaseModel):
    {# PriceStructList:Tuple[{{tuple_type_construct(每天小时数, "阶梯电价")}}] = Field(title = f"长度为{每天小时数}的阶梯电价列表", description = "{{电价单位描述}}") #}
{{PLField("PriceStructList", "每天小时数", "阶梯电价", 电价单位描述)}}

{{getFee()}}
        current_time = math.floor(time_in_day%每天小时数)
        mPriceStruct = self.PriceStructList[current_time]
        result = mPriceStruct.getFee(power, time_in_day)
        return result

{% set load_types = ['电']%}
{% set load_class_names = []%}
{% for load_type in load_types%}
{% do load_class_names.append(load_type+"负荷")%}
{% endfor%}
{% set input_types = ['柴油'] %}

{% macro sum_reduce(seq)%}
 sum({{seq}})
{# functools.reduce(sequence={{seq}}, function = lambda x,y: x+y) #}
{% endmacro%}

{% macro init_super_class(class_name) %}
    def __init__(self, PD:dict, mw: ModelWrapper, 计算参数实例: 计算参数, 设备ID: {{ class_name }}ID, 设备信息: {{ class_name }}信息):
        super().__init__(PD=PD, mw=mw, 计算参数实例=计算参数实例, ID = 设备ID.ID)
        self.设备ID = 设备ID
        self.设备信息 = 设备信息
{% endmacro %}

{% macro port_variable_define(class_name) %}
        ##### PORT VARIABLE DEFINITION ####

        self.ports = {}
        
        {% for port_name, port_type in 设备接口集合[class_name] %}
        {% if port_type.endswith("输入输出") or class_name in ['变压器', "传输线"]%}
        {% set mt = "Reals" %}
        {% elif port_type.endswith("输入") %}
        {# {% set mt = "NegativeReals"%} #}
        {% set mt = "NonPositiveReals"%}
        {% elif port_type.endswith("输出") %}
        {% set mt = "NonNegativeReals"%}
        {% endif %}
        self.PD[self.设备ID.{{port_name}}] = self.ports['{{port_name}}'] = self.{{port_name}} = self.变量列表("{{port_name}}", within={{mt}})
        """
        类型: {{port_type}}
        """

        {% endfor %}
{% endmacro %}

{%macro expand_unit_conversion(mdigit, exceptionList=[])%}
        {% if mdigit[4] == 1 or mdigit[0] in exceptionList%}
        self.{{ mdigit[0] }}: float = 设备信息.{{ mdigit[0] }}
        """
        名称: {{ mdigit[1] }}
        单位: {{ mdigit[2] }}
        """
        {%else%}
        self.{{ mdigit[0] }}: float = 设备信息.{{ mdigit[0] }} * {{ mdigit[4]}}
        """
        名称: {{ mdigit[1] }}
        单位: {{ mdigit[3] }} <- {{ mdigit[2] }}
        """
        {% endif %}
        assert self.{{ mdigit[0] }} >=0
{%endmacro%}


{% set 时间步长参数='self.计算参数.时间参数'%}
{# {% set 时间步长参数='self.计算参数.时间参数()'%} #}
{# {% set 时间步长参数='(1 if self.计算参数.计算步长 == "小时" else 3600)'%} #}

{% set 单向变电器列表 = ['变压器', '变流器']%}

{%set 设备参数例外列表 = ["PowerDeltaLimit", "RatedWindSpeed", "MaxWindSpeed", "MinWindSpeed", "BatteryDeltaLimit", "BatteryStorageDecay"]%}
# 8760 hours of data
# several days of data to compute a year

# 7200 seconds. simulation

# device parameters would be the same.

# load and environment might change.

# so for every device the will change.

# iterate through all device-port pairs, then retrieve attributes from another dict.

# string, digits, tables.
# you can dump and load from json.
{# 
class 加法器ID(BaseModel):
    输入:int
    输出:int
    输入输出: int #}

{# {% for super_class, class_name, mstrs, mdigits, mtables in 设备库 %} #}

def quicksum_indexed_var(indexed_var):
    if isinstance(indexed_var,list):
        return sum(indexed_var)
    return sum(indexed_var.values())
#############
# Device ID #
#############
from pydantic import validator
class 设备ID(BaseModel):
    ID: {{non_neg_int}} = Field(title = "设备ID", description = '从拓扑图节点ID获取')

{% for class_name in 设备接口集合.keys()%}

class {{class_name}}ID(设备ID):
    {% for port_name, port_type in 设备接口集合[class_name]%}
    {{ port_name }}: {{non_neg_int}} = Field(title = "{{ port_name }}ID", description = "接口类型: {{ port_type }}")
    """
    类型: {{ port_type }}
    """
    {% endfor %}

{% endfor %}

###############
# Device Info #
###############

{% set deviceBaseIdentifiers = [
    "设备名称",
]%}
{% set deviceOptionalIdentifiers = [
    "生产厂商",
    "设备型号",
]%}
{% set deviceIdentifiers = deviceBaseIdentifiers + deviceOptionalIdentifiers %}

class 设备基础信息(BaseModel):
{% for i in deviceBaseIdentifiers%}
    {{i}}: {{normal_str}} = Field(title = "{{i}}")
{# 
    subtype_hidden: Union[None, str] = Field(
        default=None, title="节点原次类型", description="内部变量，不要填写"
    )
     #}
    def toStandard(self, attr:str):
        className = self.__class__.__name__

        with ErrorManager(default_error = f"Instance data:\n{self.dict()}\nError converting attribute '{attr}' of class '{className}'"):
            schema = self.schema()
            props = schema['properties']

            attr_alias_dict = {k: v.get('title', None) for k,v in props.items()}
            attrName= attr if attr in props.keys() else attr_alias_dict[attr]
            assert attrName, f"Cannot find attribute name in class '{className}' with query '{attr}'"
            val = copy.deepcopy(getattr(self, attrName))
            if val is None:
                logger_print("Warning: Attribute '{attr}' of class '{className}' is None. Using zero instead.")
                return 0

            desc = props[attr]['description']
            val_units = desc.replace("：", ":").split(":")[-1].strip()

            units = []
            for i, unit in enumerate(val_units.replace("，", ",").split(",")):
                u = unit.strip()
                if u:
                    units.append(u)
            
            varNames = attrName.replace("-","_").split("_")
            assert len(varNames) == len(units), f"units length ({units}) does not match varname length ({varNames}).\nfailed to parse unit for: {className}.{attrName}"
        
            assert len(units)>0, f"{className}.{attrName} does not have unit definition"

            crlist = []

            for val_unit in units:
                ConversionRate, StandardUnit = unitFactorCalculator(ureg, standard_units, val_unit)
                logger_print(f"Converting param {varNames[i]} at {className}.{attrName}: {val_unit} -> {StandardUnit} (magnitude: {ConversionRate})")
                crlist.append(ConversionRate)

            len_varNames = len(varNames)

            if not {{ IsIterable('val') }}:
                assert len_varNames == 1, f"input value {val} failed to match shape of class {className}.{attrName} (len: {len_varNames})"
                ret_val = val*crlist[0]
            elif not {{ IsIterable('val[0]') }} :
                assert len_varNames == 1, f"input value {val} failed to match shape of class {className}.{attrName} (len: {len_varNames})"
                ret_val = [v*crlist[0] for v in val]
            else:
                # verify shape here.
                ret_val = []
                for it in val:
                    assert len(it) == len_varNames, f"input value {it} failed to match shape of class {className}.{attrName} (len: {len_varNames})"
                    ret_val.append([it[i]*crlist[i] for i in range(len_varNames)])
            return ret_val

{% endfor %}

class 设备信息(设备基础信息):
{% for i in deviceOptionalIdentifiers%}
    {{i}}: {{normal_str}} = Field(title = "{{i}}")

{% endfor %}

{# 设备特有类型 #}
from enum import auto
import sys
{# 
if sys.version_info >= (3,11):
    from enum import StrEnum
else:
    from strenum import StrEnum #}
from strenum import StrEnum


class 风力发电类型(StrEnum):
    变桨 = auto()
    定桨 = auto()
    标幺值 = auto()

class 油耗规划算法(StrEnum):
    平均= auto()
    最佳= auto()

class 新能源消纳约束(StrEnum):
    无 = auto()
    惩罚代价 = auto()
    限制消纳率 = auto()

class 负荷类型(StrEnum):
    Normal = auto()
    Punished = auto()
    Flexible = auto()
    Interruptable = auto()
    InterruptableAndFlexible = auto()

class Direction(StrEnum):
    Directed = auto()
    Bidirectional = auto()

{% set NonLoadDeviceDict = {}%}

{# 不是标准单位 #}
{% set gasEmissionUnit = "kg/L" %}
{% set fuelEmissionUnits = {} %}
{% for gas in [
        "CO2",
        "NOX",
        "SO2"
    ]
%}
    {% do fuelEmissionUnits.update({gas: gasEmissionUnit}) %}
{% endfor %}
{% set 燃料能源相关数据默认单位 = {
    '柴油': {
        "Price": "万元/L",
        "热值": "kWh/L",
        }
    }
%}
{%set RenewableEnergyDevices = ['风力发电', '光伏发电']%}
{% for key in 燃料能源相关数据默认单位.keys()%}
    {% do 燃料能源相关数据默认单位[key].update(fuelEmissionUnits) %}
{% endfor %}
{% for super_class, class_name, mstrs, mdigits, mtables in 设备库 %}
    {% do NonLoadDeviceDict.update({class_name: (super_class, mstrs, mdigits, mtables)})%}
{% endfor %}
{% for class_name in 设备接口集合.keys() %}

class {{class_name}}信息({{"设备基础信息" if class_name not in NonLoadDeviceDict.keys() else "设备信息"}}):
            
    {% if class_name not in NonLoadDeviceDict.keys() %}
        {% if class_name in load_class_names %}
    LoadType: 负荷类型 = Field(default = 负荷类型.Normal, title = "负荷类型", description = f"可选: {', '.join(负荷类型.__members__.keys())}")

    # 正数
    PunishmentRate: confloat(ge=0) = Field(default = 0, title = "惩罚系数", description="单位: 元/kWh")
    """
    单位: 元/kWh
    """

    Pmin : confloat(ge = 0) = Field(default = 0,title = "负荷功率最小值", description = "单位: kW")
    """
    单位: kW
    """
    
    Pmax : confloat(ge = 0) = Field(default = 0,title = "负荷功率最大值", description = "单位: kW")
    """
    单位: kW
    """

    @validator('Pmax')
    def validate_Pmax(cls, v, values):
        if values.get('LoadType', None) in [负荷类型.Flexible, 负荷类型.InterruptableAndFlexible]:
            p_min = values.get('Pmin', 0)
            assert v >= p_min, f"Pmax must be greater than or equal to Pmin\nGiven: Pmax={v}, Pmin={p_min}"
        return v
            

    EnergyConsumption: List[{{non_neg_float}}] = Field(title = '耗能功率表', description='单位: kW')
    """
    单位: kW
    {# In this way it will be timescale independent. #}
    """

    MaxEnergyConsumption: Union[None, {{pos_float}}] = Field(default = None, title = "最大消耗功率", description = '单位: kW\n用于典型日下计算变压器容量')
    """
    单位: kW
    {# 用于电负荷 典型日计算 #}
    """

            {% if class_name in ["电负荷"]%}
    PriceModel: Union[常数电价, 阶梯电价, 分时电价, 分时阶梯电价, 分月电价, 分时分月电价] = Field(title = '计价模型', description='单位: kWh/元')
            {% else %}
                {% error("未找到'{}'的计价模型".format(class_name)) %}
            {% endif %}
        {% else %}
            {% if class_name in 燃料能源相关数据默认单位.keys() %}
                {% for attrName, defaultUnit in 燃料能源相关数据默认单位[class_name].items()%}
    {{ attrName}} : Tuple[{{pos_float}}, {{normal_str}}] = Field(title = "{{attrName}}", description="格式: [数值,单位]")
    """
    格式: [数值,单位]
    """
                {% endfor%}

    class DefaultUnits:
                {% for attrName, defaultUnit in 燃料能源相关数据默认单位[class_name].items()%}
        {{attrName }} = "{{defaultUnit}}"
                {%endfor%}
            {% else%}
                {% error("未知负荷信息类型:", class_name)%}
            {% endif%}
        {% endif%}
    {% else %}
        {% set super_class, mstrs, mdigits, mtables = NonLoadDeviceDict[class_name] %}
        {# special variables for non-load device info #}
        {# {% if class_name in ['锂电池']%} #}
    {# needStorageDecayCompensation : bool = Field(default=True, title = "是否允许可变存储衰减补偿", description = "开启后存储衰减补偿将可变，反之存储衰减补偿等于存储衰减") #}
        {% if class_name in ['传输线'] %}
    Optimize:bool = Field(default = False, title ="是否优化线径", description="若选是，根据电负荷峰值确定传输电功率; 选否，则输入给定传输电功率值")
    U:confloat(gt=0) = Field(title = "传输电压", description = "单位: kW")
    """
    单位: kW
    """
    Rho:confloat(gt=0) = Field(title = "传输线电阻率", description = "单位: Ω*m")
    """
    单位: Ω*m
    """
    GivenAveragePower:confloat(gt = 0) = Field(title = '平均功率', description = "单位: kW")
    """
    单位: kW
    """
    GivenMaxPower:confloat(gt = 0) = Field(title = '峰值功率', description = "单位: kW")
    """
    单位: kW
    """

    Pwire_Asec_Pr: List[Tuple[confloat(gt=0), confloat(gt=0), confloat(gt=0)]] = Field(title = "传输电功率上限-截面积-单位长度价格", description="单位：kW，mm2，万元/km")
    """
    Pwire（传输电功率上限）
    单位：kW
    
    Asec（截面积）
    单位：mm2
    
    Pr（单位长度价格）
    单位：万元/km
    """
        {% elif class_name in RenewableEnergyDevices%}
    RenewableEnergyConsumptionConstraint: 新能源消纳约束 = Field(default = 新能源消纳约束.无, title= "新能源消纳约束", description = "无、惩罚代价、限制消纳率" )
    RenewableEnergyConsumptionPunishmentRate: confloat(ge=0) = Field(default=0, title = "新能源消纳约束惩罚代价", description = "单位: 元/kWh")
    """
    单位: 元/kWh
    """
    RenewableEnergyConsumptionRate: confloat(ge=0, le=100) = Field(default=0, title = "新能源消纳率",description = "单位: percent")
    """
    单位: percent
    """
    @validator("RenewableEnergyConsumptionPunishmentRate")
    def validate_RenewableEnergyConsumptionPunishmentRate(cls, v, values):
        if values.get('RenewableEnergyConsumptionConstraint', 新能源消纳约束.无) == 新能源消纳约束.惩罚代价:
            assert v>0, f"不合理的惩罚代价：{v}"
        return v
            {% if class_name in ['风力发电'] %}
    machineType: 风力发电类型 = Field(default=风力发电类型.变桨, title = '选择风力发电类型', description = "定桨、变桨（默认）、标幺值")
    normalizedPower: Union[None, List[float]]= Field(default=None, title="风力发电标幺值", description = "空或数组(典型日长度为24,全年逐时长度为8760,秒级长度为7200)")
            {%endif%}
        {% elif class_name in ['柴油发电']%}
    {# 机组年运行时间约束:bool (若选否，变量约束不创建，变量为自由变量，降低计算量)  #}
    {# unitAnnualOperatingTimeConstraint:bool #}
    {# {{cws("Unit annual operating time constraint")}}:bool=Field(default = False, title="机组年运行时间约束", description="若选否，变量约束不创建，变量为自由变量，降低计算量") #}
    unitAnnualOperatingTimeConstraint:bool=Field(default = False, title="机组年运行时间约束", description="若选否，变量约束不创建，变量为自由变量，降低计算量")
    {# 机组年运行时间最高限值，单位：次。 #}
    maximumAnnualOperatingTimeLimitOfTheUnit:conint(ge=0)=Field(default=0, title="机组年运行时间最高限值", description="单位：小时")
    {# {{cws("Maximum annual operating time limit of the unit")}}:bool=Field(default = False, title="机组年运行时间最高限值", description="单位：次") #}
    {# 考虑机组启动费用:bool(若选否，变量约束不创建，变量为自由变量，降低计算量) #}
    considerUnitStartUpCosts:bool=Field(default = False, title="考虑机组启动费用", description="若选否，变量约束不创建，变量为自由变量，降低计算量")
    {# 机组单次启动费用，单位：元/次 #}
    unitSingleStartupCost:conint(ge=0) =Field(default =0, title="机组单次启动费用", description="单位：元/次")
    {# 机组规划算法选择 (平均油耗规划算法或者最佳油耗规划算法)。 #}
    unitPlanningAlgorithmSelection: 油耗规划算法=Field(default =油耗规划算法.平均 ,title="机组规划算法选择", description="平均/最佳")
    {# 平均负载率: (如果是平均油耗规划算法，需要填写，否则默认为空） #}
    averageLoadRate : confloat(ge=0, le=100) = Field(default =0, title="平均负载率", description="单位：percent")
            {% elif class_name in ['变压器']%}
    direction: Direction = Field(default= Direction.Directed, title = "单双向模式",description="默认为单向")
        {% endif%} 
        {% set visited_fields = []%}
        {% for psc, mstr in mstrs %}
            {%if mstr not in deviceIdentifiers%}
                {% if mstr not in visited_fields%}
                    {% do visited_fields.append(mstr)%}
    {{ mstr }}: {{normal_str}} = Field(title = "{{mstr}}")
                {% endif%}

            {% endif%}
        {% endfor %}
    
        {% for psc, mdigit in mdigits %}
            {% set mstr = mdigit[0]%}
            {% if mstr not in visited_fields%}
                {% do visited_fields.append(mstr)%}
    {{ mstr }}: {{non_neg_float}} = Field(title = "{{mdigit[1]}}", description =   "名称: {{ mdigit[1] }}\n单位: {{ mdigit[2] }}")
    """
    名称: {{ mdigit[1] }}
    单位: {{ mdigit[2] }}
    """
                {% if mdigit[2] == 'percent'%}
                {# {% do percent_fields.append(mdigit[1])%} #}
    @validator({{repr(mstr)}})
    {# @validator({{validate_params}}) #}
    def validate_{{mstr}}_for_percent_warning(cls, value):
        warning_msg = None
        field_name = {{repr(mstr)}}
        if value <= ies_env.PERCENT_WARNING_THRESHOLD:
            warning_msg = f"Field '{field_name}' (value: {value}; unit: percent) passed to class '{cls.__name__}' is less than or equal to {ies_env.PERCENT_WARNING_THRESHOLD}"
        if warning_msg is not None:
            if ies_env.UNIT_WARNING_AS_ERROR:
                {# raise ValidationError(warning_msg) #}
                raise Exception(warning_msg)
            else:
                logger_print(warning_msg)
        return value
                {%endif%}

            {% endif%}
        {% endfor %}

        {% for psc, main, sub in mtables %}
            {% set mtable=(main, sub)%}
            {% set mstr = mtable[0][0]+"_"+mtable[1][0] %}
            {% if mstr not in visited_fields%}
                {% do visited_fields.append(mstr)%}
    {{ mstr}} : List[Tuple[{{pos_float}},{{non_neg_float}}]] = Field(title = "{{ mtable[0][1]}}_{{ mtable[1][1]}}", description=   "{{ mtable[0][0]}}: {{ mtable[0][1]}}\n单位: {{ mtable[0][2]}}\n{{ mtable[1][0]}}: {{ mtable[1][1]}}\n单位: {{ mtable[1][2]}}")
    """
    {{ mtable[0][0]}}: {{ mtable[0][1]}}
    单位: {{ mtable[0][2]}}

    {{ mtable[1][0]}}: {{ mtable[1][1]}}
    单位: {{ mtable[1][2]}}
    """

            {%endif%}
        {% endfor %}

    {# validators #}
        {%if class_name in ['风力发电']%}
    @validator("RatedPower")
    def checkRatedPower(cls, v, values):
        CutoutPower = values.get('CutoutPower', None)
        if CutoutPower is None:
            # instead of Exception, which will make pydantic panic!
            raise ValidationError("风力发电没有传入切出功率")
        else:
            assert CutoutPower <= v, f"切出功率({CutoutPower})必须小于额定功率({v})" 
        return v
        {% endif %}

        {# {% if percent_fields != []%}
            {% set validate_params = ""%}
            {% for field_name in percent_fields%}
                {% set validate_params = validate_params + repr(field_name)+ ","%}
            {%endfor%} #}
        {# @validator({{validate_params}})
        def validate_percent_fields(cls, value):
            warning_msg = None
            if value <= ies_env.PERCENT_WARNING_THRESHOLD:
                warning_msg = f"value '{value}' at field '{field_name}' passed to class '{cls.__name__}'"
            if warning_msg is not None:
                if ies_env.UNIT_WARNING_AS_ERROR:
                    raise Exception(warning_msg)
                else:
                    logger_print(warning_msg)
            return value #}
        {# {% endif %} #}
    {% endif %}
{% endfor %}

####################
# model definition #
####################

{# from pyomo.environ import * #}

{# from pyomo.core.expr.sympy_tools import sympyify_expression, sympy2pyomo_expression #}
from sympy.polys.polytools import Poly
import re
from sympy import sympify
# taking too long. recursion.
from progressbar import progressbar
{# 
def find_parentheses(s):
    stack = []
    result = [] # EIPList
    for i, c in enumerate(progressbar(s)):
        if c == '(':
            stack.append(i) # 记录左括号的位置
        elif c == ')':
            if stack: # 如果栈不为空
                start = stack.pop() # 弹出最近的左括号位置
                if not stack: # 如果栈为空，说明找到了一个最外层的括号对
                    result.append(s[start:i+1]) # 将括号对加入结果列表
    return result #}

from expr_utils import getExprStrParsedToExprList

{# mystr = '(1,2,3), (((1+2),2),5,(6,7)) 23'
logger_print(find_parentheses(mystr)) #}

def withBanner(banner: str = ""):
    def decorator(func):
        def inner_func(*args, **kwargs):
            logger_print(f"_____________{banner}_____________")
            val = func(*args, **kwargs)
            logger_print(f"_____________{banner}_____________")
            return val
        return inner_func
    return decorator


@withBanner("ERROR LOG")
def examineSubExprDegree(expr):
    data = str(expr)
    exprlist = getExprStrParsedToExprList(data)
    {# logger_print("SPLITING EXPR")
    expr_repr = str(expr)
    regex = re.compile(r'(\[\d+\])')
    subs = regex.findall(expr_repr)
    subs = set(subs)
    for sub in subs:
        num = sub.strip("[").strip("]")
        expr_repr = expr_repr.replace(sub, f"_Array")
    EIPList = find_parentheses(expr_repr)
    elems_in_parentheses = set(EIPList)

    EIPMAP = {e: f'EIP_{i}' for i, e in enumerate(elems_in_parentheses)}
    EIPMAP_REV = {v:k for k,v in EIPMAP.items()}
    for EIP, EIP_CODE in EIPMAP.items():
        expr_repr = expr_repr.replace(EIP, EIP_CODE)
    
    subexpr_strs = expr_repr.replace("-", "+ -").split("+") #}
    logger_print("ANALYSING TERMS")
    for subexpr in progressbar(exprlist):
        {# subexpr_str = subexpr_str.strip()
        if len(subexpr_str) == 0:
            continue
        for k,v in EIPMAP_REV.items():
            subexpr_str = subexpr_str.replace(k,v)
        subexpr = sympify(subexpr_str) #}
        subpoly = Poly(subexpr)
        subpoly_deg = subpoly.total_degree()
        if subpoly_deg not in [0,1]:
            logger_print()
            logger_print("Abnormal subexpression poly degree:", subpoly_deg)
            # recover expression representation
            {# subexpr_pyomo = sympy2pyomo_expression(subexpr, objmap)
            subexpr_pyomo_repr = str(subexpr_pyomo) #}
            logger_print("Abnormal expression:", subexpr)
            {# logger_print("Abnormal expression:", subexpr_pyomo_repr) #}
    logger_print()

from collections import defaultdict

{% macro initSubmodelRelatedTranslationTable(attrName)%}
        self._{{attrName}} = "default{{pascalize(attrName)}}"
        self.varNameTo{{pascalize(attrName)}} = cast(Dict[str, str], defaultdict(lambda: "unknown{{pascalize(attrName)}}"))
        self.{{attrName}}ToVarName = cast(Dict[str, List[str]], defaultdict(lambda: []))
        self.{{attrName}}ToVarName.update({self._{{attrName}}: []})
        {# self.{{attrName}}ToVarName: Dict[str, List[str]] = {self._{{attrName}}: []} #}
{% endmacro%}
{% macro setupSubmodelRelatedProperty(attrName)%}
    def set{{pascalize(attrName)}}(self, {{attrName}}:str):
        assert isinstance({{attrName}}, str), f"{{attrName}} must be a string!\n{{attrName}}: {repr({{attrName}})}"
        assert len({{attrName}})>=1, "zero length {{attrName}} submitted."
        {{attrName}} = {{attrName}}.strip()
        self._{{attrName}} = {{attrName}}
        self.{{attrName}}ToVarName[{{attrName}}] = self.{{attrName}}ToVarName.get({{attrName}}, []) 
    def get{{pascalize(attrName)}}(self):
        return self._{{attrName}}
    {{attrName}} = property(fset=set{{pascalize(attrName)}}, fget=get{{pascalize(attrName)}})
{% endmacro%}
{% macro modifySubmodelRelatedTranslationTable(attrName)%}
        self.varNameTo{{pascalize(attrName)}}[name] = self.{{attrName}}
        self.{{attrName}}ToVarName
        self.{{attrName}}ToVarName[self.{{attrName}}].append(name)
        self.keyword_processor.add_keyword(name)
{% endmacro%}
{% macro dynamicProperty(attrName)%}
{% set getter=attrName+"Getter"%}
{% set setter=attrName+"Setter"%}
    def {{getter}}(self):
        return self._{{attrName}}
    def {{setter}}(self, val):
        self._{{attrName}} = val

    {{attrName}} = property(fget = {{getter}}, fset = {{setter}})
{% endmacro%}
{% set submodelRelatedAttrs = ['submodelName', 'submodelClassName'] %}
{% set objectiveRelatedAttrs = ['obj', 'obj_expr'] %}

import flashtext

class SharedParams(BaseModel):
    典型日: bool
    计算步长: Literal["小时", '秒']
    计算类型: Literal['仿真模拟', '设计规划']
    计算目标: Literal['经济','环保','经济_环保']

class InputParams(SharedParams):
{# class InputParams(BaseModel): #}
    calcParamList: List
    {# calcTarget: str #}
    {# 典型日
    计算步长
    计算类型 #}
    rangeDict: Union[None, dict] 
    needResult: bool 
    additional_constraints: dict

class ModelWrapper:
    {# __slots__ = ['obj',"obj_expr"] #}
    inputParam: InputParams
    def __init__(self, model:Optional[ConcreteModel]=None, cloned:bool = False):
        self.model = model if model is not None else ConcreteModel()
        self.clock = {}
        self.cloned = cloned
        self.assumptions: List[Callable] = []
        self.keyword_processor = flashtext.KeywordProcessor()
{% for objRelatedAttr in objectiveRelatedAttrs %}
        self._{{objRelatedAttr}} = ...
{% endfor %}
    {# still inside __init__ method #}
{{applyMacroWithSingleParam(initSubmodelRelatedTranslationTable, submodelRelatedAttrs)}}
        # TODO: put assumptions into here after any operation using BigM notation (like multiplication)
    {# still inside __init__ method #}

{{applyMacroWithSingleParam(dynamicProperty, objectiveRelatedAttrs)}}


{{applyMacroWithSingleParam(setupSubmodelRelatedProperty, submodelRelatedAttrs)}}
    def check_assumptions(self):
        # TODO: call this function after model solved.
        for assumption in self.assumptions:
            assumption()
        self.assumptions = [] # clear assumptions
    def word_counter(self, text: str) -> Dict[str, int]:
        keywords_found = self.keyword_processor.extract_keywords(text)

        keyword_counts = {}
        for keyword in keywords_found:
            keyword_counts[keyword] = keyword_counts.get(keyword, 0) + 1

        return keyword_counts
    def __del__(self):
        del self.model
        del self.clock
        del self
    def getSpecialName(self, key:str):
        val = self.clock.get(key,0)
        name = f"{key}_{val}"
        self.clock[key] = val+1
        return name
    {% for k in ['Constraint', 'Var','Objective']%}
    {% set mv = "*args, **kwargs"%}
    def {{k}}(self, {{ "name:str," if k == "Var" else ""}} {{ mv}}):
        {% if k !="Var" %}
        expr = kwargs.pop('expr',args[0] if len(args) >0 else None)
        if expr is None:
            logger_print("ARGS:", args)
            logger_print("KWARGS:", kwargs)
            raise Exception("Not passing expression to method '{{k}}'")
        deg = getattr(expr, "polynomial_degree", 0)
        if deg:
            deg = expr.polynomial_degree()
        {# deg = expr.polynomial_degree() #}
        if deg != 1:
            logger_print("EXPR DEG:", deg)
            expr_repr =f"{str(expr) if len(str(expr))<200 else str(expr)[:200]+'...'}"
            logger_print('EXPR:',  expr_repr)
            # only if deg > 0 we need further inspection.
            if deg >0:
                # TODO: use regex to simplify expression here.
                {# logger_print("_____________ERROR LOG_____________") #}
                examineSubExprDegree(expr)
                {# logger_print("_____________ERROR LOG_____________") #}
            error_msg = f"[{{k}}] Unacceptable polynomial degree for expression."
            raise Exception(error_msg)
        name = self.getSpecialName("{{k[:3].upper()}}")
        {% endif %}
        {% set init_argname = "initialize"%}
            {# {% if k == 'Var'%}
        _{{init_argname}} = kwargs.get({{qstr(init_argname)}}, 0)
        _{{init_argname}} = kwargs.get({{qstr(init_argname)}}, None)
            {% endif %} #}
        {# now we refuse to initialize anything. including var.#}
        if {{qstr(init_argname)}} in kwargs.keys():
            del kwargs[{{qstr(init_argname)}}]
        {% if k == 'Var'%}
        {# if VAR_INIT_AS_ZERO in os.environ.keys(): # test override. #}
        if ies_env.VAR_INIT_AS_ZERO is not None:
            kwargs[{{qstr(init_argname)}}] = 0
        {% endif %}
        ret = {{k}}({{mv if k == "Var" else "expr = expr, *args[1:], **kwargs"}})
        {# ret = {{k}}({{mv+", {}=_{}".format(init_argname, init_argname) if k == "Var" else "expr = expr, *args[1:], **kwargs"}}) #}
        {% if k == 'Objective'%}
        self.obj = ret
        self.obj_expr = expr
        {% endif%}
{{double_check_setattr("self.model", "name", 'ret') | indent(2*4, true)}}
{{applyMacroWithSingleParam(modifySubmodelRelatedTranslationTable, submodelRelatedAttrs)}}
        {# self.model.__setattr__(name, ret) #}
        return ret
    {% endfor%}
    def Block(self, model:Optional[ConcreteModel]=None, cloned:bool = False):
        wrapper = ModelWrapper(model, cloned=cloned)
        name = self.getSpecialName("BLK")
        self.model.__setattr__(name, wrapper.model)
{{applyMacroWithSingleParam(modifySubmodelRelatedTranslationTable, submodelRelatedAttrs)}}
        return wrapper




# first convert the unit.
# assign variables.

# shall you assign port with variables.

# 风、光照

# 需要明确单位
{# class 计算参数(BaseModel): #}
class 计算参数(SharedParams):
    典型日ID: Union[{{non_neg_int}}, None] = None # increse by external loop
    {# 计算步长: Literal["小时", '秒'] #}
    {# 典型日: bool #}

    分时计价开始时间点: float = Field(default=0, title = '秒级仿真时 开始时间在一天中的哪个小时', description=f"取值范围: 0-{每天小时数}", ge=0, le=每天小时数)

    {# @validator('分时计价开始时间点')
    def validate_starting_time(cls, v):
        assert v>=0, f"开始时间点大于等于0\n实际: {v}"
        assert v<=24, f"开始时间点小于等于24\n实际: {v}"
        return v #}

    分时计价开始月份: int = Field(default=0, title = '秒级仿真时 开始时间在一年中的哪个月份', description="取值范围: 0-11", le=11, ge=0)

    {# @validator('分时计价开始月份')
    def validate_starting_month(cls, v):
        assert v>=0, f"开始月份大于等于0\n实际: {v}"
        assert v<=11, f"开始月份小于等于11\n实际: {v}"
        return v
     #}
    {# 典型日权重: int = 0 #}
    典型日代表的日期: conlist(conint(ge=0, lt=365), min_items=0, max_items=365, unique_items=True)= []
    @validator('典型日代表的日期')
    def validate_typical_day(cls, v, values):
        if values['典型日']:
            len_v = len(v)
            assert len_v >0
            assert len_v <= 365
            {# if len_v <= 0:
                raise ValidationError(f"典型日代表日期不应小于等于0\n实际长度：{len_v}")
            if len_v  >365:
                raise ValidationError(f"典型日代表日期不应大于365\n实际长度：{len_v}") #}
        return v
    {# 计算类型: Literal['仿真模拟', '设计规划'] #}
    {# 计算目标: Literal['经济','环保','经济_环保'] #}
    风速: List[{{non_neg_float}}]
    """
    单位: m/s
    """
    光照: List[{{non_neg_float}}]
    """
    单位: kW/m2
    """
    气温: List[{{non_neg_float}}]
    """
    单位: 摄氏度
    """
    贴现率: confloat(ge=0, le=100) = Field(title = "贴现率", description = "单位: percent")
    {# 年利率: float #}
    """
    单位: percent
    """
    @property
    def 迭代步数(self):
        {# steps = None #}
        if self.计算步长 == "秒":
            steps = 两小时秒数
        elif self.计算步长 == "小时" and self.典型日 is False:
            steps = 每年小时数
        elif self.计算步长 == "小时" and self.典型日 is True:
            steps = 每天小时数
        else:
            logger_print(self)
            raise Exception("未知计算参数")
        errors = []

        {% for t in ['风速','光照','气温']%}
        if not len(self.{{t}}) == steps:
            errors.append(f'{{t}}长度应该是{steps} 实际:{len(self.{{t}})}')
        {% endfor%}

        if errors:
            raise Exception("\n".join(errors))
        return steps
    
    {# @lru_cache(maxsize=1) #}
    @property
    def 时间参数(self):
        """
        如果计算步长为秒，那么返回3600
        如果计算步长为小时，那么返回1

        相当于返回一小时内有多少计算步长
        """
        return (1 if self.计算步长 == "小时" else 每小时秒数)

    @property
    def deltaT(self):
        """
        如果计算步长为秒，那么返回1/3600
        如果计算步长为小时，那么返回1

        相当于返回一个计算步长内有多少小时
        """
        return (1/self.时间参数)
    
    @property
    def 总计算时长(self):
        """
        返回该计算模式下总共有多少小时
        """
        return self.迭代步数 / self.时间参数

    {# @property # 提前计算好了
    def 典型日列表(self): # 
        ... #}
    {# # like: (tday_index, tday_data, tday_count) #}

class POSNEG:
        {% set POSNEGParamNames = ["x", "x_pos", "x_neg", "b_pos", "b_neg", "x_abs"] %}
    def __init__(self, {{",".join(POSNEGParamNames)}}):
        {%for f in POSNEGParamNames%}
        self.{{f}} = {{f}}
        {%endfor%}

{# from functools import reduce #}
{# import functools #}
{% set financial_param_names = [
            "总采购成本",
            "总建设费用",
            "总固定维护成本",
            "总固定成本年化",
            "总成本年化",
            "总可变维护成本年化"
        ]
%}
{{import_type_fallback("Protocol")}}

class 可购买类(Protocol):
    是否购买: ...
    {% for e0 in financial_param_names%}
    {{e0}}: ...
    {% endfor%}
    def BinVarMultiplySingle(self, *args, **kwargs): ...

class 设备模型:
    def __init__(self, PD: dict, mw: ModelWrapper, 计算参数实例: 计算参数, ID: int):
        logger_print("Building Device Model:", submodelClassName:=self.__class__.__name__)
        submodelName = f"{submodelClassName}_{ID}"
        self.mw = mw
{% for attrName in submodelRelatedAttrs %}
        self.mw.{{attrName}} = {{attrName}}
{% endfor%}
        self.PD = PD
        self.计算参数 = 计算参数实例
        self.ID = ID
        self.SID = 0
        {# self.BigM = 1e+8  #}
        self.BigM = 1e+7 # 这个数不能太大 否则就会报错
        {# self.BigM = 1e+12 #}
        """
        一个极大数
        """
        self.EPS = 1e-4
        {# usually you want to use it in initialization, not constraints! #}
        """
        一个极小数
        """
        {% for e0 in financial_param_names %}
        self.{{e0}} = 0
        {% endfor %}
        self.年化率 = ...
    
    def TimeSummation(self, target:list, source, mrange = None):
        mrange = self.getRange(mrange)
        for i in mrange:
            target[i]+= source[i]
        return target

    @staticmethod
    def 处理最终财务输出(mclass: 可购买类):
        {% for e0 in financial_param_names%}
        mclass.{{e0}} = mclass.BinVarMultiplySingle(mclass.是否购买, mclass.{{e0}})
        {% endfor %}
    
    def constraints_register(self):
        if self.__class__.__name__ == "设备模型":
            raise NotImplementedError("Must be implemented by subclasses.")
        logger_print("REGISTERING: ", self.__class__.__name__)

    def getVarName(self, varName: str):
        VN = f"DI_{self.ID}_VN_{varName}" # use underscore.
        if self.计算参数.典型日ID is not None: # starting from 0, so be careful!
            VN = f"TD_{self.计算参数.典型日ID}_"+VN
        return VN
    
    def getSpecialVarName(self, varName:str):
        specialVarName = f"SP_{self.SID}_{varName}"
        self.SID +=1
        return specialVarName

    def 单变量(self, varName: str, **kwargs):
        var = self.mw.Var(self.getVarName(varName) ,**kwargs)
        return var
    
    def getRange(self, mrange:range = None):
        if mrange is None: mrange = range(self.计算参数.迭代步数)
        return mrange

    def 变量列表(self, varName: str, mrange:range = None, **kwargs):
        var = self.mw.Var(self.getVarName(varName) ,self.getRange(mrange), **kwargs)
        return var

    def RangeConstraint(self, var_1, var_2,  expression=... ,mrange:range = None):
        assert expression !=...
        for i in self.getRange(mrange):
            self.mw.Constraint(expression(var_1[i], var_2[i]))

    def RangeConstraintMulti(self, *vars, expression=..., mrange:range=None): # keyword argument now.
        assert expression is not ...
        for i in self.getRange(mrange):
            self.mw.Constraint(expression(*[var[i] for var in vars]))

    def CustomRangeConstraint(self, var_1, var_2,  customRange:range=..., expression= ...):
        assert customRange is not ...
        for i in customRange:
            self.mw.Constraint(expression(var_1, var_2, i))
    
    def CustomRangeConstraintMulti(self, *vars, customRange:range=..., expression=...):
        assert expression is not ...
        assert customRange is not ...
        for i in customRange:
            self.mw.Constraint(expression(*vars, i))
    
    def SumRange(self,var_1,  mrange:range=None):
        return {{- sum_reduce('[var_1[i] for i in self.getRange(mrange)]')}}
    
    def 单变量转列表(self, var,  dup:int=None):
        if dup is None:
            dup = self.计算参数.迭代步数
        return [var for _ in range(dup)]
    
    def 单表达式生成指示变量(self, varName: str, expr):
        # where to exclude type from type hints?
        # or what language can express type exclusion?
        posneg = self.变量列表_带指示变量(varName, exprList=[expr], mrange = range(1))
        ret = POSNEG(posneg.x[0], posneg.x_pos[0], posneg.x_neg[0], posneg.b_pos[0], posneg.b_neg[0], posneg.x_abs[0])
        return ret
    
    def 变量列表_带指示变量(self, varName:str,  exprList:list=None, within= Reals, mrange:range=None) -> POSNEG:
        if exprList:
            x = exprList
        else:
            x = self.变量列表(varName,within=within, mrange = mrange)

        {% for flag in ['pos', 'neg'] %}
        b_{{flag}} = self.变量列表(self.getSpecialVarName(varName), within = Boolean, mrange = mrange)
        x_{{flag}} = self.变量列表(self.getSpecialVarName(varName), within = NonNegativeReals, mrange = mrange)

        self.RangeConstraint(b_{{flag}}, x_{{flag}}, lambda x,y: x*self.BigM >= y, mrange = mrange)
        {% endfor %}

        self.RangeConstraint(b_pos, b_neg, lambda x,y: x+y == 1, mrange = mrange)

        self.RangeConstraintMulti(x, x_pos, x_neg, expression = lambda x,y,z: x == y-z , mrange = mrange)

        x_abs = self.变量列表(self.getSpecialVarName(varName), within = NonNegativeReals, mrange = mrange)

        self.RangeConstraintMulti(x_pos, x_neg, x_abs, expression = lambda x,y,z : z == x+y, mrange = mrange)

        posneg = POSNEG(x, x_pos, x_neg, b_pos, b_neg, x_abs)

        return posneg
    
    def Piecewise(self, 
        x_var, # x_var
        y_var, # y_var
        x_vals: List[float],
        y_vals: List[float],
         {#  #}
     range_list:Union[List[int], None]=None, 
     pw_repn='MC', 
     {# pw_repn='SOS2',  #}
     pw_constr_type='EQ', unbounded_domain_var=True):

        # TODO: if performance overhead is significant, shall use "MC" piecewise functions, or stepwise functions.

        # BUG: x out of bound, resulting into unsolvable problem.
        assert x_vals[0] <= x_vals[-1]
        expand_val = 1e+3
        _x_vals = [x_vals[0]-expand_val] + x_vals +[ x_vals[-1]+expand_val]
        _y_vals = [y_vals[0]] + y_vals +[ y_vals[-1]]

        if range_list is None:
            range_list = list(range(self.计算参数.迭代步数))
        PWL = []
        for i in range_list:
            piecewise_name = self.getSpecialVarName("PW")
            PW = Piecewise(
            y_var[i],
            x_var[i],
            pw_pts=_x_vals,
            f_rule=_y_vals,
            pw_repn=pw_repn,
            pw_constr_type=pw_constr_type,
            unbounded_domain_var=unbounded_domain_var,
            warn_domain_coverage=False, # to suppress warning
        )
{{double_check_setattr("self.mw.model", "piecewise_name", "PW") | indent(3*4, true)}}

            {# assert getattr(self.mw.model,piecewise_name, None) is None, f"错误: 不能设置两次相同的变量名称\n重复变量: {piecewise_name}"
            self.mw.model.__setattr__(piecewise_name, PW)
            PWL.append(PW) #}
        return PWL

    @staticmethod
    def breakdownExpression(expr):
        expr_type = type(expr)

        assert expr_type != {{IndexedVar}}, f"Expression: {repr(expr)[:200]}\nInvalid expression type."

        {# numeric_types = [float, int]
        variable_types = [ScalarVar, {{GeneralVarData}}] #}
        # otherwise, expression types.
        {# results = [] #}
        is_linear, results = pyomo.core.expr.current.decompose_term(expr)
        if is_linear:
            return results
        else:
            examineSubExprDegree(expr)
            raise Exception(f"Nonlinear expression found while breaking down.\nExpression type: {type(expr)}")
        {# if expr_type in numeric_types:
            results.append((expr))
        else:
            # implement expression breakdown. usually pyomo expressions.
            try:
                results.append(...)
            except:
                ... #}
    
    def BinVarMultiplySingle(self, b_var, x_var,  recurse=True):
    {# def BinVarMultiplySingle(self, b_var, x_var, recurse=False): #}
        assert b_var.is_binary()
        assert type(x_var) is not {{IndexedVar}}
        {# assert x_var.is_continuous()  #}
        {# x_var can be binary. #}

        {# to eliminate the issue of overflow: #}
        {# approach 1: first divide variable by some number, then multiply by that. (not working) #}
        {# approach 2: if the variable/expression is summation, execute the function elementwise then sum them up. #}
        {# if using APP2, shall do recursion. #}
        {# and mind all occurance of BigMs #}
        numeric_types = [float, int]
        if recurse:
            # tear down x_var
            h_list = []
            for sub_x_var in self.breakdownExpression(x_var):
                _h = self.BinVarMultiplySingle(b_var,sub_x_var, recurse=False)
                h_list.append(_h)
            return sum(h_list)
        else:

            if type(x_var) == tuple:
                assert len(x_var) == 2, f"Invalid `x_var`: {x_var}"
                # format: (factor, x_var)
                assert type(x_var[0]) in [float, int], f"Invalid `x_var` format: {x_var}\nShould be: (factor (float), x_var (Var))"
                factor, _x_var = x_var
                if _x_var is None: # constant.
                    return factor * b_var
            else:
                factor = 1
                _x_var = x_var
                if type(_x_var) in numeric_types:
                    return _x_var * b_var

            h = self.单变量(self.getSpecialVarName("BVM"), within=Reals)

            {# divider = 1e+2 #}

            self.mw.Constraint(h<= b_var* self.BigM)
            self.mw.Constraint(h>= -b_var*self.BigM)
            {# self.mw.Constraint(h <= x_var/divider+(1-b_var)*self.BigM)
            self.mw.Constraint(h >= x_var/divider-(1-b_var)*self.BigM) #}
            self.mw.Constraint(h <= _x_var+(1-b_var)*self.BigM)
            self.mw.Constraint(h >= _x_var-(1-b_var)*self.BigM)
            return h * factor
        {# return h*divider #}

    def Multiply(self,dict_mx:dict, dict_my:dict, varName:str,  precision = 10, within = Reals): # two continuous multiplication
        #  (x+y)^2 - (x-y)^2 = 4xy
        mx, max_mx, min_mx = dict_mx['var'], dict_mx['max'], dict_mx['min']
        my, max_my, min_my = dict_my['var'], dict_my['max'], dict_my['min']
        assert not mx[0].is_binary()
        assert not my[0].is_binary()

        m1posneg = self.变量列表_带指示变量(self.getSpecialVarName(varName))
        self.RangeConstraintMulti(m1posneg.x, mx, my , expression = lambda x,y,z: x == y+z)
        mx_my_sum_var = m1posneg.x_abs
        mx_my_sum_pow2_var = self.变量列表(self.getSpecialVarName(varName))

        m2posneg = self.变量列表_带指示变量(self.getSpecialVarName(varName))
        self.RangeConstraintMulti(m2posneg.x, mx, my, expression = lambda x,y,z: x == y-z)
        mx_my_minus_var = m2posneg.x_abs
        mx_my_minus_pow2_var = self.变量列表(self.getSpecialVarName(varName))

        l0, r0 = min_mx + min_my, max_mx+max_my
        l1, r1 = min_mx - max_my, max_mx-min_my
        def getBound(l0, r0):
            if l0*r0 >=0:
                l0,r0 = abs(l0), abs(r0)
                l, r = min([l0, r0]), max([l0, r0])
            else:
                l0, r0 = abs(l0), abs(r0)
                l, r = 0, max([l0, r0])
            return l, r

        mx_my_sum = np.linspace(*getBound(l0, r0), precision).tolist()

        mx_my_sum_pow2 = [x**2 for x in mx_my_sum]

        mx_my_minus = np.linspace(*getBound(l1, r1), precision).tolist()

        mx_my_minus_pow2 = [x**2 for x in mx_my_minus]

        self.Piecewise(x_var = mx_my_sum_var, y_var = mx_my_sum_pow2_var, x_vals = mx_my_sum, y_vals = mx_my_sum_pow2) # assume it is absolute.

        self.Piecewise(x_var = mx_my_minus_var, y_var = mx_my_minus_pow2_var, x_vals = mx_my_minus, y_vals = mx_my_minus_pow2)

        mx_my_multiply = self.变量列表(varName, within=within)

        self.RangeConstraintMulti(mx_my_sum_pow2_var, mx_my_minus_pow2_var, mx_my_multiply, expression =  lambda x,y,z:(x-y)/4 == z)

        return mx_my_multiply

{% for super_class, class_name, mstrs, mdigits, mtables in 设备库 %}
{% set SO.class_name = class_name %}

class {{class_name}}模型(设备模型):
{{ init_super_class(class_name)}}

        {% set mflag = namespace(val="") %}
        {% if class_name in RenewableEnergyDevices %}
        self.RenewableEnergyConsumptionPunishmentRate = self.设备信息.toStandard("RenewableEnergyConsumptionPunishmentRate")
        self.RenewableEnergyConsumptionConstraint = self.设备信息.RenewableEnergyConsumptionConstraint
        self.RenewableEnergyConsumptionRate = self.设备信息.toStandard("RenewableEnergyConsumptionRate")
        self.discardedRenewableEnergyPower = self.变量列表('discardedRenewableEnergyPower', within=NonNegativeReals)
        self.punishRate = 0
        """
        惩罚代价
        单位：万元/h
        """
        {% endif %}
        {% if class_name in ['柴油发电'] %}
        self.燃料热值:float = 0 # 需要拓扑解析之后进行赋值
            {% for e in ['unitSingleStartupCost', 'averageLoadRate'] %}
        self.{{e}} = self.设备信息.toStandard({{repr(e)}})
            {% endfor %}
        {% elif class_name in ['传输线'] %}
        # params added later
            {% for lateinit_varname in ["U", "Rho", "GivenAveragePower", "GivenMaxPower","Pwire_Asec_Pr"] %}
        self.{{lateinit_varname}} = self.设备信息.toStandard({{repr(lateinit_varname)}})
            {% endfor %}
        {% endif%}
        {% for psc, mdigit in mdigits %}
        {% if psc in ["仿真模拟", "设计规划"] %}
        {# # psc: {{psc}} mflag: {{mflag}} #}
        {% if mflag.val != psc %}
        {% set mflag.val = psc %}
        {# # after: psc: {{psc}} mflag: {{mflag}} #}
        {% set psc2 = "if self.计算参数.计算类型 == '{}'".format(psc) %}
        {{psc2}}:
        {% if psc2 == 设计规划 %}
            # BUG: if unbounded, then we get some error.
            {% if class_name not in ['传输线'] %}
                {# {% if class_name not in ['锂电池','光伏发电']%}
                    {% set mbounds = "bounds = (self.设备信息.MinDeviceCount, self.设备信息.MaxDeviceCount)" %}
                {% endif%} #}
            self.DeviceCount = self.单变量('DeviceCount', within=NonNegativeIntegers) # type: ignore
            {# self.DeviceCount = self.单变量('DeviceCount', within=NonNegativeIntegers, {{mbounds}}) # type: ignore #}
            """
            单位： 个
            """
            {% endif %}
        {% elif psc2 == 仿真模拟 %}
            {% if class_name == '锂电池' %}
            self.DeviceCount = round(self.设备信息.TotalCapacity / self.设备信息.RatedCapacity) # for better user experience.
            {# self.DeviceCount = math.floor(self.设备信息.TotalCapacity / self.设备信息.RatedCapacity) #}
            {% endif %}
        {% else %}
            {% error "[ERROR] invalid branch: {}".format(psc)%}
        {% endif %}
        {%endif%}
{{expand_unit_conversion(mdigit) | indent(4, true)}}
        {# {{expand_unit_conversion(mdigit) | indent(4, True)}} #}
        {% else %}
{{expand_unit_conversion(mdigit,设备参数例外列表) }}
        {% endif %}
        {% endfor %}
        {# {%endwith%} #}

        {% for psc, main, sub in mtables %}
        {% set mtable=(main, sub)%}
        self.{{ mtable[0][0]}}_{{ mtable[1][0]}} : List[List[float]] = [[v1 * {{mtable[0][4]}}, v2 * {{mtable[1][4]}}] for v1, v2 in 设备信息.{{ mtable[0][0]}}_{{ mtable[1][0]}}]
        """
        {{ mtable[0][0]}}: {{ mtable[0][1]}}
        单位: {{ mtable[0][3]}} <- {{ mtable[0][2]}}

        {{ mtable[1][0]}}: {{ mtable[1][1]}}
        单位: {{ mtable[1][3]}} <- {{ mtable[1][2]}}
        """
        self.{{ mtable[0][0]}}_{{ mtable[1][0]}}.sort(key=lambda x: x[1])


        {% endfor %}

{{ port_variable_define(class_name)}}
        
        # 设备特有约束（变量）
        {% if class_name in ['光伏发电','风力发电','柴油发电'] %}
        self.电输出 = self.电接口
            {% if class_name in ["柴油发电"]%}
        self.柴油输入 = self.燃料接口
            {% elif class_name in ['风力发电']%}
        self.单台发电功率 = ...
            {% endif%}
        {% endif%}

        {% if class_name in ['变压器', '传输线'] %}

        self.PowerInput_ = self.变量列表_带指示变量("PowerInput_")
        self.PowerOutput_ = self.变量列表_带指示变量("PowerOutput_")

        self.RangeConstraint(self.电输入, self.PowerInput_.x, expression=lambda x,y: x==y)
        self.RangeConstraint(self.电输出, self.PowerOutput_.x, expression=lambda x,y: x==y)
        
        self.RangeConstraint(self.PowerInput_.b_pos, self.PowerOutput_.b_pos, expression = lambda x,y: x + y <=1)
        self.RangeConstraint(self.PowerInput_.b_neg, self.PowerOutput_.b_neg, expression = lambda x,y: x + y <=1)

            {%if class_name in ['变压器']%}


        if self.设备信息.direction == Direction.Directed:
            self.RangeConstraintMulti(self.PowerInput_.x_pos, expression=lambda x: x == 0)
            self.RangeConstraintMulti(self.PowerOutput_.x_neg, expression=lambda x: x == 0)
    
        {{设计规划}}: # 在变压器和负荷的交换节点处做处理
            self.最大允许的负载总功率 = self.DeviceCount*(self.RatedPower*self.Efficiency)*self.PowerParameter/(1 if 0 == self.LoadRedundancyParameter else self.LoadRedundancyParameter) # type: ignore
            {%elif class_name in ['传输线']%}
        self.Pwire_Asec_Pr.sort(key=lambda x: x[0])
        self.Pwire_arr = [e[0] for e in self.Pwire_Asec_Pr]
        self.Asec_arr = [e[1] for e in self.Pwire_Asec_Pr]
        self.Pr_arr = [e[2] for e in self.Pwire_Asec_Pr]

        if self.设备信息.Optimize:
            self.Pwire = self.单变量('Pwire', within=NonNegativeReals)
            self.RangeConstraintMulti(self.PowerInput_.x_neg, self.PowerOutput_.x_neg, expression = lambda x,y: x+y<=self.Pwire)
            self.Asec = self.单变量('Asec', within=NonNegativeReals)
            self.Piecewise(x_var = [self.Pwire], y_var = [self.Asec],x_vals = self.Pwire_arr, y_vals = self.Asec_arr,range_list = [0])[0]
            self.Pr = self.单变量('Pr', within=NonNegativeReals)
            self.Piecewise(x_var = [self.Pwire], y_var = [self.Pr], x_vals = self.Pwire_arr, y_vals = self.Pr_arr ,range_list = [0])[0]
        else:
            self.Pwire = self.GivenMaxPower
            {# self.Pwire = self.GivenAveragePower #}
            self.Asec = np.interp(self.Pwire, self.Pwire_arr, self.Asec_arr)
            self.Pr = np.interp(self.Pwire, self.Pwire_arr, self.Pr_arr)
        self.R =(self.Rho*self.Length )/ self.Asec
        """
        传输线电阻
        """
        self.Ploss = self.R * ((self.GivenAveragePower/self.U) **2)

        # unit please?
        # overriding passed parameters.
        # let's preserve this.
        self.CostPerKilometer = self.Pr
        {# no formula! #}
        {# self.CostPerYearPerKilometer = ...  #}
        {# self.BuildCostPerKilometer =  #}
        
        self.inputIndicators = self.变量列表_带指示变量('inputIndicators')
        self.outputIndicators = self.变量列表_带指示变量('outputIndicators')
        
            {% endif %}
        {% endif %}
        {% if class_name in ['光伏发电'] %}
        {{设计规划}}:
            # TODO：标准光照下出力
            self.MaxDeviceCount = math.floor(self.MaxInstallArea/self.Area)
            self.MinDeviceCount = math.ceil(self.MinInstallArea/self.Area)
            assert self.MinDeviceCount>=0
            assert self.MaxDeviceCount>=self.MinDeviceCount
        {% elif class_name == "柴油发电" %}
        
        # TODO: define some variables with expression


        {# self.电功率中转 = self.变量列表_带指示变量("电功率中转") #}
        {# self.单台发电功率 = self.变量列表("单台发电功率", within=NonNegativeReals)
        self.单台柴油输入 = self.变量列表("单台柴油输入", within=NonPositiveReals) #}

        self.Nrun = self.变量列表("Nrun", within=NonNegativeIntegers)
        """
        机组开启台数
        """
        self.Nrun_indicators = self.变量列表_带指示变量("Nrun_indicators")
        self.RangeConstraint(self.Nrun, self.Nrun_indicators.x, expression = lambda x,y: x == y + 0.5)
        
        self.RangeConstraintMulti(self.Nrun, expression = lambda x: x <= self.DeviceCount)
        self.Nstart = self.变量列表_带指示变量("Nstart")
        """
        机组开启台数求导
        """
        self.mw.Constraint(expr = self.Nstart.x[0] == 0)
        self.CustomRangeConstraintMulti(self.Nstart.x, self.Nrun, expression = lambda x,y,i: x[i+1] == y[i+1] - y[i], customRange = range(self.计算参数.迭代步数 - 1))

        self.机组年启动次数 = quicksum_indexed_var(self.Nstart.x_pos) * (8760/self.计算参数.总计算时长)
        self.机组年运行时间 = (quicksum_indexed_var(self.Nrun_indicators.b_pos) / self.计算参数.迭代步数) * 8760
        
        if self.设备信息.unitAnnualOperatingTimeConstraint:
            self.mw.Constraint(expr = self.机组年运行时间 <= self.设备信息.maximumAnnualOperatingTimeLimitOfTheUnit)
        
        self.annualUnitStartupCosts = 0
        if self.设备信息.considerUnitStartUpCosts:
            self.annualUnitStartupCosts = self.机组年启动次数 * self.unitSingleStartupCost

        if self.设备信息.unitPlanningAlgorithmSelection == 油耗规划算法.平均:
            x = self.averageLoadRate
            {# already sorted. #}
            {# xfp = list(sorted(self.设备信息.DieselToPower_Load, key = lambda e: e[1])) #}
            xp = [e[1] for e in self.DieselToPower_Load]
            fp = [e[0] for e in self.DieselToPower_Load]
            self.averageDieselConsumptionRate = np.interp(x, xp, fp)

        elif self.设备信息.unitPlanningAlgorithmSelection == 油耗规划算法.最佳:
            self.子机组列表 = []
            {% set subModelParamsAndRanges = [
                ["柴油输入", "NonPositiveReals"],
                ["电输出", "NonNegativeReals"],
                ["是否开启", "Boolean"],
                ["是否真的开启", "Boolean"],
            ] %}
            {% for p, r in subModelParamsAndRanges%}
            self.子机组{{p}}列表 = []
            {% endfor%}
            {# self.柴油子机组基础模型 = self.Block() # modelwrapper #}
            self.子机组数目 = self.MaxDeviceCount if self.计算参数.计算类型 == '设计规划' else self.DeviceCount
            self.子机组数目 = int(self.子机组数目)
            self.子机组是否购买 = self.变量列表('子机组是否购买', mrange = range(self.子机组数目), within=Boolean)

            for i in range(self.子机组数目):
                logger_print(f"正在创建第{i+1}个柴油子机组模型")
                subModelWrapper = self.mw.Block()
                子机组模型 = 设备模型({}, subModelWrapper, self.计算参数, i)
                self.子机组列表.append(子机组模型)
            {% for p, r in subModelParamsAndRanges%}

                子机组{{p}} = 子机组模型.变量列表('子机组{{p}}', within={{r}})
                self.子机组{{p}}列表.append(子机组{{p}})
            {% endfor%}

            # define series of submodels
        else:
            raise Exception("未知油耗规划算法：", self.设备信息.unitPlanningAlgorithmSelection)

        {# 
        {{设计规划}}:
            self.最大油耗率 = max([x[0] for x in self.DieselToPower_Load])

            self.原电输出 = self.Multiply(dict(var=self.单台发电功率,max=self.RatedPower, min=0), dict(var=self.单变量转列表(self.DeviceCount),max=self.MaxDeviceCount, min=self.MinDeviceCount), "原电输出", within = NonNegativeReals)

            self.柴油输入_ = self.Multiply(dict(var=self.单台柴油输入, max=0, min=-self.RatedPower*self.最大油耗率), dict(var=self.单变量转列表(self.DeviceCount),max=self.MaxDeviceCount, min=self.MinDeviceCount), "柴油输入_", within = NonPositiveReals)
            self.RangeConstraint(self.柴油输入_, self.柴油输入, lambda x,y: x == y)
        else:
            self.原电输出 = self.变量列表("原电输出", within = NonNegativeReals)
            self.RangeConstraint(self.原电输出, self.单台发电功率, lambda x,y: x == y*self.DeviceCount)
            self.RangeConstraint(
                self.柴油输入,
                self.单台柴油输入,
                expression=lambda x, y: x == y * self.DeviceCount,
            ) 
        #}
        {% elif class_name  == '锂电池' %}

        {# self.needStorageDecayCompensation:bool = self.设备信息.needStorageDecayCompensation

        """
        开启后存储衰减补偿将可变，反之存储衰减补偿等于存储衰减
        """ #}

        assert self.InitSOC >= self.MinSOC
        assert self.InitSOC <= self.MaxSOC
        {# self.InitActualCapacityPerUnit = (self.InitSOC - self.MinSOC) * self.RatedCapacity #}
        self.InitCapacityPerUnit = self.InitSOC * self.RatedCapacity

        {{设计规划}}:
            #  初始SOC
            self.MaxDeviceCount = math.floor(self.MaxTotalCapacity / self.RatedCapacity)
            self.MinDeviceCount = math.ceil(self.MinTotalCapacity / self.RatedCapacity)

            self.TotalCapacity = self.DeviceCount * self.RatedCapacity # type: ignore

        assert self.MaxSOC >= self.MinSOC
        assert self.MaxSOC < 1
        {# assert self.MaxSOC <= 1 #}
        {# assert self.MinSOC >= 0 #}
        assert self.MinSOC > 0 # to ensure that battery will not be drained.

        self.原电接口 = self.变量列表_带指示变量("原电接口") # 正 放电 负 充电

        {# self.ActualCapacityPerUnit = self.RatedCapacity * (self.MaxSOC - self.MinSOC) #}

        self.CurrentTotalCapacity = self.变量列表('CurrentTotalCapacity', within=NonNegativeReals)

        # reserved expression list. do not use it in any constraints.
        self.SOC = [self.CurrentTotalCapacity[i]/self.TotalCapacity for i in self.CurrentTotalCapacity]

        {# {{设计规划}}:
            self.CurrentTotalCapacity.setlb(self.MinDeviceCount*self.MinSOC*self.RatedCapacity)
            self.CurrentTotalCapacity.setub(self.MaxDeviceCount*self.MaxSOC*self.RatedCapacity) #}
            
        self.RangeConstraintMulti(self.CurrentTotalCapacity, expression = lambda x: x >= self.TotalCapacity * self.MinSOC)
        self.RangeConstraintMulti(self.CurrentTotalCapacity, expression = lambda x: x <= self.TotalCapacity * self.MaxSOC)
        {# else: # 仿真模拟
            self.CurrentTotalCapacity.setlb(self.DeviceCount*self.MinSOC*self.RatedCapacity)
            self.CurrentTotalCapacity.setub(self.DeviceCount*self.MaxSOC*self.RatedCapacity) #}

        {# self.CurrentTotalActualCapacity = self.变量列表('CurrentTotalActualCapacity', within=NonNegativeReals) #}

        {# self.TotalActualCapacity = self.DeviceCount * self.ActualCapacityPerUnit # type: ignore #}

        {# self.MaxTotalCapacityDeltaPerStep = self.BatteryDeltaLimit * self.TotalCapacity / ({{时间步长参数}})
        """
        单位: kWh
        """ #}

        self.MaxTotalChargeOrDischargeRate = self.BatteryDeltaLimit * self.TotalCapacity 
        """
        最大总充放功率
        单位: kW
        """

        {# self.TotalStoragePowerOfDecay = (self.BatteryStorageDecay / 100) * self.TotalCapacity
        """
        单位: kW
        """ #}
        self.sigma = (self.BatteryStorageDecay / 100) 
        """
        衰减率
        单位: 1/h
        """

            {# {% if needStorageDecayCompensation%} #}
        {# if self.needStorageDecayCompensation: 
            # TODO: Verify if "compensated decay rate" works.
            {{设计规划}}:

                self.CurrentTotalPowerOfDecayCompensated = self.变量列表('总补偿衰减率', bounds = (0,(self.BatteryStorageDecay/100)*self.MaxTotalCapacity), within=NonNegativeReals) # the greater the value, the less our compensation is, the greater the real discharge by decay is (will not emit to external ports).
                # constraint.
                self.RangeConstraintMulti(self.CurrentTotalPowerOfDecayCompensated, expression=lambda x: x<=self.TotalStoragePowerOfDecay)
            else: # 仿真模拟
                self.CurrentTotalPowerOfDecayCompensated = self.变量列表('总补偿衰减率', bounds = (0,self.TotalStoragePowerOfDecay), within=NonNegativeReals) #}

        {%elif class_name in ['双向变流器']%}

        self.线路端_ = self.变量列表_带指示变量("线路端_")
        self.储能端_ = self.变量列表_带指示变量("储能端_")
{# 
        {% elif class_name in ['传输线']%}
        self.电输入_去除损耗 = self.变量列表_带指示变量('电输入_去除损耗')  #}
        {%endif%}

        {% if class_name not in ["传输线"]%}
        self.POSNEG_是否购买 = self.单表达式生成指示变量('POSNEG_是否购买', self.DeviceCount - 0.5)
        self.是否购买 = self.POSNEG_是否购买.b_pos

        if isinstance(self.DeviceCount, Var): # 设备台数约束
            self.DeviceCount.setlb(self.MinDeviceCount)
            self.DeviceCount.setub(self.MaxDeviceCount)
        {% endif%}

    def constraints_register(self):
        super().constraints_register()
        # 设备特有约束（非变量）
        {# 检验解析时参数是否填写完全 #}
        {% if class_name in ['柴油发电']%}

        assert self.燃料热值!=0
        assert type(self.燃料热值) in [int,float]

        {% endif%}
        {% if class_name == "风力发电" %}
        # define a single-variate piecewise function
        # 
        #         ____
        #        /    |
        #       /     | ax^3
        #  ----/      |______
        #
        assert self.RatedWindSpeed >=self.MinWindSpeed
        assert self.MaxWindSpeed >=self.RatedWindSpeed

        if self.设备信息.machineType in [风力发电类型.变桨, 风力发电类型.定桨]:

            发电曲线参数 = self.RatedPower / ( (self.RatedWindSpeed - self.MinWindSpeed) ** 3)

            # windspeed (m/s) -> current power per device (kW)
            WS = np.array(self.计算参数.风速, dtype=np.float64) # BUG: before that it was "np.int64", which introduce errors.
            {# self.单台发电功率 = 单台发电功率 = np.piecewise(WS, [WS<=self.MinWindSpeed, np.logical_and(WS >self.MinWindSpeed,WS <= self.RatedWindSpeed) , np.logical_and(WS >self.RatedWindSpeed, WS <=self.MaxWindSpeed) , WS > self.MaxWindSpeed], [0,
            lambda x: 发电曲线参数 * ((x - self.MinWindSpeed) ** 3), 
            self.RatedPower, 0]) #}
            if self.设备信息.machineType == 风力发电类型.定桨:
                # 额定功率 +( (切出功率 - 额定功率)*(实际风速-额定风速)) / (切出风速-额定风速)
                定桨风机特有函数 = lambda 实际风速: self.RatedPower +((self.CutoutPower - self.RatedPower)*(实际风速-self.RatedWindSpeed)) / (self.MaxWindSpeed-self.RatedWindSpeed)
            self.单台发电功率 = 单台发电功率 = np.piecewise(
            WS,
            [
                WS <= self.MinWindSpeed,
                np.logical_and(WS > self.MinWindSpeed, WS <= self.RatedWindSpeed),
                np.logical_and(WS > self.RatedWindSpeed, WS <= self.MaxWindSpeed),
                WS > self.MaxWindSpeed,
            ],
            [   0, 
                lambda x: 发电曲线参数 * ((x - self.MinWindSpeed) ** 3),
                self.RatedPower if self.设备信息.machineType == 风力发电类型.变桨 else 定桨风机特有函数, 
                0 
            ],
            )
            self.单台发电功率 = 单台发电功率 = 单台发电功率.tolist()
        elif self.设备信息.machineType in [风力发电类型.标幺值]:
            assert self.设备信息.normalizedPower is not None, "标幺值风机不能传空的标幺值"
            assert (length:= len(self.设备信息.normalizedPower)) == (required_length:= self.计算参数.迭代步数), f'标幺值长度不合理\n迭代步数: {required_length}\n实际: {length}'
            self.单台发电功率 = 单台发电功率 = [self.RatedPower*normalizedPower for normalizedPower  in self.设备信息.normalizedPower]
        else:
            raise Exception(f"未知风机类型：{self.设备信息.machineType}")

        {% endif %}

        {# 
        # 设备台数约束
        {% if class_name not in ['传输线'] %}
        {{设计规划}}:
            self.mw.Constraint(self.DeviceCount <= self.MaxDeviceCount)
            self.mw.Constraint(self.DeviceCount >= self.MinDeviceCount)
        {% endif %}
        #}
        
        # 输出输入功率约束

        {%if class_name in ['传输线']%}
{#         
        TotalDecayPerStep = self.Length * self.PowerTransferDecay / {{时间步长参数}}
        self.RangeConstraint(self.电输入_去除损耗.x, self.电输入, lambda x,y: x == y+TotalDecayPerStep )
        self.RangeConstraint(self.电输入_去除损耗.x_neg, self.电输出,lambda x,y: x == y ) #}
{#         
        self.RangeConstraint(self.电输入, self.PowerInput_.x, expression = lambda x,y: x==y)
        self.RangeConstraint(self.电输出, self.PowerOutput_.x, expression = lambda x,y: x==y) #}

        self.RangeConstraint(self.电输入, self.inputIndicators.x, expression = lambda x,y: x == y-self.Ploss)

        self.RangeConstraint(self.电输出, self.outputIndicators.x, expression = lambda x,y: x == y-self.Ploss)

        self.RangeConstraintMulti(self.PowerOutput_.x_pos, self.inputIndicators.x_neg, expression = lambda x,y: x==y)
        {# self.RangeConstraintMulti(self.PowerOutput_.x_pos, self.inputIndicators.x_neg, self.inputIndicators.b_neg, expression = lambda x,y,z: x==y - 2* z * self.Ploss) #}
        self.RangeConstraintMulti(self.PowerInput_.x_pos, self.outputIndicators.x_neg, expression = lambda x,y: x==y)
        {# self.RangeConstraintMulti(self.PowerInput_.x_pos, self.outputIndicators.x_neg, self.outputIndicators.b_neg, expression = lambda x,y,z: x==y - 2* z * self.Ploss) #}

        {# direction constraint#}
        self.RangeConstraint(self.PowerInput_.b_pos, self.PowerOutput_.b_pos, expression = lambda x,y: x + y <=1)
        self.RangeConstraint(self.PowerInput_.b_neg, self.PowerOutput_.b_neg, expression = lambda x,y: x + y <=1)

        {% elif class_name in ['双向变流器'] %}

        self.RangeConstraint(self.线路端_.x , self.线路端, lambda x,y: x==y)
        self.RangeConstraint(self.储能端_.x , self.储能端, lambda x,y: x==y)

        # wrong! negative is input.
        {# self.RangeConstraint(self.线路端_.x_neg, self.储能端_.x_pos,lambda x,y: x == y*self.Efficiency)
        self.RangeConstraint(self.储能端_.x_neg, self.线路端_.x_pos,lambda x,y: x == y*self.Efficiency) #}

        self.RangeConstraint(self.线路端_.x_neg, self.储能端_.x_pos,lambda x,y: y == x *self.Efficiency)
        self.RangeConstraint(self.储能端_.x_neg, self.线路端_.x_pos,lambda x,y: y == x *self.Efficiency)

        {% elif class_name in 单向变电器列表 %}
        # TODO: figure out what "PowerParameter" does
        # TODO: fix efficiency issue
        {% if class_name not in ['变压器']%}
        self.RangeConstraint(self.电输入, self.电输出, lambda x,y: x * self.Efficiency {{"* self.PowerParameter" if class_name in ['变压器'] else ""}} == -y)
        self.RangeConstraintMulti(self.电输入, expression=lambda x: -x<=self.RatedPower * self.DeviceCount)
        {% else %}
        self.RangeConstraint(
            self.PowerInput_.x_neg,
            self.PowerOutput_.x_pos,
            lambda x, y: x * self.Efficiency * self.PowerParameter == y,
        )
        self.RangeConstraint(
            self.PowerOutput_.x_neg,
            self.PowerInput_.x_pos,
            lambda x, y: x * self.Efficiency * self.PowerParameter == y,
        )
        
        self.RangeConstraintMulti(
            self.PowerInput_.x_neg, expression=lambda x: x <= self.RatedPower * self.DeviceCount
        )
        self.RangeConstraintMulti(
            self.PowerOutput_.x_neg, expression=lambda x: x <= self.RatedPower * self.DeviceCount
        )
        {% endif%}

        {% elif class_name in RenewableEnergyDevices %}
            {% if class_name in ['光伏发电'] %}
        光电转换效率 = self.MaxPower / self.Area # 1kW/m2光照下能产生的能量 省略除以1 单位: one
        assert 光电转换效率<=1, f"光电转换效率数值不正常: {光电转换效率} (应当在0-1之间)\n光电转换效率 = 单块最大功率 / 单块面积"
        总最大功率 = self.MaxPower * self.DeviceCount
        总面积 = self.Area * self.DeviceCount

        # 光照强度 * 总面积 * 光电转换效率 * 电电转换效率
        # (kW/m2) * m2 * one * one -> kW
        self.RangeConstraintMulti(self.计算参数.光照, self.电输出, self.discardedRenewableEnergyPower, expression = lambda x,y,z: x*总面积*光电转换效率*self.PowerConversionEfficiency == y+z)

        # BUG: 限制最大功率输出（标准光照下）
        self.RangeConstraintMulti(self.电输出, expression = lambda x: x <= self.MaxPower*self.DeviceCount*self.PowerConversionEfficiency)

            {% elif class_name in ['风力发电'] %}
        self.RangeConstraintMulti(单台发电功率, self.电输出, self.discardedRenewableEnergyPower, expression = lambda x,y,z: x*self.DeviceCount ==y+z)
            {% endif%}
        if self.RenewableEnergyConsumptionConstraint == 新能源消纳约束.惩罚代价:
            self.punishRate =(quicksum_indexed_var(self.discardedRenewableEnergyPower)/self.计算参数.迭代步数)* self.RenewableEnergyConsumptionPunishmentRate
        elif self.RenewableEnergyConsumptionConstraint == 新能源消纳约束.限制消纳率:
            self.mw.Constraint(expr = (1-self.RenewableEnergyConsumptionRate)*quicksum_indexed_var(self.电输出) > self.RenewableEnergyConsumptionRate*quicksum_indexed_var(self.discardedRenewableEnergyPower))
        elif self.RenewableEnergyConsumptionConstraint == 新能源消纳约束.无:
            ...
        else:
            raise Exception(f"未知新能源消纳约束：{self.RenewableEnergyConsumptionConstraint}\n元件模型: {self.__class__.__name__}")
        {% elif class_name in ['柴油发电'] %}
        {# 总最小启动功率 = self.RatedPower * self.PowerStartupLimit * self.DeviceCount #}
        {# 总最小启动功率 = self.RatedPower * self.PowerStartupLimit #}
        {# 总最大输出功率 = self.RatedPower * self.DeviceCount #}
{# 
        self.RangeConstraintMulti(self.单台发电功率, expression = lambda x: x <= self.RatedPower)
        self.RangeConstraint(self.原电输出, self.电功率中转.x, lambda x,y: x == y + 总最小启动功率)

        self.Piecewise(y_var = self.单台柴油输入, x_var = self.单台发电功率, y_vals = [-x[0]*self.RatedPower*x[1] for x in self.DieselToPower_Load], x_vals = [self.RatedPower*x[1] for x in self.DieselToPower_Load])
        # 柴油输入率: L/h

        self.RangeConstraintMulti(self.电功率中转.x_pos, self.电输出, self.电功率中转.b_pos, expression = lambda x,y,z: x + self.BinVarMultiplySingle(z,总最小启动功率) == y) #}

        if self.设备信息.unitPlanningAlgorithmSelection == 油耗规划算法.平均:
        
            self.RangeConstraint(self.电输出, self.Nrun_indicators.b_pos, lambda x,y: x >= y * self.RatedPower * self.PowerStartupLimit)
            self.RangeConstraint(self.电输出, self.Nrun, lambda x, y: x <= y * self.RatedPower)
            self.RangeConstraint(self.电输出, self.Nrun, lambda x, y: x >= (y-1) * self.RatedPower)

            self.RangeConstraint(self.柴油输入, self.电输出, lambda x, y: -x == self.averageDieselConsumptionRate * y)

        elif self.设备信息.unitPlanningAlgorithmSelection == 油耗规划算法.最佳:
            子机组购买数目 = 0

            {% set subModelParamsNeeded = [] %}
            {% for p, r in subModelParamsAndRanges %}
                {% if p not in ['是否开启'] %}
                    {% do subModelParamsNeeded.append(p) %}
                {% endif %}
            {% endfor %}
            
            {% for p in subModelParamsNeeded%}
            子机组{{p}}求和 = [0]* self.计算参数.迭代步数
            {% endfor%}

            for i in range(self.子机组数目):
                logger_print(f"正在为第{i+1}个柴油子机组模型创建约束")

                子机组模型:设备模型 = self.子机组列表[i]

            {% for p, r in subModelParamsAndRanges%}
                子机组{{p}} = self.子机组{{p}}列表[i]
            {% endfor%}

                子机组是否购买 = self.子机组是否购买[i]

                子机组模型.RangeConstraintMulti(子机组电输出, expression = lambda x: x <= 子机组是否购买 * self.BigM)
                子机组模型.RangeConstraint(子机组电输出, 子机组是否开启, expression = lambda x,y: x <= y * self.RatedPower)
                子机组模型.RangeConstraint(子机组电输出, 子机组是否开启, expression = lambda x,y: x >= y * self.RatedPower * self.PowerStartupLimit)

                子机组模型.RangeConstraint(子机组是否开启, 子机组是否真的开启, expression = lambda x,y: 子机组模型.BinVarMultiplySingle(子机组是否购买, x) == y)
                {# for j in range(self.计算参数.迭代步数): #}
                    {# 子机组是否真的开启求和[j] += 子机组是否真的开启[j] #}
                    
                if self.计算参数.计算步长 == "秒":
                    # deltalimit
                    subModelElectricityPowerDeltaLimit = self.RatedPower * self.PowerDeltaLimit / 100

                    子机组模型.CustomRangeConstraintMulti(子机组电输出,子机组是否真的开启, customRange = range(self.计算参数.迭代步数), expression = lambda x,y,i: x[i+1] - x[i]>= -subModelElectricityPowerDeltaLimit*y)
                    子机组模型.CustomRangeConstraintMulti(子机组电输出,子机组是否真的开启, customRange = range(self.计算参数.迭代步数), expression = lambda x,y,i: x[i+1] - x[i]<=subModelElectricityPowerDeltaLimit*y)
            
            {% for p in subModelParamsNeeded %}
                子机组{{p}}求和 = 子机组模型.TimeSummation(子机组{{p}}求和, 子机组{{p}})
            {% endfor %}

                子机组模型.Piecewise(
                    y_var=子机组柴油输入,
                    x_var=子机组电输出,
                    y_vals=[-x[0] * self.RatedPower * x[1] for x in self.DieselToPower_Load],
                    x_vals=[self.RatedPower * x[1] for x in self.DieselToPower_Load],
                )
            子机组购买数目 = quicksum_indexed_var(self.子机组是否购买)
            self.mw.Constraint(expr = 子机组购买数目 == self.DeviceCount)
            self.RangeConstraint(self.Nrun, 子机组是否真的开启求和, expression = lambda x,y: x==y)

            {% for p in ['柴油输入', '电输出'] %}
            self.RangeConstraint(self.{{p}}, 子机组{{p}}求和, expression = lambda x,y: x==y)
            {% endfor %}
        else:
            raise Exception(f"未知油耗规划算法：{self.设备信息.unitPlanningAlgorithmSelection}") 
        

        {%elif class_name in ['锂电池'] %}
        {# self.RangeConstraintMulti(self.CurrentTotalActualCapacity, expression = lambda x: x <= self.TotalActualCapacity) #}

        self.mw.Constraint(self.CurrentTotalCapacity[0] == self.InitCapacityPerUnit * self.DeviceCount)
        {# self.mw.Constraint(self.CurrentTotalActualCapacity[0] == self.InitActualCapacityPerUnit * self.DeviceCount) #}


            {# {% if needStorageDecayCompensation%} #}
        {# if self.needStorageDecayCompensation: #}
            {# S(t) - (1-sigma*deltaT)*S(t-1) = (p0_pos - p0_neg)*deltaT #}
            {# deltaT = 1 if 计算步长 == 小时 else 1/3600 #}
        self.CustomRangeConstraintMulti(
            self.原电接口.x,
            self.CurrentTotalCapacity,
            {# self.CurrentTotalPowerOfDecayCompensated, #}
            customRange = range(self.计算参数.迭代步数 - 1),
            expression = 
            lambda x, y, i: x[i] *self.计算参数.deltaT == (y[i] * (1- self.计算参数.deltaT * self.sigma)  - y[i + 1])
            {# lambda x, y, z, i: x[i] - z[i] == (y[i] - y[i + 1]) * self.计算参数.时间参数, #}
        )
        self.RangeConstraintMulti(
            self.原电接口.x_pos,
            self.原电接口.x_neg,
            self.电接口,
            {# self.CurrentTotalPowerOfDecayCompensated,  #}
            expression=lambda x_pos, x_neg, y: x_pos * self.DischargeEfficiency - (x_neg) / self.ChargeEfficiency == y,
            {# expression=lambda x_pos, x_neg, y, z: x_pos * self.DischargeEfficiency- (x_neg + (self.TotalStoragePowerOfDecay - z)) / self.ChargeEfficiency== y, #}
        )
        {# {% else%} #}
{#             
        else:
            self.CustomRangeConstraint(self.原电接口.x, self.CurrentTotalCapacity, customRange = range(self.计算参数.迭代步数-1),expression =  lambda x,y,i: x[i] == (y[i] - y[i+1]) * {{时间步长参数}})
            self.RangeConstraintMulti(self.原电接口.x_pos, self.原电接口.x_neg, self.电接口,expression = lambda x_pos, x_neg, y: x_pos * self.DischargeEfficiency - (x_neg + self.TotalStoragePowerOfDecay)/self.ChargeEfficiency == y) 
         #}
            {# {% endif%} #}
        {# power = delta(capacity)/delta(time)#}
            {# {% if needStorageDecayCompensation%} #}
            {# {%else%} #}
            {# {% endif%} #}
        {# for i in range(self.计算参数.迭代步数): #}
        self.RangeConstraintMulti(self.原电接口.x_abs, expression = lambda x: x <= self.MaxTotalChargeOrDischargeRate)
        {# for i in range(self.计算参数.迭代步数-1): #}
            {# 
            self.mw.Constraint(self.CurrentTotalCapacity[i+1] - self.CurrentTotalCapacity[i] <= self.MaxTotalCapacityDeltaPerStep)
            self.mw.Constraint(self.CurrentTotalCapacity[i+1] - self.CurrentTotalCapacity[i] >= -self.MaxTotalCapacityDeltaPerStep)
            #}

{# 
        {{设计规划}}:
            # if self.设备信息.循环边界条件 == '日间独立':
                # self.mw.Constraint(self.原电接口.x[0] == self.EPS)
                # BUG: override suspicious constraints with init values.
                # self.原电接口.x[0].set_value(self.EPS)
            if self.设备信息.循环边界条件 == '日间连接':
                self.mw.Constraint(self.CurrentTotalCapacity[0] - self.CurrentTotalCapacity[self.计算参数.迭代步数-1] <=self.MaxTotalCapacityDeltaPerStep)

                self.mw.Constraint(self.CurrentTotalCapacity[0] - self.CurrentTotalCapacity[self.计算参数.迭代步数-1] >=-self.MaxTotalCapacityDeltaPerStep)
                if self.needStorageDecayCompensation:
            # {% if needStorageDecayCompensation%}
                    self.mw.Constraint(
                        self.原电接口.x[0] - self.CurrentTotalPowerOfDecayCompensated[0]
                        == (
                            self.CurrentTotalCapacity[self.计算参数.迭代步数 - 1]
                            - self.CurrentTotalCapacity[0]
                        )
                        * self.计算参数.时间参数
                    )
            # {%else%}
                else:
                    self.mw.Constraint(self.原电接口.x[0] == (self.CurrentTotalCapacity[self.计算参数.迭代步数-1] - self.CurrentTotalCapacity[0]) * {{时间步长参数}})
            # {% endif%} 
            else:
                raise Exception("未知循环边界条件:", self.设备信息.循环边界条件)
        else: # 仿真模拟
        # elif self.计算参数.计算类型 == "仿真模拟": 
            # self.mw.Constraint(self.原电接口.x[0] == self.EPS) 
            self.原电接口.x[0].set_value(self.EPS) #}

        if self.计算参数.典型日:
            self.mw.Constraint((lambda x, y: x[self.计算参数.迭代步数 - 1] *self.计算参数.deltaT== (y[self.计算参数.迭代步数 - 1] * (1- self.计算参数.deltaT * self.sigma)  - y[0])) (self.原电接口.x,
            self.CurrentTotalCapacity))
        {# else:
            self.原电接口.x[self.计算参数.迭代步数 - 1].set_value(0)
         #}

        {% endif %}

        {# 秒级功率变化限制，有特定的变量限制 #}
        {% if class_name in ['光伏发电', '风力发电', '柴油发电'] %}
            {% set extraDeltaLimitConditions = {
                "风力发电":" and self.设备信息.machineType != 风力发电类型.标幺值",
                "柴油发电":" and self.设备信息.unitPlanningAlgorithmSelection != 油耗规划算法.最佳"
            }%}
        {{秒}} {{extraDeltaLimitConditions.get(class_name, "")}}:
            总最大功率 = {{'self.MaxPower' if class_name in ['光伏发电'] else 'self.RatedPower'}} * self.DeviceCount
            最大功率变化 = 总最大功率 * self.PowerDeltaLimit / 100
            {% if class_name in ['柴油发电'] %}
            最大下行功率变化生成 = lambda Nrun_t: Nrun_t * self.RatedPower * self.PowerDeltaLimit / 100
            {% endif %}
            self.CustomRangeConstraintMulti(self.电输出 , customRange = range(self.计算参数.迭代步数-1), expression = lambda x,i: x[i+1] - x[i] <= 最大功率变化)
            {% if class_name in ['柴油发电']%}
            self.CustomRangeConstraintMulti(self.电输出, self.Nrun, customRange = range(self.计算参数.迭代步数-1), expression = lambda x,y,i: x[i+1] - x[i] >= -最大下行功率变化生成(y[i]))
            {% else %}
            self.CustomRangeConstraintMulti(self.电输出, customRange =  range(self.计算参数.迭代步数-1),expression = lambda x,i: x[i+1] - x[i] >= -最大功率变化)
            {% endif %}
        {% endif %}
        {# elif self.计算参数.计算步长 == "小时":
            ... # skip it.
        else:
            raise Exception("未知计算步长:", self.计算参数.计算步长) #}
        
        # 计算年化
        # unit: one
        {# if 计算参数.计算类型 == "规划设计": #}
        {# 规划设计和仿真模拟都需要计算年化 #}
        {%with%}
        {% if class_name in ['锂电池'] %} 

        # TODO: to get LifetimeDischargeCapacityPerUnit working
        self.LifetimeDischargeCapacityPerUnit = self.LifetimeCycleCount * self.RatedCapacity
        """
        单块电池生命周期总放电量
        单位: kWh
        """

        计算范围内总平均放电功率 = (self.SumRange(self.原电接口.x_pos)/self.计算参数.迭代步数)# kW
        {# 计算范围内总平均功率 = (self.SumRange(self.原电接口.x_abs)/self.计算参数.迭代步数)+ self.TotalStoragePowerOfDecay # kW #}
        # avg power

        一小时总电变化量 = 计算范围内总平均放电功率 # 省略乘1
        {# 一小时总电变化量 = 计算范围内总平均功率 #}
        # kWh

        一年总电变化量 = 一小时总电变化量 * 每年小时数
        
        self.mw.Constraint(一年总电变化量 * self.BatteryLife <= self.DeviceCount * self.LifetimeDischargeCapacityPerUnit * 0.85)
        assert self.BatteryLife >=1
        assert self.Life >= self.BatteryLife
        Life = self.BatteryLife
        {%else%}
        Life = self.Life
        {%endif%}
        self.年化率 = 计算年化率(self.计算参数.贴现率, Life)
        {# self.年化率 = ((1+(self.计算参数.年利率/100)) ** Life) / Life #}
        {% if class_name in ['光伏发电'] %}
            {% set m='总最大功率' %}
            {% set vi = 'Kilowatt' %}
            {% set vm = 'Kilowatt' %}
            {% set vb = 'Kilowatt' %}
            {% set vv = 'Work' %}
        {% elif class_name in ['风力发电']+单向变电器列表+ ['双向变流器'] %}
            {% set m='self.DeviceCount * self.RatedPower' %}
            {% set vi = 'Kilowatt' %}
            {% set vm = 'Kilowatt' %}
            {% set vb = 'Kilowatt' %}
            {% set vv = 'Work' %}
        {% elif class_name in ['柴油发电'] %}
            {% set m='self.DeviceCount' %}
            {% set vi = 'Machine' %}
            {% set vm = 'Machine' %}
            {% set vb = 'Machine' %}
            {% set vv = 'Work' %}
        {% elif class_name in ["锂电池"] %}
            {% set m='self.DeviceCount * self.RatedCapacity' %}
            {% set vi = 'Capacity' %}
            {% set vm = 'Capacity' %}
            {% set vb = 'Capacity' %}
            {% set vv = 'Work' %}
        {% elif class_name in ['传输线'] %}
            {% set m='self.Length'%}
            {% set vi = 'Kilometer' %}
            {% set vm = 'Kilometer' %}
            {% set vb = 'Kilometer' %}
        {% else%}
            {% error("不支持的设备类型:", class_name) %}
        {% endif %}

        self.总采购成本 = self.CostPer{{vi}} * ({{ m}}) 
        self.总固定维护成本 = self.CostPerYearPer{{vm}} * ({{ m}})
        self.总建设费用 = self.BuildCostPer{{vb}} * ({{ m}}) + self.BuildBaseCost

        self.总固定成本年化 = (self.总采购成本 + self.总建设费用) * self.年化率 + self.总固定维护成本 
        {# self.总固定成本年化 = (self.总采购成本 + self.总固定维护成本 + self.总建设费用) * self.年化率 #}

        {% if class_name in ['光伏发电','风力发电','柴油发电']%}
            {% set m1="self.SumRange(self.电输出)"%}
        {% elif class_name in ['锂电池']%}
            {% set m1="计算范围内总平均放电功率*self.计算参数.迭代步数"%}
            {# {% set m1="计算范围内总平均功率*self.计算参数.迭代步数"%} #}
        {% elif class_name in 单向变电器列表 %}
        {# {% elif class_name in 单向变电器列表+['传输线']%} #}
            {% if class_name in ['变压器'] %}
            {# {% if class_name in ['变压器', '传输线']%} #}
            {% set m1 = '(self.SumRange(self.PowerInput_.x_neg) + self.SumRange(self.PowerOutput_.x_neg))'%}
            {% else%}
            {% set m1='-self.SumRange(self.电输入)'%}
            {% endif%}
        {% elif class_name in ['双向变流器'] %}
            {% set m1='(self.SumRange(self.储能端_.x_neg)+self.SumRange(self.线路端_.x_neg))'%}
        {%elif class_name in ['传输线'] %}
            {% set m1='0' %}
        {% else %}
            {% error("不支持的类型:", class_name) %}
        {% endif %}
        {% if class_name not in ['传输线'] %}
        {# 总可变维护成本年化 = ({{m1}}) * (8760 / self.计算参数.迭代步数) * ({{时间步长参数}}) *self.VariationalCostPer{{vv}} #}
        self.总可变维护成本年化 = (({{m1}}) / self.计算参数.迭代步数) * 每年小时数 * self.VariationalCostPer{{vv}}
        # avg_power * 8760 = annual_work
        {% if class_name in ['柴油发电'] %}
        self.总可变维护成本年化 += self.annualUnitStartupCosts
        {% endif %}

        self.总成本年化 = self.总固定成本年化 + self.总可变维护成本年化
        {% else %}
        self.总成本年化 = self.总固定成本年化
        {% endif %}
        {% endwith %}

        {% if class_name != "传输线" %}
        {# 忽略传输线 #}
        self.处理最终财务输出(self)
        {% endif %}

        return self.总成本年化
{% endfor %}

{% set load_class_names = [] %}
{% for v in load_types %}
    {% do load_class_names.append(v+"负荷")%}
{% endfor %}
{% set input_class_names = input_types%}
{% set special_classes = {"load_class": load_class_names, "input_class": input_class_names} %}

{# check for coverage #}
{% for class_name in 设备接口集合.keys() %}
    {% if class_name not in NonLoadDeviceDict.keys() %}
        {% if class_name not in input_class_names+load_class_names%}
            {% error("未覆盖的非设备类型:", class_name)%}
        {% endif%}
    {% endif%}
{% endfor%}

{% for k,clist in special_classes.items() %}
    {% for class_name in clist%}
class {{class_name}}模型(设备模型):
{{ init_super_class(class_name)}}

{{ port_variable_define(class_name)}}

    {% if k == "load_class"%}
        {% if not class_name.endswith('负荷') %}
            {% error("错误的负荷类名:", class_name) %}
        {% else %}
            {% set v = class_name.strip("负荷") %}
        {% endif %}
        assert len(self.设备信息.EnergyConsumption) == self.计算参数.迭代步数
        
        if self.设备信息.LoadType == 负荷类型.Punished:
            self.UnsatisfiedEnergyConsumption = self.变量列表(
            "UnsatisfiedEnergyConsumption", within=NonNegativeReals
        )

        if 负荷类型.Interruptable in self.设备信息.LoadType:
            self.Interrupted = self.变量列表(
            "Interrupted", within=Boolean)
            # Binary is ok.

        {% if v in ['电'] %}
        MaxEnergyConsumptionDefault = max(self.设备信息.EnergyConsumption)

        if self.设备信息.MaxEnergyConsumption is None:
            self.MaxEnergyConsumption = MaxEnergyConsumptionDefault
        else:
            assert self.设备信息.MaxEnergyConsumption >= MaxEnergyConsumptionDefault
            self.MaxEnergyConsumption = self.设备信息.MaxEnergyConsumption

        {% endif %}

        self.IncomeRates = ...
        self.punishRate = 0
        self.PriceModel = self.设备信息.PriceModel

    {% elif k == 'input_class' %}

        class _Units(BaseModel):
        {% for attrName, defaultUnit in 燃料能源相关数据默认单位[class_name].items() %}
            {{attrName}}: str
        {% endfor%}

        UnitsDict = {}

        {% for attrName, defaultUnit in 燃料能源相关数据默认单位[class_name].items() %}
        ## PROCESSING: {{attrName}}
        ### UNIT COMPATIBILITY CHECK ###
        default_unit = self.设备信息.DefaultUnits.{{attrName}}
        val_unit = self.设备信息.{{attrName}}[1]

        has_exception, _ = getSingleUnitConverted(default_unit = default_unit, val_unit =val_unit)

        if has_exception:
            raise Exception(f"Unit '{val_unit}' is not compatible with default unit '{default_unit}'")
        ### UNIT COMPATIBILITY CHECK ###

        
        ### UNIT CONVERSION ###
        ConversionRate, StandardUnit = unitFactorCalculator(ureg, standard_units, val_unit)
        ### UNIT CONVERSION ###
        
        self.{{attrName}} = self.设备信息.{{attrName}}[0] * ConversionRate
        """
        单位: 标准单位 <- 现用单位
        """
        UnitsDict.update(dict({{attrName}}= str(StandardUnit)))
        {% endfor%}

        self.Units = _Units.parse_obj(UnitsDict)
    {% else%}
        {% error("Unknown special class:", k)%}
    {% endif%}
    
    def constraints_register(self):
        super().constraints_register()
    {% if k == "load_class"%}
        {% if v in ['电'] %}
            {% set port_name = '电接口' %}
        {% else %}
            {% error("未知负荷类型:",class_name) %}
        {% endif %}
        # TODO: 典型日的分时分月电价取每天同一小时的平均，在电价模型内实现
        getTimeInDay = lambda index: index {{小时}} else self.计算参数.分时计价开始时间点 + 每天小时数*convertMonthToDays(self.计算参数.分时计价开始月份) + (index/每小时秒数)

        self.IncomeRates = [self.PriceModel.getFee(power, getTimeInDay(index)) for index, power in enumerate(self.{{port_name}}.values())] # negative, means income
        punishmentRates = [0]

        if self.设备信息.LoadType == 负荷类型.Normal:
            self.RangeConstraint(self.{{port_name}}, self.设备信息.EnergyConsumption, lambda x,y: x == -y)
        elif self.设备信息.LoadType == 负荷类型.Punished:
            self.RangeConstraintMulti(self.{{port_name}}, self.UnsatisfiedEnergyConsumption, self.设备信息.EnergyConsumption,expression =  lambda x,y,z: x == -(z-y))
            punishmentRates = [v*self.设备信息.PunishmentRate for v in self.UnsatisfiedEnergyConsumption.values()]
        elif self.设备信息.LoadType == 负荷类型.Flexible:
            self.RangeConstraintMulti(self.{{port_name}}, expression = lambda x: -x>=self.设备信息.Pmin)
            self.RangeConstraintMulti(self.{{port_name}}, expression = lambda x: -x<=self.设备信息.Pmax)
        elif self.设备信息.LoadType == 负荷类型.Interruptable:
            self.RangeConstraintMulti(self.{{port_name}}, self.Interrupted, expression = lambda x,y : -x==self.设备信息.Pmax*(1-y))
        elif self.设备信息.LoadType == 负荷类型.InterruptableAndFlexible:
            self.RangeConstraintMulti(self.{{port_name}}, self.Interrupted, expression = lambda x,y : -x>=self.设备信息.Pmin*(1-y))
            self.RangeConstraintMulti(self.{{port_name}}, self.Interrupted, expression = lambda x,y : -x<=self.设备信息.Pmax*(1-y))
        else:
            raise Exception("不合理的负荷类型:", self.设备信息.LoadType)
        
        {# 年化费用 = ((0 if self.设备信息.LoadType == LoadType.Punished else (quicksum_indexed_var(self.IncomeRates)))/len(self.IncomeRates)) * 每年小时数 #}
        if self.设备信息.LoadType == 负荷类型.Punished:
            年化费用 = 0
            self.punishRate = quicksum_indexed_var(punishmentRates)/self.计算参数.迭代步数
        else:
            年化费用 = (quicksum_indexed_var(self.IncomeRates)/self.计算参数.迭代步数) * 每年小时数
        {# 年化费用 = ((0 if self.设备信息.LoadType == LoadType.Punished else (quicksum_indexed_var(self.IncomeRates)) + quicksum_indexed_var(punishmentRates))/len(self.IncomeRates)) * 每年小时数 #}
        # 已经是负数了

        {# 计价模型 #}
    {% elif k == "input_class" %}
        {% if class_name in ['柴油'] %}
        平均消耗率 = self.SumRange(self.燃料接口) / self.计算参数.迭代步数
        {% else %}
            {% error('未知能源类型:', class_name) %}
        {% endif %}

        年化费用 = 平均消耗率 * self.Price * 每年小时数

    {% else %}
        {% error("未知特殊类型:", k) %}
    {% endif %}
        self.总成本年化 = self.总可变维护成本年化 = 年化费用
        return 年化费用

{% endfor %}
{% endfor %}


class ModelWrapperContext:
    def __init__(self, inputParams:InputParams):
        mw = ModelWrapper()
        self.mw = mw
        self.mw.inputParams = deepcopy(inputParams)

    def __enter__(self):
        logger_print("ENTER MODEL WRAPPER CONTEXT")
        return self.mw

    def __exit__(self, exc_type, exc_value, exc_traceback):
        # we don't have to take care of this.
        if exc_type == None:
            logger_print("NO ERROR IN MODEL WRAPPER CONTEXT")
        else:
            logger_print("ERROR IN MODEL WRAPPER CONTEXT")
        {# del self.mw.model #}
        del self.mw
        {# self.mw.exit() #}
        logger_print("EXITING MODEL WRAPPER CONTEXT")

{% for e in ["Inst", "ID", 'Info'] %}
{% set class_types = {}%}
{% set type_suffix = ("模型" if e == "Inst" else ("信息" if e == 'Info' else e)) %}
{% for class_name in 设备接口集合.keys() %}
{% do class_types.update({class_name:class_name+type_suffix}) %}
{% endfor %}
dev{{e}}ClassMap : Dict[str, {{"设备"+type_suffix if type_suffix != "信息" else "BaseModel"}}]= {
    {% for class_name in 设备接口集合.keys() %}
    "{{class_name}}": {{class_types[class_name]}},
    {% endfor %}
} # type: ignore

{% endfor %}

def iterate_input_output_limit(attr, indexs, G, devInstDict):
    m_limit_list = []
    for m_id in indexs:
        m_anchor = G.nodes[m_id]
        m_node_id = m_anchor["device_id"]
        m_devInst = devInstDict[m_node_id]
        m_limit_list.append(getattr(m_devInst, attr))
    io_limit = sum(m_limit_list)
    return io_limit

{# {% macro iterate_input_output_limit(io_type, attr, type_annotation) %}
    {% set devInstVarName = "m_devInst{}".format(io_type.title())%}
                m_limit_list = []
                for m_id in {{io_type}}_indexs:
                    m_anchor = G.nodes[m_id]
                    m_node_id = m_anchor['device_id']
                    {{devInstVarName}} : {{type_annotation}} = devInstDict[m_node_id]
                    m_limit_list.append({{devInstVarName}}.{{attr}})
                {{io_type}}_limit = {{- sum_reduce('m_limit_list') }}
{% endmacro %} #}

# export all these data with no dependency on calculation type.

def getSchemaFromDataModel(dataModel: BaseModel):
    schema = dataModel.schema()
    return schema

def getRequiredKeysSetFromDataModel(dataModel:BaseModel):
    schema = getSchemaFromDataModel(dataModel)
    requiredKeys = schema['required']
    return set(requiredKeys)

def getDuplicatedSchemaKeysSetFromDataModels(dataModel_0:BaseModel, dataModel_1:BaseModel):
    requiredKeysSet_0 = getRequiredKeysSetFromDataModel(dataModel_0)
    requiredKeysSet_1 = getRequiredKeysSetFromDataModel(dataModel_1)
    duplicatedSchemaKeysSet = requiredKeysSet_0.intersection(requiredKeysSet_1)
    return duplicatedSchemaKeysSet

{# TODO: 添加自来水消耗费用 自来水消耗量 #}
class 仿真结果(BaseModel):
    {% for chineseName, englishName in frontend_translation_table.items()%}
    {% if chineseName in ['元件名称', '设备型号', '元件类型']%}
        {% set mtype = 'str'%}
    {% elif chineseName in ["设备台数"]%}
        {% set mtype = 'int'%}
    {% else %}
        {% set mtype  = 'float'%}
        {# need to clarify units! #}
        {# refer to "export_format_validate.py" for unit conversion details. #}
    {% endif%}
    {{englishName}} : {{mtype if mtype !='int' else 'float'}} = Field(title = "{{chineseName}}")
    {# {% if mtype in ['int', 'float']%} #}

    {# unit conversion has been skipped. #}
    {# {%if mtype == 'int'%}
    @validator('{{englishName}}')
    def convert_number_{{englishName}}(cls, v):
        try: 
            val = int(v)
        except:
            val = v
        return val
    {% endif%} #}

    {% endfor %}

{% set planningResultKeyTranslationMap = {'方案详情': '规划结果详情', "方案列表": "规划方案概览"} %}


class 设备模型协议(Protocol):
    设备信息: 设备信息
    
{% macro createFieldsByList(lst)%}
    {% for elem in lst%}
    {{elem['vn']}}: {{elem['vt']}} = Field(title="{{elem['vn']}}", description={{repr(elem['desc'])}})
    """
{{elem['desc'] | indent(4, true)}}
    """

    {%endfor%}
{% endmacro%}
{% for key, elemDict in planningExportFormatList %}
    {% set planningResultExportClassName = planningResultKeyTranslationMap[key] %}
    {% set planningParamLUT = {"cn": [], 'en': []}%}
    {% set planningUnits = {} %}
    {% for elemKey, elem in elemDict.items() %}
        {% set valName = elemKey %}
        {% set valEnglishName = elem['englishName'] %}
        {% set valType = elem['type'] %}
        {% set valUnit = elem['unit'] %}
        {% set description %}{{'单位: '+valUnit+'\n' if valUnit != None else ''}}对应字段: {{valEnglishName}}{% endset %}
        {% set description_en %}{{'单位: '+valUnit+'\n' if valUnit != None else ''}}对应字段: {{valName}}{% endset %}
        {% if valUnit != None%}
            {% do planningUnits.update({valName: valUnit})%}
        {% endif%}
    
        {% do planningParamLUT['cn'].append({"vn": valName, "vt": valType, "desc": description}) %}
        {% do planningParamLUT['en'].append({"vn": valEnglishName, "vt": valType, "desc": description_en}) %}
    {% endfor %}
    {% set planningResultExportClassNameTranslated= planningResultExportClassName+"_翻译"%}
class {{planningResultExportClassNameTranslated}}(BaseModel):
{{createFieldsByList(planningParamLUT['en'])}}

class {{planningResultExportClassName}}(BaseModel):
{{createFieldsByList(planningParamLUT['cn'])}}
    class Units:
    {% for key, unit in planningUnits.items() %}
        {{key}} = {{repr(unit)}}
        {# test type checker #}
    {% endfor %}

    def translate(self):
        paramDict = self.dict()
        {# paramDict = self.to_dict() #}
        TT = self.get_translation_table()
        params = {TT[k]: v for k,v in paramDict.items()}
        return {{planningResultExportClassNameTranslated}}(**params)

    @classmethod
    def get_translation_table(cls) -> Dict[str, str]:
        schema = cls.schema()
        required_keys = schema['required']
        properties = schema['properties']
        translation_table = {}
        for rk in required_keys:
            prop = properties[rk]
            desc = prop['description']
            parse_result = parse.parse('对应字段: {englishTranslation}', desc.split("\n")[-1])
            et = parse_result['englishTranslation']
            translation_table[rk] = et
        return translation_table



    @classmethod
    {% if key == "方案列表" %}
    def export(cls, planningResultList: List[规划结果详情], simulationResultList: List[仿真结果], FSPT:Dict[str,str], totalAnnualFee:float, planType: str): # totalAnnualFee is equivalent to our "financial" objective
        params = dict(年化费用 = totalAnnualFee, 方案类型 = planType)
        def updateParam(k, v):
            {# if type(v) in [float, int]: #}
                {# if not np.isnan(v): #}
            params[k] = params.get(k, 0)+(v if not np.isnan(v) else 0)
                    {# params[k] = params.get(k,0)+v #}
                {# else: #}
                    {# params[k] = params.get(k,0) #}
        duplicate_params_planning_keys = getDuplicatedSchemaKeysSetFromDataModels(规划方案概览,规划结果详情)

        for planningResult in planningResultList:
            for duplicatedKey in duplicate_params_planning_keys:
                val = getattr(planningResult, duplicatedKey)
                updateParam(duplicatedKey, val)

        remainedKeys = getRequiredKeysSetFromDataModel(cls).difference(set(params.keys()))

        for simulationResult in simulationResultList:
            for remainedKey in remainedKeys: # '年热负荷', '年电负荷', '年冷负荷', '年蒸汽负荷', '年氢气负荷'
                {# keyBase = remainedKey.strip("年") #}
                keyBase = remainedKey.strip("年").strip('负荷').strip('消耗量')
                for keySuffix in ['负荷', '消耗量']:
                    attemptKey = f"{keyBase}{keySuffix}"
                {# if (val:=getattr(simulationResult, FSPT.get(keyBase,"NO_TRANSLATION"),...)) is not ...: #}
                    if (val:=getattr(simulationResult, FSPT.get(attemptKey,"NO_TRANSLATION"), ...)) is not ...:
                    {# if (val:=getattr(simulationResult, FSPT.get(attemptKey,...),...)) is not ...: #}
                        updateParam(remainedKey, val)
                    {# FIX: early break #}
                    break
        remainedKeys = getRequiredKeysSetFromDataModel(cls).difference(set(params.keys()))
        for rk in remainedKeys:
            params[rk] = cmath.nan
    {% else %}
    {# 方案详情 #}
    # 此处的仿真结果是每个典型日的仿真结果，不是合并之后的仿真结果表格
    # 出来的也是每个典型日对应的规划详情，需要根据设备ID进行合并
        {# {% set simExportClassList = [] %}
        {% for devName in 设备接口集合.keys() %}
            {% do simExportClassList.append("{}仿真结果".format(devName)) %}
        {% endfor %} #}
    {# @staticmethod #}
    def export(cls, deviceModel: 设备模型协议, deviceSimulationResult, timeParam:float):
    {# def export(deviceModel: 设备模型协议, deviceSimulationResult: Union[{{", ".join(simExportClassList)}}], timeParam:float): #}
    {# def export(deviceModel: 设备模型协议, deviceSimulationResult: 仿真结果, timeParam:float): #}
        params = {}
        params['元件名称'] = deviceModel.设备信息.设备名称
        params['型号'] = getattr(deviceModel.设备信息, '设备型号', '')
        {# params['设备型号'] = getattr(deviceModel.设备信息, '设备型号', '') #}
        params['数量'] = getattr_with_ellipsis_fallback(deviceModel.设备信息,'equiCounts', 0) # 不要累加数量！
        params['平均效率_平均COP'] = getattr_with_ellipsis_fallback(deviceSimulationResult, 'averageEfficiency', cmath.nan)
        params['设备采购成本'] = value(deviceModel.总采购成本) * (timeParam/每年小时数)

        {% for k in ["机组年启动次数","机组年运行时间"] %}
        params[{{repr(k)}}] = value(getattr_with_ellipsis_fallback(deviceModel,{{repr(k)}}, cmath.nan))
        {% endfor %}
        params['设备年维护费'] = getattr_with_ellipsis_fallback(deviceSimulationResult, "设备维护费用", cmath.nan) # 乘过时间参数就不用乘了
        {# params['设备年维护费'] = deviceSimulationResult.equipmentMaintenanceCosts # 乘过时间参数就不用乘了 #}
        for attrName in ['年碳排放', '年NOX排放','年SO2排放']:
            gasType = attrName.strip('年').strip('排放') if '碳' not in attrName else 'CO2'

            # fuel instances. we cannot allow diesel engines for this, since this will introduce errors in summation.
            if isinstance(deviceModel, 柴油模型): # fuel unit: L
            {# if type(deviceModel) in [柴油模型]: # fuel unit: L #}
                # L * (kg/L)
                modelBaseName = deviceModel.__class__.__name__.strip("模型")
                dieselConsumptionUnit = getattr(globals().get(f'{modelBaseName}仿真结果导出单位'), f'{modelBaseName}消耗量')
                val_raw, val_unit = multiplyWithUnit((deviceSimulationResult.柴油消耗量, dieselConsumptionUnit), getattr(deviceModel.设备信息, gasType)) # [数值，单位]
                {# val_raw, val_unit = multiplyWithUnit((deviceSimulationResult.dieselConsumption, dieselConsumptionUnit), getattr(deviceModel.设备信息, gasType)) # [数值，单位] #}
                # gas emission unit: kg
                # now you may want to convert this by acquiring units elsewhere...
                target_unit = getattr({{planningResultExportClassName}}.Units, attrName)
                {# magnitude, _ = unitFactorCalculator(ureg, standard_units, val_unit) #}
                val_quantity = val_raw * ureg.Unit(val_unit)
                val_quantity_target = val_quantity.to(target_unit)
                val = val_quantity_target.magnitude
                {# val = magnitude * val_raw #}
                # kg -> t (standard)
            else:
                val = cmath.nan
            params[attrName] = val

    {% endif %}
        {# FIX: return inside for loop #}
        return cls(
            **params
        )

{% endfor %}


class 节点基类(BaseModel):
    {# type:{{normal_str}} = Field(title = "节点类型") #}
    subtype:{{normal_str}} = Field(title = "节点次类型")
    id:int = Field(title = "节点ID")

class 连线节点(节点基类):
    type: Literal['连接线','合并线']

class 锚点节点(节点基类):
    type: Literal['锚点']
    port_name:{{normal_str}} = Field(title = '锚点名称')
    device_id:{{non_neg_int}} = Field(title = '锚点所对应设备ID')
    
class 母线节点(节点基类):
    type: Literal['母线']
    conn: conlist({{normal_str}}, min_items=2)  = Field(title = '母线连接线类型列表', description = '包括连接到母线上的连接线和合并线类型')# connection/merge types to literal.

class 设备接口映射(BaseModel):
    subtype: {{normal_str}} = Field(title = "接口类型")
    id: {{non_neg_int}} = Field(title = "接口ID", description = "拓扑图上与设备、母线、连接线的ID相比较具有唯一性的ID")

{% set infoClassList = []%}
{% for class_name in 设备接口集合.keys() %}
    {% do infoClassList.append(class_name+"信息")%}
{% endfor %}

class 设备节点基类(节点基类):
    type: Literal['设备']
    ports:Dict[{{normal_str}},设备接口映射] = Field(title = "设备接口映射", description = "描述设备所对应接口的类型和接口ID")

deviceSubtypeAlias = dict(变流器=["单向变流器"])
{# deviceSubtypeAlias = dict(变流器=["单向变流器"], 锂电池=['蓄热设备','蓄冷设备','蓄冰设备']) #}
DSAToDS = {e:k for k, v in deviceSubtypeAlias.items() for e in v}
{# {% set deviceSubtypeAlias = dict(变流器=["单向变流器"]) %} #}
{% set deviceNodeClasses = [] %}
{% for infoClass in infoClassList %}
    {% set deviceName = infoClass.strip("信息")%}
    {% set deviceNodeClassName = deviceName+"节点" %}
    {% do deviceNodeClasses.append(deviceNodeClassName) %}
class {{deviceNodeClassName}}(设备节点基类):
    {# subtype_hidden:Union[None, str] = Field(default = None, title = "节点原次类型", description = "内部变量，不要填写") #}
    subtype: Literal[{{repr(deviceName)}}, *deviceSubtypeAlias.get({{repr(deviceName)}}, [])] = Field(title = "节点次类型")
    {# subtype: Literal[{{repr(deviceName)}}, {{",".join(aliasLiterals)}}] = Field(title = "节点次类型") #}
    param:{{infoClass}} = Field(title = '设备信息', description = {{repr(infoClass)}})

    @validator('subtype')
    def validate_subtype(cls, v, values):
        v = DSAToDS.get(v, v)
        {# values['subtype_hidden'] = v #}
        {# values['param']['subtype_hidden'] = v #}
        return v

{% endfor %}

class mDict(BaseModel):
    directed:bool=Field(default = False, title='保留字段')
    multigraph:bool=Field(default = False, title='保留字段')
    graph:计算参数 = Field(
        title="能流拓扑图的附加属性",
        description="仿真和优化所需的模型参数字典", example = {
            "计算步长": "小时",
            "典型日": False,
            "典型日代表的日期": [],
            "计算类型": "设计规划",
            "风速": [], "光照":[],"气温":[] ,"年利率":0.1})
    nodes:conlist(Union[锚点节点,{{",".join(deviceNodeClasses)}},母线节点,连线节点], min_items=5) = Field(
    {# nodes:conlist(Union[锚点节点,设备节点,母线节点,连线节点], min_items=5) = Field( #}
        title="节点",
        description="由所有节点ID和属性字典组成的列表", example =[ {
                "type": "锚点",
                "port_name": "电接口",
                "subtype": "供电端输出",
                "device_id": 2,
                "id": 3
            }])
    links:conlist(Dict[Literal['source','target'], int], min_items=4) = Field(
        title="边",
        description="由能流图中节点互相连接的边组成的列表", example = [
            {
                "source": 0,
                "target": 1
            },
            {
                "source": 1,
                "target": 31
            }])

# TODO: 增加单典型日判断类型或者字段

class EnergyFlowGraph(BaseModel):
    mDictList: List[mDict]
    residualEquipmentLife: confloat(ge=0) = Field(
        default=0, title="辅助设备寿命", description="默认为0，年化率返回为1\n单位：年\n用于计算辅助设备年化系数"
    )

from networkx import Graph
from failsafe_utils import failsafe_suppress_exception

# partial if typical day mode is on.
def compute(devs:List[dict], adders:Dict[int,dict], graph_data:dict, G: Graph, mw: ModelWrapper):
    PD = {}
    algoParam = 计算参数.parse_obj(graph_data)

    devInstDict = {}

    for dev in devs:
        with failsafe_suppress_exception():
            devSubtype = dev['subtype']
            {# devParam = {k:v for k,v in dev.items() if k not in {"subtype","type","ports"} } #}
            devParam = dev['param']
            devPorts = dev['ports']

            devID_int = dev['id']

            devIDClass = devIDClassMap[devSubtype]

            devIDInstInit = {"ID": devID_int}
            for port_name, port_info in devPorts.items():
                with failsafe_suppress_exception():
                    port_id = port_info['id']
                    devIDInstInit.update({port_name:port_id})
            devIDInst = devIDClass.parse_obj(devIDInstInit)

            devInfoInstInit = devParam
            devInfoClass = devInfoClassMap[devSubtype]
            devInfoInst = devInfoClass.parse_obj(devInfoInstInit)

            devInstClass = devInstClassMap[devSubtype]
            devInst = devInstClass(PD = PD, mw=mw, 计算参数实例=algoParam, 设备ID= devIDInst, 设备信息=devInfoInst) # type: ignore

            devInstDict.update({devID_int: devInst})

    for adder_index, adder in adders.items():
        with failsafe_suppress_exception():
            input_indexs, output_indexs, io_indexs = adder['input'], adder['output'], adder['IO']

            # fill in missing params
            with failsafe_suppress_exception():
                if len(input_indexs) >= 1:
                    if G.nodes[input_indexs[0]]['subtype'] == "柴油输出":
                        assert len(input_indexs) == 1, "柴油元件只能一对多连接"
                        diesel_node_id = G.nodes[input_indexs[0]]['device_id']
                        {# 热值 = devInstDict[diesel_node_id].设备信息.热值 #}
                        热值 = devInstDict[diesel_node_id].热值
                        for output_index in output_indexs:
                            output_node_index = G.nodes[output_index]['device_id']
                            devInstDict[output_node_index].燃料热值 = 热值
            # add them all.

            logger_print("_"*20)
            display_var_names = lambda indexs: '\n    '.join([str(PD[i]) for i in indexs])
            logger_print(f"INPUTS:{display_var_names(input_indexs)}")
            logger_print()
            logger_print(f"OUTPUTS:{display_var_names(output_indexs)}")
            logger_print()
            logger_print(f"IO:{display_var_names(io_indexs)}")
            logger_print("_"*20)

            for j in range(algoParam.迭代步数):
                seqsum = {{- sum_reduce('[PD[i][j] for i in input_indexs + output_indexs + io_indexs]') }}
                # TODO: 消纳率约束
                mw.Constraint(seqsum >=0)

            with failsafe_suppress_exception():
                if algoParam.计算类型 == '设计规划':
                    cnt = 0
                    if len(input_indexs)==0:
                        continue
                    input_anchor_0 = G.nodes[input_indexs[0]]
                    if input_anchor_0['subtype'] == '变压器输出':
                        logger_print(f"Building Converter Constraint #{cnt}")
                        cnt+=1
                        assert io_indexs == []

                        input_limit = iterate_input_output_limit("最大允许的负载总功率", input_indexs, G, devInstDict)
    {# {{ iterate_input_output_limit("input","最大允许的负载总功率", "变压器模型") }} #}
                        output_limit = iterate_input_output_limit("MaxEnergyConsumption", output_indexs, G, devInstDict)
    {# {{ iterate_input_output_limit("output","MaxEnergyConsumption", "电负荷模型") }} #}

                        mw.Constraint(input_limit + output_limit >= 0)

    {# financial_obj_expr = {{- sum_reduce('[e.constraints_register() for e in devInstDict.values()]') }} #}
    financial_obj_expr = 0


    for e in devInstDict.values():
        with failsafe_suppress_exception():
            financial_obj_expr += e.constraints_register()
            financial_obj_expr = addPunishRateToFinancialTarget(financial_obj_expr, devInst)

    financial_dyn_obj_expr = 0

    for e in devInstDict.values():
        with failsafe_suppress_exception():
            financial_dyn_obj_expr += e.总可变维护成本年化
            financial_dyn_obj_expr = addPunishRateToFinancialTarget(financial_obj_expr, devInst)


    {# financial_dyn_obj_expr = sum([(e.总可变维护成本年化) for e in devInstDict.values()]) #}

    environment_obj_exprs = [] # annual CO2 emission
    
    for e in devInstDict.values():
        {# if type(e) == 柴油模型: #}
        if isinstance(e, 柴油模型):
            environment_obj_exprs.append((sum(e.燃料接口.values())/e.计算参数.迭代步数)*每年小时数 * e.CO2)

    environment_obj_expr = sum(environment_obj_exprs)
    
    obj_exprs = (financial_obj_expr,
                financial_dyn_obj_expr,
                environment_obj_expr,
    )
    return obj_exprs, devInstDict, PD
    # always minimize the objective.

def addValueToTarget(target, devInst, attrName:str, iterCount:int):
    if hasattr(devInst, attrName):
        target += getattr(devInst, attrName) * iterCount
    return target

def addNewRateToAnnualTarget(target, devInst, attrName:str):
    target = addValueToTarget(target, devInst, attrName, 每年小时数)
    return target

def addPunishRateToFinancialTarget(target, devInst):
    target = addNewRateToAnnualTarget(target, devInst, 'punishRate')
    return target

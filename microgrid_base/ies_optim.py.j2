# TODO: 典型日 最终输出结果需要展开为8760

# the main code for computing.
# currently just compute microgrid
# three computation modes:

# 8760 hours of data
# several days of data to compute a year

# 7200 seconds. simulation

# device parameters would be the same.

# load and environment might change.

# so for every device the will change.

# iterate through all device-port pairs, then retrieve attributes from another dict.

from pydantic import BaseModel
from typing import List
# string, digits, tables.
# you can dump and load from json.
{# 
class 加法器ID(BaseModel):
    输入:int
    输出:int
    输入输出: int #}

{% for super_class, class_name, mstrs, mdigits, mtables in 设备库 %}

class {{class_name}}ID(BaseModel):
    ID: int
    {% for port_name, port_type in 设备接口集合[class_name]%}
    {{ port_name }}: int
    """
    类型: {{ port_type }}
    """
    {% endfor %}

class {{class_name}}信息(BaseModel): # {{super_class}}
    {% for mstr in mstrs %}
    {{ mstr }}: str

    {% endfor %}
    
    {% for mdigit in mdigits %}
    {{ mdigit[0] }}: float
    """
    名称: {{ mdigit[1]}}
    单位: {{mdigit[2]}}
    """

    {% endfor %}

    {% for mtable in mtables %}
    {{ mtable[0][0]}}_{{ mtable[1][0]}} : List[List[float]]
    """
    {{ mtable[0][0]}}: {{ mtable[0][1]}}
    单位: {{ mtable[0][2]}}

    {{ mtable[1][0]}}: {{ mtable[1][1]}}
    单位: {{ mtable[1][2]}}
    """

    {% endfor %}
{% endfor %}

####################
# model definition #
####################

from pyomo.environ import *

# first convert the unit.
# assign variables.

# shall you assign port with variables.

# 风、光照
from typing import Union, Literal, List

# 需要单位明确
class 计算参数(BaseModel):
    典型日ID: Union[int, None] = None
    计算步长: Union[Literal["小时"], Literal['秒']]
    计算模式: Union[Literal['典型日'],None]
    计算类型: Union[Literal['仿真模拟'],Literal['设计规划']]
    风速: List[float]
    """
    单位: m/s
    """
    光照: List[float]
    """
    单位: kW/m2
    """
    气温: List[float]
    """
    单位: 摄氏度
    """
    年利率: Union[float, None]
    """
    单位: percent
    """
    @property
    def 迭代步数(self):
        {# steps = None #}
        if self.计算步长 == "秒":
            steps = 7200
        elif self.计算步长 == "小时" and self.计算模式 is None:
            steps = 8760
        elif self.计算步长 == "小时" and self.计算模式 is "典型日":
            steps = 24
        else:
            raise Exception("未知计算参数:", self.计算步长, self.计算模式)
        assert len(self.风速) == steps
        assert len(self.光照) == steps
        assert len(self.气温) == steps
        return steps
    {# @property # 提前计算好了
    def 典型日列表(self): # 
        ... #}
    {# # like: (tday_index, tday_data, tday_count) #}

from functools import reduce
class 设备模型:
    def __init__(self, model: ConcreteModel, 计算参数实例: 计算参数, ID):
        self.model = model
        self.计算参数 = 计算参数实例
        self.ID = ID

    def getVarName(self, varName: str):
        VN = f"DI_{self.ID}_VN_{varName}" # use underscore.
        if self.计算参数.典型日ID:
            VN = f"TD_{self.计算参数.典型日ID}_"+VN
        return VN

    def 单变量(self, varName: str, **kwargs):
        var = self.model.__dict__[self.getVarName(varName)] = Var(**kwargs)
        return var

    def 变量列表(self, varName: str,**kwargs):
        var = self.model.__dict__[self.getVarName(varName)] = Var(range(self.计算参数.迭代步数), **kwargs)
        return var

    def RangeConstraint(var_1, var_2, expression):
        for i in range(self.计算参数.迭代步数):
            Constraint(expression(var_1[i], var_2[i]))

    def CustomRangeConstraint(var_1, var_2, customRange, expression):
        for i in range(customRange):
            Constraint(expression(var_1, var_2, i))
    
    def SumRange(var_1):
        return reduce([var_1[i] for i in range(self.计算参数.迭代步数)], lambda x,y: x+y)
    {# def 典型日变量列表(self, varName: str,**kwargs):
        varList = []
        for i in range(len(self.计算参数.典型日列表)):
            var = self.model.__dict__[f"典型日[{i}]_"+self.getVarName(varName)] = Var(range(24), **kwargs)
            varList.append(var)
        return varList #}

# input: negative
# output: positive
# IO: Real

{% for super_class, class_name, mstrs, mdigits, mtables in 设备库 %}

class {{class_name}}模型(设备模型):
    def __init__(self, model: ConcreteModel, 计算参数实例: 计算参数, 设备ID: {{ class_name }}ID, 设备信息: {{ class_name }}信息):
        super().__init__(model=model, 计算参数实例=计算参数实例, ID = 设备ID.ID)
        self.设备ID = 设备ID
        self.设备信息 = 设备信息

        if self.计算参数.计算类型 == "设计规划":
            self.DeviceCount = self.单变量('DeviceCount', within=NonNegativeIntegers)

        {% for mdigit in mdigits %}
        {% if super_class in ["仿真模拟","设计规划"] %}
        {% if super_class == "仿真模拟" %}
        if self.计算参数.计算类型 == "仿真模拟":
        {% elif super_class == "设计规划" %}
        if self.计算参数.计算类型 == "仿真模拟":
        {%endif%}
            {% if mdigit[4] == 1%}
            self.{{ mdigit[0] }}: float = 设备信息.{{ mdigit[0] }}
            """
            名称: {{ mdigit[1] }}
            单位: {{ mdigit[3] }}
            """
            {%else%}
            self.{{ mdigit[0] }}: float = 设备信息.{{ mdigit[0] }} * {{ mdigit[4]}}
            """
            名称: {{ mdigit[1] }}
            单位: {{ mdigit[3] }} <- {{ mdigit[2] }}
            """
            {% endif %}
            assert self.{{ mdigit[0] }} >=0
        {% else %}
        {% if mdigit[4] == 1 or mdigit[0] in ["PowerDeltaLimit", "RatedWindSpeed", "MaxWindSpeed", "MinWindSpeed"] %}
        self.{{ mdigit[0] }}: float = 设备信息.{{ mdigit[0] }}
        """
        名称: {{ mdigit[1] }}
        单位: {{ mdigit[3] }}
        """
        {%else%}
        self.{{ mdigit[0] }}: float = 设备信息.{{ mdigit[0] }} * {{ mdigit[4]}}
        """
        名称: {{ mdigit[1] }}
        单位: {{ mdigit[3] }} <- {{ mdigit[2] }}
        """
        assert self.{{ mdigit[0] }} >=0
        {% endif %}

        {% endfor %}

        {% for mtable in mtables %}
        self.{{ mtable[0][0]}}_{{ mtable[1][0]}} : List[List[float]] = [[v1 * {{mtable[0][4]}}, v2 * {{mtable[1][4]}}] for v1, v2 in 设备信息.{{ mtable[0][0]}}_{{ mtable[1][0]}}]
        self.{{ mtable[0][0]}}_{{ mtable[1][0]}}.sort(key=lambda x: x[1])
        """
        {{ mtable[0][0]}}: {{ mtable[0][1]}}
        单位: {{ mtable[0][3]}} <- {{ mtable[0][2]}}

        {{ mtable[1][0]}}: {{ mtable[1][1]}}
        单位: {{ mtable[1][3]}} <- {{ mtable[1][2]}}
        """

        {% endfor %}

        ##### PORT VARIABLE DEFINITION ####
        
        {% for port_name, port_type in 设备接口集合[class_name] %}
        {% if port_type.endswith("输入输出") %}
        self.{{port_name}} = self.变量列表("{{port_name}}", within=Reals)
        {% elif port_type.endswith("输入") %}
        self.{{port_name}} = self.变量列表("{{port_name}}", within=NegativeReals)
        {% elif port_type.endswith("输出") %}
        self.{{port_name}} = self.变量列表("{{port_name}}", within=NonNegativeReals)
        {% endif %}
        """
        类型: {{port_type}}
        """

        {% endfor %}
    
    def constraints_register(self):
        {% if class_name == "风力发电"%}
        # define a single-variate piecewise function
        # 
        #         ____
        #        /    |
        #       /     | ax^3
        #  ----/      |______
        #
        assert self.RatedWindSpeed > self.MinWindSpeed
        assert self.MaxWindSpeed > self.RatedWindSpeed

        发电曲线参数 = self.RatedPower / ( (self.RatedWindSpeed - self.MinWindSpeed) ** 3)

        # windspeed -> current power per device
        def 发电曲线(windspeed):
            if windspeed <= self.MinWindSpeed:
                return 0
            elif windspeed > self.MinWindSpeed and windspeed <= self.RatedWindSpeed:
                return 发电曲线参数 * ((self.RatedWindSpeed - self.MinWindSpeed) ** 3)
            elif windspeed > self.RatedWindSpeed and windspeed < self.MaxWindSpeed:
            elif windspeed >= self.
        {% endif %}

        if self.计算参数.计算模式 == "仿真模拟":
            {% if class_name in ['光伏发电'] %}
            ...
            {% else %}
            {% endif %}
        elif self.计算参数.计算模式 == "规划设计":
            {% if class_name in ['光伏发电'] %}
            MaxDeviceCount = self.MaxInstallArea/self.Area
            MinDeviceCount = self.MinInstallArea/self.Area
            self.DeviceCount
            assert MinDeviceCount>=0
            assert MaxDeviceCount>=MinDeviceCount

            Constraint(self.DeviceCount <= MaxDeviceCount)
            Constraint(self.DeviceCount >= MinDeviceCount)
            {% else %}
            Constraint(self.DeviceCount <= self.MaxDeviceCount)
            Constraint(self.DeviceCount >= self.MinDeviceCount)
            {% endif %}
        else:
            raise Exception("未知计算模式:", self.计算参数.计算模式)
        {# self.model.__dict__['{{}}'] = Var() #}

        {% if class_name in ['光伏发电'] %}
        光电转换效率 = self.MaxPower / self.Area # 一块光伏板，1kw/m2光照
        总最大功率 = self.MaxPower * self.DeviceCount

        self.RangeConstraint(self.计算参数.光照, self.电输出, lambda x,y: x*self.PowerConversionEfficiency*光电转换效率 >= y)
        {% elif class_name in [] %}
        {% endif %}

        if self.计算参数.计算步长 == "秒":
            {% if class_name in ['光伏发电'] %}
            最大功率变化 = 总最大功率 *self.PowerDeltaLimit / 100
            self.CustomRangeConstraint(self.电输出 , self.PowerDeltaLimit, lambda x,y,i: x[i+1] - x[i] <= 最大功率变化)
            self.CustomRangeConstraint(self.电输出 , self.PowerDeltaLimit, lambda x,y,i: x[i+1] - x[i] >= -最大功率变化)
            {%endif%}
        elif self.计算参数.计算步长 == "小时":
            ...
        else:
            raise Exception("未知计算步长:", self.计算参数.计算步长)
    
    # 计算年化
    {% if class_name in ['光伏发电'] %}
    Life = self.Life
    {%else%}
    ...
    {%endif%}
    年化率 = ((1+(self.计算参数.年利率/100))** Life) / Life
    # unit: one
    if 计算参数.计算模式 == "规划设计":
        {% if class_name in ['光伏发电'] %}
        总采购成本 = self.CostPerWatt * 总最大功率 
        总固定维护成本 = self.CostPerYear * 总最大功率 
        总建设费用 = self.BuildCostPerWatt * 总最大功率 + self.BuildBaseCost

        总固定成本年化 = (总采购成本 + 总固定维护成本 + 总建设费用)*年化率

        总可变维护成本年化 = self.SumRange(self.电输出) * (8760 / self.计算参数.迭代步数) # 由于是小时步长 不用乘时间
        {% else %}
        {% endif %}
{% endfor %}

# TODO: 典型日 最终输出结果需要展开为8760
# TODO: add more "bounds" to variables
{# optional comment flag for our stepwise refactor. #}
{%set SO = namespace(class_name="")%}
{# {% set needStorageDecayCompensation=true%} #}
{% macro stepwise_flag(class_name, flag_name) %}{% if SO.class_name == class_name %}{{' STEPWISE FLAG [{}] '.format(flag_name).center(40, "#") }}{% endif %}{% endmacro %}
from typing import Dict, List, Tuple, Union, Callable
from pydantic import conlist, conint, confloat, constr
{# consider to type check all variable operations #}
{# cast such type to all variables, to forbid 'var * var' #}
import pyomo.core.base
{% set IndexedVar = "pyomo.core.base.var.IndexedVar" %}
{% set GeneralVarData = "pyomo.core.base.var._GeneralVarData" %}
{# forbid untyped code. #}
{# mark as pyright global config. #}
{# also for mypy #}
{% set normal_str = "constr(min_length=1)"%}
{% set non_neg_float = "confloat(ge=0)"%}
{% set pos_float = "confloat(gt=0)"%}
{% set non_neg_int = "conint(ge=0)"%}
{% set pos_int = "conint(gt=0)"%}
{% macro qstr(mstr)%}"{{mstr}}"{%endmacro%}
{% macro import_type_fallback(symbol)%}
try:
    from typing import {{symbol}}
except:
    from typing_extensions import {{symbol}}
{% endmacro %}
{{import_type_fallback("Literal")}}
{# 
try:
    from typing import Annotated
except:
    from typing_extensions import Annotated #}

{# from typing import Tuple #}

{% macro double_check_setattr(obj, attrName, val) %}
assert getattr({{obj}},{{attrName}}, None) is None, f"错误: 不能设置两次相同的变量名称\n重复变量: { {{attrName}} }"
{{obj}}.__setattr__({{attrName}}, {{val}})
{% endmacro %}

import rich
from pydantic import BaseModel, Field, validator
# the main code for computing.
# currently just compute microgrid
# three computation modes:
{# shall you define more string literals in enum class, and more pydantic models, union types.#}
{# from functools import lru_cache #}

{# item count is for list, length is for string.#}
{% macro tuple_type_construct(l, t)%}{{", ".join([t]*l)}}{% endmacro%}
{# {% macro item_constraint(l)%}min_item = {{l}}, max_item= {{l}}{% endmacro%} #}

{# ##########[PINT START]########## #}

{# import pint #}

from unit_utils import (
    unitFactorCalculator,
    ureg,
    standard_units,
    getSingleUnitConverted,
)

{# ##########[PINT END]########## #}

### 计价模型 ###
import math
# 函数参数: (power, time_in_day)
# 阶梯电价: 容量下限从0开始

# TODO: 每个月的都不同 #

{% set 电价单位 = "元/kWh"%}
{% set 电价单位描述 = "单位: 元/kWh"%}

{% macro getFee()%}
    def getFee(self, power:float, time_in_day:float) -> float:
{% endmacro%}
{% macro getMonthIndexFromTimeInDay()%}
        current_day_index = time_in_day//24
        month_index = convertDaysToMonth(current_day_index)
{% endmacro%}
{% macro getCurrentTimeFromTimeInDay()%}
        current_time = math.floor(time_in_day%24)
{% endmacro%}
{% macro returnElectricPrice() %}
        return self.convert(price*power)
{% endmacro%}
{% macro getFeeWrapper()%}
{{getFee()}}
{{caller()}}
{{ returnElectricPrice()}}
{% endmacro%}
from functools import lru_cache
class 电价转换:
    @staticmethod
    @lru_cache(maxsize=1)
    def getMagnitude():
        magnitude, _ = unitFactorCalculator(ureg, standard_units, "{{电价单位}}")
        return magnitude
    @staticmethod
    def convert(value):
        # convert to standard unit
        magnitude = 电价转换.getMagnitude()
        ret = value * magnitude
        return ret

class 常数电价(BaseModel, 电价转换):
    Price:{{pos_float}} = Field(title = "电价", description = "{{电价单位描述}}")

{%call getFeeWrapper()%}
        price = self.Price
{% endcall%}

month_days = [31] * 12
month_days[1] = 28
month_days[4 - 1] = month_days[6 - 1] = month_days[9 - 1] = month_days[11 - 1] = 30
assert sum(month_days) == 365

def convertMonthToDays(month_index:int):
    {# cursor = month_index -1 #}
    assert month_index in range(12)
    ret = sum(month_days[:month_index])
    return ret

def convertDaysToMonth(day_index:float):
    acc_days = 0
    for month_cursor, days_in_month in enumerate(month_days):
        acc_days += days_in_month
        if acc_days >= day_index:
            return month_cursor
    {# if day_index <365:
        return month_cursor+1 #}
    raise Exception("Invalid day index:", day_index)

class 分月电价(BaseModel, 电价转换):
    PriceList:Tuple[{{tuple_type_construct(12, "float")}}] =Field(title = "长度为12的价格数组", description = "{{电价单位描述}}")
    
{%call getFeeWrapper()%}
{{getMonthIndexFromTimeInDay()}}
        price = self.PriceList[month_index]
{% endcall%}

class 分时电价(BaseModel, 电价转换):
    PriceList: Tuple[{{tuple_type_construct(24, "float")}}] = Field(title = "长度为24的价格数组", description = "{{电价单位描述}}")
{# 
    @validator("PriceList")
    def checkPriceList(cls, val):
        assert len(val) == 24
        return val #}

{%call getFeeWrapper()%}
{{getCurrentTimeFromTimeInDay()}}
        price = self.PriceList[current_time]
{% endcall%}

class 分时分月电价(BaseModel, 电价转换):
    PriceStruct:Tuple[{{tuple_type_construct(12, "分时电价")}}] = Field(title = "长度为12的分时电价数组", description = "{{电价单位描述}}")
{# {%call getFeeWrapper()%} #}
{{ getFee()}}
{{getMonthIndexFromTimeInDay()}}
        _分时电价 = self.PriceStruct[month_index]
        ret = _分时电价.getFee(power,time_in_day)
        return ret
{# {{getCurrentTimeFromTimeInDay()}} #}
        {# price = _分时电价.PriceList[current_time]
{% endcall%} #}

class 计价阶梯(常数电价):
    LowerLimit : {{non_neg_float}} = Field(title = "功率下限")

class 阶梯电价(BaseModel):
    PriceStruct: conlist(计价阶梯, min_items=1) = Field(title = "长度不定的计价阶梯列表", description = "{{电价单位描述}}")

    @validator("PriceStruct")
    def checkPriceStruct(cls, v: List[计价阶梯]):
        v.sort(key = lambda x: x.LowerLimit)
        assert v[0].LowerLimit == 0
        return v
    
{{getFee()}}
        for index, elem in enumerate(self.PriceStruct):
            if elem.LowerLimit <= power:
                if index+1 == len(self.PriceStruct) or self.PriceStruct[index+1].LowerLimit >= power:
                    return elem.getFee(power, time_in_day)
        rich.print(self)
        raise Exception("Unable to get electricity price with power:", power)

class 分时阶梯电价(BaseModel):
    PriceStructList:Tuple[{{tuple_type_construct(24,"阶梯电价")}}] = Field(title = "长度为24的阶梯电价列表", description = "{{电价单位描述}}")

{{getFee()}}
        current_time = math.floor(time_in_day%24)
        mPriceStruct = self.PriceStructList[current_time]
        result = mPriceStruct.getFee(power, time_in_day)
        return result

{% set load_types = ['电']%}
{% set load_class_names = []%}
{% for load_type in load_types%}
{% do load_class_names.append(load_type+"负荷")%}
{% endfor%}
{% set input_types = ['柴油'] %}

{% macro sum_reduce(seq)%}
 sum({{seq}})
{# functools.reduce(sequence={{seq}}, function = lambda x,y: x+y) #}
{% endmacro%}

{% macro init_super_class(class_name)%}
    def __init__(self, PD:dict, mw: ModelWrapper, 计算参数实例: 计算参数, 设备ID: {{ class_name }}ID, 设备信息: {{ class_name }}信息):
        super().__init__(PD=PD, mw=mw, 计算参数实例=计算参数实例, ID = 设备ID.ID)
        self.设备ID = 设备ID
        self.设备信息 = 设备信息
{% endmacro %}

{%macro port_variable_define(class_name)%}
        ##### PORT VARIABLE DEFINITION ####

        self.ports = {}
        
        {% for port_name, port_type in 设备接口集合[class_name] %}
        {% if port_type.endswith("输入输出") %}
        {% set mt = "Reals" %}
        {% elif port_type.endswith("输入") %}
        {# {% set mt = "NegativeReals"%} #}
        {% set mt = "NonPositiveReals"%}
        {% elif port_type.endswith("输出") %}
        {% set mt = "NonNegativeReals"%}
        {% endif %}
        self.PD[self.设备ID.{{port_name}}] = self.ports['{{port_name}}'] = self.{{port_name}} = self.变量列表("{{port_name}}", within={{mt}})
        """
        类型: {{port_type}}
        """

        {% endfor %}
{% endmacro %}

{%macro expand_unit_conversion(mdigit, exceptionList=[])%}
        {% if mdigit[4] == 1 or mdigit[0] in exceptionList%}
        self.{{ mdigit[0] }}: float = 设备信息.{{ mdigit[0] }}
        """
        名称: {{ mdigit[1] }}
        单位: {{ mdigit[2] }}
        """
        {%else%}
        self.{{ mdigit[0] }}: float = 设备信息.{{ mdigit[0] }} * {{ mdigit[4]}}
        """
        名称: {{ mdigit[1] }}
        单位: {{ mdigit[3] }} <- {{ mdigit[2] }}
        """
        {% endif %}
        assert self.{{ mdigit[0] }} >=0
{%endmacro%}


{% set 时间步长参数='self.计算参数.时间参数'%}
{# {% set 时间步长参数='self.计算参数.时间参数()'%} #}
{# {% set 时间步长参数='(1 if self.计算参数.计算步长 == "小时" else 3600)'%} #}

{% set 单向变电器列表 = ['变压器', '变流器']%}

{%set 设备参数例外列表 = ["PowerDeltaLimit", "RatedWindSpeed", "MaxWindSpeed", "MinWindSpeed", "BatteryDeltaLimit", "BatteryStorageDecay", 'BatteryDeltaLimit']%}
# 8760 hours of data
# several days of data to compute a year

# 7200 seconds. simulation

# device parameters would be the same.

# load and environment might change.

# so for every device the will change.

# iterate through all device-port pairs, then retrieve attributes from another dict.

# string, digits, tables.
# you can dump and load from json.
{# 
class 加法器ID(BaseModel):
    输入:int
    输出:int
    输入输出: int #}

{# {% for super_class, class_name, mstrs, mdigits, mtables in 设备库 %} #}

#############
# Device ID #
#############
from pydantic import validator
class 设备ID(BaseModel):
    ID: {{non_neg_int}} = Field(title = "设备ID", description = '从拓扑图节点ID获取')

{% for class_name in 设备接口集合.keys()%}

class {{class_name}}ID(设备ID):
    {% for port_name, port_type in 设备接口集合[class_name]%}
    {{ port_name }}: {{non_neg_int}} = Field(title = "{{ port_name }}ID", description = "接口类型: {{ port_type }}")
    """
    类型: {{ port_type }}
    """
    {% endfor %}

{% endfor %}

###############
# Device Info #
###############

{% set deviceBaseIdentifiers = [
    "设备名称",
]%}
{% set deviceOptionalIdentifiers = [
    "生产厂商",
    "设备型号",
]%}
{% set deviceIdentifiers = deviceBaseIdentifiers + deviceOptionalIdentifiers %}

class 设备基础信息(BaseModel):
{% for i in deviceBaseIdentifiers%}
    {{i}}: {{normal_str}} = Field(title = "{{i}}")

{% endfor %}

class 设备信息(设备基础信息):
{% for i in deviceOptionalIdentifiers%}
    {{i}}: {{normal_str}} = Field(title = "{{i}}")

{% endfor %}

{% set NonLoadDeviceDict = {}%}

{# 不是标准单位 #}
{% set 燃料能源相关数据默认单位 = {
    '柴油':{
        "Price": "万元/L",
        "热值": "kWh/L",
        "CO2": "kg/L"
    }
}%}
{% for super_class, class_name, mstrs, mdigits, mtables in 设备库 %}
    {% do NonLoadDeviceDict.update({class_name: (super_class, mstrs, mdigits, mtables)})%}
{% endfor %}
{% for class_name in 设备接口集合.keys() %}

class {{class_name}}信息({{"设备基础信息" if class_name not in NonLoadDeviceDict.keys() else "设备信息"}}):
    {% if class_name not in NonLoadDeviceDict.keys() %}
        {% if class_name in load_class_names %}
    # 正数
    EnergyConsumption: List[{{non_neg_float}}] = Field(title = '耗能功率表', description='单位: kW')
    """
    单位: kW
    {# In this way it will be timescale independent. #}
    """

    MaxEnergyConsumption: Union[None, {{pos_float}}] = Field(default = None, title = "最大消耗功率", description = '单位: kW\n用于典型日下计算变压器容量')
    """
    单位: kW
    {# 用于电负荷 典型日计算 #}
    """

            {% if class_name in ["电负荷"]%}
    PriceModel: Union[常数电价, 阶梯电价, 分时电价, 分时阶梯电价, 分月电价, 分时分月电价] = Field(title = '计价模型', description='单位: kWh/元')
            {% else %}
                {% error("未找到'{}'的计价模型".format(class_name)) %}
            {% endif %}
        {% else %}
            {% if class_name in 燃料能源相关数据默认单位.keys() %}
                {% for attrName, defaultUnit in 燃料能源相关数据默认单位[class_name].items()%}
    {{ attrName}} : Tuple[{{pos_float}}, {{normal_str}}] = Field(title = "{{attrName}}", description="格式: [数值,单位]")
    """
    格式: [数值,单位]
    """
                {% endfor%}

    class DefaultUnits:
                {% for attrName, defaultUnit in 燃料能源相关数据默认单位[class_name].items()%}
        {{attrName }} = "{{defaultUnit}}"
                {%endfor%}
            {% else%}
                {% error("未知负荷信息类型:", class_name)%}
            {% endif%}
        {% endif%}
    {% else %}
        {% set super_class, mstrs, mdigits, mtables = NonLoadDeviceDict[class_name] %}
        {# special variables for non-load device info #}
        {% if class_name in ['锂电池']%}
    needStorageDecayCompensation : bool = Field(default=True, title = "是否允许可变存储衰减补偿", description = "开启后存储衰减补偿将可变，反之存储衰减补偿等于存储衰减")
        {% endif%}
        {% for psc, mstr in mstrs %}
            {%if mstr not in deviceIdentifiers%}
    {{ mstr }}: {{normal_str}} = Field(title = "{{mstr}}")
            {% endif%}

        {% endfor %}
    
        {% for psc, mdigit in mdigits %}
    {{ mdigit[0] }}: {{non_neg_float}} = Field(title = "{{mdigit[1]}}", description =   "名称: {{ mdigit[1] }}\n单位: {{ mdigit[2] }}")
    """
    名称: {{ mdigit[1] }}
    单位: {{ mdigit[2] }}
    """

        {% endfor %}

        {% for psc, main, sub in mtables %}
            {% set mtable=(main, sub)%}
    {{ mtable[0][0]}}_{{ mtable[1][0]}} : List[Tuple[{{pos_float}},{{non_neg_float}}]] = Field(title = "{{ mtable[0][1]}}_{{ mtable[1][1]}}", description=   "{{ mtable[0][0]}}: {{ mtable[0][1]}}\n单位: {{ mtable[0][2]}}\n{{ mtable[1][0]}}: {{ mtable[1][1]}}\n单位: {{ mtable[1][2]}}")
    """
    {{ mtable[0][0]}}: {{ mtable[0][1]}}
    单位: {{ mtable[0][2]}}

    {{ mtable[1][0]}}: {{ mtable[1][1]}}
    单位: {{ mtable[1][2]}}
    """

        {% endfor %}
    {% endif %}
{% endfor %}

####################
# model definition #
####################

from pyomo.environ import *

{# from pyomo.core.expr.sympy_tools import sympyify_expression, sympy2pyomo_expression #}
{# from typing import cast #}
from sympy.polys.polytools import Poly
import re
from sympy import sympify
# taking too long. recursion.
from progressbar import progressbar
{# 
def find_parentheses(s):
    stack = []
    result = [] # EIPList
    for i, c in enumerate(progressbar(s)):
        if c == '(':
            stack.append(i) # 记录左括号的位置
        elif c == ')':
            if stack: # 如果栈不为空
                start = stack.pop() # 弹出最近的左括号位置
                if not stack: # 如果栈为空，说明找到了一个最外层的括号对
                    result.append(s[start:i+1]) # 将括号对加入结果列表
    return result #}

from expr_utils import getExprStrParsedToExprList

{# mystr = '(1,2,3), (((1+2),2),5,(6,7)) 23'
print(find_parentheses(mystr)) #}

def withBanner(banner: str = ""):
    def decorator(func):
        def inner_func(*args, **kwargs):
            print(f"_____________{banner}_____________")
            val = func(*args, **kwargs)
            print(f"_____________{banner}_____________")
            return val
        return inner_func
    return decorator


@withBanner("ERROR LOG")
def examineSubExprDegree(expr):
    data = str(expr)
    exprlist = getExprStrParsedToExprList(data)
    {# print("SPLITING EXPR")
    expr_repr = str(expr)
    regex = re.compile(r'(\[\d+\])')
    subs = regex.findall(expr_repr)
    subs = set(subs)
    for sub in subs:
        num = sub.strip("[").strip("]")
        expr_repr = expr_repr.replace(sub, f"_Array")
    EIPList = find_parentheses(expr_repr)
    elems_in_parentheses = set(EIPList)

    EIPMAP = {e: f'EIP_{i}' for i, e in enumerate(elems_in_parentheses)}
    EIPMAP_REV = {v:k for k,v in EIPMAP.items()}
    for EIP, EIP_CODE in EIPMAP.items():
        expr_repr = expr_repr.replace(EIP, EIP_CODE)
    
    subexpr_strs = expr_repr.replace("-", "+ -").split("+") #}
    print("ANALYSING TERMS")
    for subexpr in progressbar(exprlist):
        {# subexpr_str = subexpr_str.strip()
        if len(subexpr_str) == 0:
            continue
        for k,v in EIPMAP_REV.items():
            subexpr_str = subexpr_str.replace(k,v)
        subexpr = sympify(subexpr_str) #}
        subpoly = Poly(subexpr)
        subpoly_deg = subpoly.total_degree()
        if subpoly_deg not in [0,1]:
            print()
            print("Abnormal subexpression poly degree:", subpoly_deg)
            # recover expression representation
            {# subexpr_pyomo = sympy2pyomo_expression(subexpr, objmap)
            subexpr_pyomo_repr = str(subexpr_pyomo) #}
            print("Abnormal expression:", subexpr)
            {# print("Abnormal expression:", subexpr_pyomo_repr) #}
    print()

class ModelWrapper:
    def __init__(self):
        self.model = ConcreteModel()
        self.clock = {}
        self.assumptions: List[Callable] = []
        # TODO: put assumptions into here after any operation using BigM notation (like multiplication)
    def check_assumptions(self):
        # TODO: call this function after model solved.
        for assumption in self.assumptions:
            assumption()
        self.assumptions = [] # clear assumptions
    def __del__(self):
        del self.model
        del self.clock
        del self
    def getSpecialName(self, key:str):
        val = self.clock.get(key,0)
        name = f"{key}_{val}"
        self.clock[key] = val+1
        return name
    {% for k in ['Constraint', 'Var','Objective']%}
    {% set mv = "*args, **kwargs"%}
    def {{k}}(self, {{ "name:str," if k == "Var" else ""}} {{ mv}}):
        {% if k !="Var" %}
        expr = kwargs.pop('expr',args[0] if len(args) >0 else None)
        if expr is None:
            print("ARGS:", args)
            print("KWARGS:", kwargs)
            raise Exception("Not passing expression to method '{{k}}'")
        deg = getattr(expr, "polynomial_degree", 0)
        if deg:
            deg = expr.polynomial_degree()
        {# deg = expr.polynomial_degree() #}
        if deg != 1:
            print("EXPR DEG:", deg)
            expr_repr =f"{str(expr) if len(str(expr))<200 else str(expr)[:200]+'...'}"
            print('EXPR:',  expr_repr)
            # only if deg > 0 we need further inspection.
            if deg >0:
                # TODO: use regex to simplify expression here.
                {# print("_____________ERROR LOG_____________") #}
                examineSubExprDegree(expr)
                {# print("_____________ERROR LOG_____________") #}
            error_msg = f"[{{k}}] Unacceptable polynomial degree for expression."
            raise Exception(error_msg)
        name = self.getSpecialName("{{k[:3].upper()}}")
        {% endif %}
        {% set init_argname = "initialize"%}
            {% if k == 'Var'%}
        _{{init_argname}} = kwargs.get({{qstr(init_argname)}}, 0)
        {# _{{init_argname}} = kwargs.get({{qstr(init_argname)}}, None) #}
            {% endif %}
        if {{qstr(init_argname)}} in kwargs.keys(): del kwargs[{{qstr(init_argname)}}]
        ret = {{k}}({{mv+", {}=_{}".format(init_argname, init_argname) if k == "Var" else "expr = expr, *args[1:], **kwargs"}})
{{double_check_setattr("self.model", "name", 'ret') | indent(2*4, True)}}
        {# self.model.__setattr__(name, ret) #}
        return ret
    {% endfor%}


# first convert the unit.
# assign variables.

# shall you assign port with variables.

# 风、光照

# 需要明确单位
class 计算参数(BaseModel):
    典型日ID: Union[{{non_neg_int}}, None] = None # increse by external loop
    计算步长: Literal["小时", '秒']
    典型日: bool

    分时计价开始时间点: float = Field(default=0, title = '秒级仿真时 开始时间在一天中的哪个小时', description="取值范围: 0-24", ge=0, le=24)

    {# @validator('分时计价开始时间点')
    def validate_starting_time(cls, v):
        assert v>=0, f"开始时间点大于等于0\n实际: {v}"
        assert v<=24, f"开始时间点小于等于24\n实际: {v}"
        return v #}

    分时计价开始月份: int = Field(default=0, title = '秒级仿真时 开始时间在一年中的哪个月份', description="取值范围: 0-11", le=11, ge=0)

    {# @validator('分时计价开始月份')
    def validate_starting_month(cls, v):
        assert v>=0, f"开始月份大于等于0\n实际: {v}"
        assert v<=11, f"开始月份小于等于11\n实际: {v}"
        return v
     #}
    {# 典型日权重: int = 0 #}
    典型日代表的日期: conlist(conint(ge=0, lt=365), min_items=0, max_items=365, unique_items=True)= []
    @validator('典型日代表的日期')
    def validate_typical_day(cls, v, values):
        if values['典型日']:
            assert len(v) >0
            assert len(v) <=365
        return v
    计算类型: Literal['仿真模拟', '设计规划']
    计算目标: Literal['经济','环保','经济_环保']
    风速: List[{{non_neg_float}}]
    """
    单位: m/s
    """
    光照: List[{{non_neg_float}}]
    """
    单位: kW/m2
    """
    气温: List[{{non_neg_float}}]
    """
    单位: 摄氏度
    """
    年利率: float
    """
    单位: percent
    """
    @property
    def 迭代步数(self):
        {# steps = None #}
        if self.计算步长 == "秒":
            steps = 7200
        elif self.计算步长 == "小时" and self.典型日 is False:
            steps = 8760
        elif self.计算步长 == "小时" and self.典型日 is True:
            steps = 24
        else:
            rich.print(self)
            raise Exception("未知计算参数")
        errors = []

        {% for t in ['风速','光照','气温']%}
        if not len(self.{{t}}) == steps:
            errors.append(f'{{t}}长度应该是{steps} 实际:{len(self.{{t}})}')
        {% endfor%}

        if errors:
            raise Exception("\n".join(errors))
        return steps
    
    {# @lru_cache(maxsize=1) #}
    @property
    def 时间参数(self):
        """
        如果计算步长为秒，那么返回3600
        如果计算步长为小时，那么返回1

        相当于返回一小时内有多少计算步长
        """
        return (1 if self.计算步长 == "小时" else 3600)
    {# @property # 提前计算好了
    def 典型日列表(self): # 
        ... #}
    {# # like: (tday_index, tday_data, tday_count) #}

class POSNEG:
        {% set POSNEGParamNames = ["x", "x_pos", "x_neg", "b_pos", "b_neg", "x_abs"] %}
    def __init__(self, {{",".join(POSNEGParamNames)}}):
        {%for f in POSNEGParamNames%}
        self.{{f}} = {{f}}
        {%endfor%}

{# from functools import reduce #}
{# import functools #}
{% set financial_param_names = [
            "总采购成本",
            "总建设费用",
            "总固定维护成本",
            "总固定成本年化",
            "总成本年化",
            "总可变维护成本年化"
        ]
%}
{{import_type_fallback("Protocol")}}

class 可购买类(Protocol):
    是否购买: ...
    {% for e0 in financial_param_names%}
    {{e0}}: ...
    {% endfor%}
    def BinVarMultiplySingle(self, *args, **kwargs): ...

class 设备模型:
    def __init__(self, PD: dict, mw: ModelWrapper, 计算参数实例: 计算参数, ID: int):
        print("Building Device Model:", self.__class__.__name__)
        self.mw = mw
        self.PD = PD
        self.计算参数 = 计算参数实例
        self.ID = ID
        self.SID = 0
        {# self.BigM = 1e+8  #}
        self.BigM = 1e+7 # 这个数不能太大 否则就会报错
        {# self.BigM = 1e+12 #}
        """
        一个极大数
        """
        self.EPS = 1e-4
        {# usually you want to use it in initialization, not constraints! #}
        """
        一个极小数
        """
        {% for e0 in financial_param_names %}
        self.{{e0}} = 0
        {% endfor %}
        self.年化率 = 1
    
    @staticmethod
    def 处理最终财务输出(mclass: 可购买类):
        {% for e0 in financial_param_names%}
        mclass.{{e0}} = mclass.BinVarMultiplySingle(mclass.是否购买, mclass.{{e0}})
        {% endfor%}
    
    def constraints_register(self):
        if self.__class__.__name__ == "设备模型":
            raise NotImplementedError("Must be implemented by subclasses.")
        print("REGISTERING: ", self.__class__.__name__)

    def getVarName(self, varName: str):
        VN = f"DI_{self.ID}_VN_{varName}" # use underscore.
        if self.计算参数.典型日ID:
            VN = f"TD_{self.计算参数.典型日ID}_"+VN
        return VN
    
    def getSpecialVarName(self, varName:str):
        specialVarName = f"SP_{self.SID}_{varName}"
        self.SID +=1
        return specialVarName

    def 单变量(self, varName: str, **kwargs):
        var = self.mw.Var(self.getVarName(varName) ,**kwargs)
        return var
    
    def getRange(self, mrange:range = None):
        if mrange is None: mrange = range(self.计算参数.迭代步数)
        return mrange

    def 变量列表(self, varName: str, mrange:range = None, **kwargs):
        var = self.mw.Var(self.getVarName(varName) ,self.getRange(mrange), **kwargs)
        return var

    def RangeConstraint(self, var_1, var_2,  expression=... ,mrange:range = None):
        assert expression !=...
        for i in self.getRange(mrange):
            self.mw.Constraint(expression(var_1[i], var_2[i]))

    def RangeConstraintMulti(self, *vars, expression=..., mrange:range=None): # keyword argument now.
        assert expression is not ...
        for i in self.getRange(mrange):
            self.mw.Constraint(expression(*[var[i] for var in vars]))

    def CustomRangeConstraint(self, var_1, var_2,  customRange:range=..., expression= ...):
        assert customRange is not ...
        for i in customRange:
            self.mw.Constraint(expression(var_1, var_2, i))
    
    def CustomRangeConstraintMulti(self, *vars, customRange:range=..., expression=...):
        assert expression is not ...
        assert customRange is not ...
        for i in customRange:
            self.mw.Constraint(expression(*vars, i))
    
    def SumRange(self,var_1,  mrange:range=None):
        return {{- sum_reduce('[var_1[i] for i in self.getRange(mrange)]')}}
    
    def 单变量转列表(self, var,  dup:int=None):
        if dup is None:
            dup = self.计算参数.迭代步数
        return [var for _ in range(dup)]
    
    def 单表达式生成指示变量(self, varName: str, expr):
        # where to exclude type from type hints?
        # or what language can express type exclusion?
        posneg = self.变量列表_带指示变量(varName, exprList=[expr], mrange = range(1))
        ret = POSNEG(posneg.x[0], posneg.x_pos[0], posneg.x_neg[0], posneg.b_pos[0], posneg.b_neg[0], posneg.x_abs[0])
        return ret
    
    def 变量列表_带指示变量(self, varName:str,  exprList:list=None, within= Reals, mrange:range=None) -> POSNEG:
        if exprList:
            x = exprList
        else:
            x = self.变量列表(varName,within=within, mrange = mrange)

        {% for flag in ['pos', 'neg'] %}
        b_{{flag}} = self.变量列表(self.getSpecialVarName(varName), within = Boolean, mrange = mrange)
        x_{{flag}} = self.变量列表(self.getSpecialVarName(varName), within = NonNegativeReals, mrange = mrange)

        self.RangeConstraint(b_{{flag}}, x_{{flag}}, lambda x,y: x*self.BigM >= y, mrange = mrange)
        {% endfor %}

        self.RangeConstraint(b_pos, b_neg, lambda x,y: x+y == 1, mrange = mrange)

        self.RangeConstraintMulti(x, x_pos, x_neg, expression = lambda x,y,z: x == y-z , mrange = mrange)

        x_abs = self.变量列表(self.getSpecialVarName(varName), within = NonNegativeReals, mrange = mrange)

        self.RangeConstraintMulti(x_pos, x_neg, x_abs, expression = lambda x,y,z : z == x+y, mrange = mrange)

        posneg = POSNEG(x, x_pos, x_neg, b_pos, b_neg, x_abs)

        return posneg
    
    def Piecewise(self, 
        x_var, # x_var
        y_var, # y_var
        x_vals: List[float],
        y_vals: List[float],
         {#  #}
     range_list:Union[List[int], None]=None, 
     pw_repn='MC', 
     {# pw_repn='SOS2',  #}
     pw_constr_type='EQ', unbounded_domain_var=True):

        # TODO: if performance overhead is significant, shall use "MC" piecewise functions, or stepwise functions.

        # BUG: x out of bound, resulting into unsolvable problem.
        assert x_vals[0] <= x_vals[-1]
        expand_val = 1e+3
        _x_vals = [x_vals[0]-expand_val] + x_vals +[ x_vals[-1]+expand_val]
        _y_vals = [y_vals[0]] + y_vals +[ y_vals[-1]]

        if range_list is None:
            range_list = list(range(self.计算参数.迭代步数))
        PWL = []
        for i in range_list:
            piecewise_name = self.getSpecialVarName("PW")
            PW = Piecewise(
            y_var[i],
            x_var[i],
            pw_pts=_x_vals,
            f_rule=_y_vals,
            pw_repn=pw_repn,
            pw_constr_type=pw_constr_type,
            unbounded_domain_var=unbounded_domain_var,
            warn_domain_coverage=False, # to suppress warning
        )
{{double_check_setattr("self.mw.model", "piecewise_name", "PW") | indent(3*4, True)}}
            {# assert getattr(self.mw.model,piecewise_name, None) is None, f"错误: 不能设置两次相同的变量名称\n重复变量: {piecewise_name}"
            self.mw.model.__setattr__(piecewise_name, PW)
            PWL.append(PW) #}
        return PWL

    @staticmethod
    def breakdownExpression(expr):
        expr_type = type(expr)

        assert expr_type != {{IndexedVar}}, f"Expression: {repr(expr)[:200]}\nInvalid expression type."

        {# numeric_types = [float, int]
        variable_types = [ScalarVar, {{GeneralVarData}}] #}
        # otherwise, expression types.
        {# results = [] #}
        is_linear, results = pyomo.core.expr.current.decompose_term(expr)
        if is_linear:
            return results
        else:
            examineSubExprDegree(expr)
            raise Exception(f"Nonlinear expression found while breaking down.\nExpression type: {type(expr)}")
        {# if expr_type in numeric_types:
            results.append((expr))
        else:
            # implement expression breakdown. usually pyomo expressions.
            try:
                results.append(...)
            except:
                ... #}
    
    def BinVarMultiplySingle(self, b_var, x_var,  recurse=True):
    {# def BinVarMultiplySingle(self, b_var, x_var, recurse=False): #}
        assert b_var.is_binary()
        assert type(x_var) is not {{IndexedVar}}
        {# assert x_var.is_continuous()  #}
        {# x_var can be binary. #}

        {# to eliminate the issue of overflow: #}
        {# approach 1: first divide variable by some number, then multiply by that. (not working) #}
        {# approach 2: if the variable/expression is summation, execute the function elementwise then sum them up. #}
        {# if using APP2, shall do recursion. #}
        {# and mind all occurance of BigMs #}
        numeric_types = [float, int]
        if recurse:
            # tear down x_var
            h_list = []
            for sub_x_var in self.breakdownExpression(x_var):
                _h = self.BinVarMultiplySingle(b_var,sub_x_var, recurse=False)
                h_list.append(_h)
            return sum(h_list)
        else:

            if type(x_var) == tuple:
                assert len(x_var) == 2, f"Invalid `x_var`: {x_var}"
                # format: (factor, x_var)
                assert type(x_var[0]) in [float, int], f"Invalid `x_var` format: {x_var}\nShould be: (factor (float), x_var (Var))"
                factor, _x_var = x_var
                if _x_var is None: # constant.
                    return factor * b_var
            else:
                factor = 1
                _x_var = x_var
                if type(_x_var) in numeric_types:
                    return _x_var * b_var

            h = self.单变量(self.getSpecialVarName("BVM"), within=Reals)

            {# divider = 1e+2 #}

            self.mw.Constraint(h<= b_var* self.BigM)
            self.mw.Constraint(h>= -b_var*self.BigM)
            {# self.mw.Constraint(h <= x_var/divider+(1-b_var)*self.BigM)
            self.mw.Constraint(h >= x_var/divider-(1-b_var)*self.BigM) #}
            self.mw.Constraint(h <= _x_var+(1-b_var)*self.BigM)
            self.mw.Constraint(h >= _x_var-(1-b_var)*self.BigM)
            return h * factor
        {# return h*divider #}

    def Multiply(self,dict_mx:dict, dict_my:dict, varName:str,  precision = 10, within = Reals): # two continuous multiplication
        #  (x+y)^2 - (x-y)^2 = 4xy
        mx, max_mx, min_mx = dict_mx['var'], dict_mx['max'], dict_mx['min']
        my, max_my, min_my = dict_my['var'], dict_my['max'], dict_my['min']
        assert not mx[0].is_binary()
        assert not my[0].is_binary()

        m1posneg = self.变量列表_带指示变量(self.getSpecialVarName(varName))
        self.RangeConstraintMulti(m1posneg.x, mx, my , expression = lambda x,y,z: x == y+z)
        mx_my_sum_var = m1posneg.x_abs
        mx_my_sum_pow2_var = self.变量列表(self.getSpecialVarName(varName))

        m2posneg = self.变量列表_带指示变量(self.getSpecialVarName(varName))
        self.RangeConstraintMulti(m2posneg.x, mx, my, expression = lambda x,y,z: x == y-z)
        mx_my_minus_var = m2posneg.x_abs
        mx_my_minus_pow2_var = self.变量列表(self.getSpecialVarName(varName))

        l0, r0 = min_mx + min_my, max_mx+max_my
        l1, r1 = min_mx - max_my, max_mx-min_my
        def getBound(l0, r0):
            if l0*r0 >=0:
                l0,r0 = abs(l0), abs(r0)
                l, r = min([l0, r0]), max([l0, r0])
            else:
                l0, r0 = abs(l0), abs(r0)
                l, r = 0, max([l0, r0])
            return l, r

        mx_my_sum = np.linspace(*getBound(l0, r0), precision).tolist()

        mx_my_sum_pow2 = [x**2 for x in mx_my_sum]

        mx_my_minus = np.linspace(*getBound(l1, r1), precision).tolist()

        mx_my_minus_pow2 = [x**2 for x in mx_my_minus]

        self.Piecewise(x_var = mx_my_sum_var, y_var = mx_my_sum_pow2_var, x_vals = mx_my_sum, y_vals = mx_my_sum_pow2) # assume it is absolute.

        self.Piecewise(x_var = mx_my_minus_var, y_var = mx_my_minus_pow2_var, x_vals = mx_my_minus, y_vals = mx_my_minus_pow2)

        mx_my_multiply = self.变量列表(varName, within=within)

        self.RangeConstraintMulti(mx_my_sum_pow2_var, mx_my_minus_pow2_var, mx_my_multiply, expression =  lambda x,y,z:(x-y)/4 == z)

        return mx_my_multiply

# input: negative
# output: positive
# IO: Real
import numpy as np
import math

{% for super_class, class_name, mstrs, mdigits, mtables in 设备库 %}
{% set SO.class_name = class_name %}

class {{class_name}}模型(设备模型):
{{ init_super_class(class_name)}}

        {% set mflag = namespace(val="")%}
        {% if class_name in ['柴油发电']%}
        self.燃料热值:float = 0 # 需要拓扑解析之后进行赋值
        {% endif%}
        {% for psc, mdigit in mdigits %}
        {% if psc in ["仿真模拟", "设计规划"] %}
        {# # psc: {{psc}} mflag: {{mflag}} #}
        {% if mflag.val != psc %}
        {% set mflag.val = psc%}
        {# # after: psc: {{psc}} mflag: {{mflag}} #}
        if self.计算参数.计算类型 == "{{psc}}":
        {% if psc == "设计规划" %}
            # BUG: if unbounded, then we get some error.
            {% if class_name not in ['传输线']%}
                {# {% if class_name not in ['锂电池','光伏发电']%}
                    {% set mbounds = "bounds = (self.设备信息.MinDeviceCount, self.设备信息.MaxDeviceCount)"%}
                {% endif%} #}
            self.DeviceCount = self.单变量('DeviceCount', within=NonNegativeIntegers) # type: ignore
            {# self.DeviceCount = self.单变量('DeviceCount', within=NonNegativeIntegers, {{mbounds}}) # type: ignore #}
            """
            单位： 个
            """
            {% endif%}
        {% elif psc == "仿真模拟"%}
            {% if class_name == '锂电池'%}
            self.DeviceCount = round(self.设备信息.TotalCapacity / self.设备信息.RatedCapacity) # for better user experience.
            {# self.DeviceCount = math.floor(self.设备信息.TotalCapacity / self.设备信息.RatedCapacity) #}
            {% endif %}
        {% endif %}
        {%endif%}
{{expand_unit_conversion(mdigit) | indent(4, True)}}
        {# {{expand_unit_conversion(mdigit) | indent(4, True)}} #}
        {% else %}
{{expand_unit_conversion(mdigit,设备参数例外列表) }}
        {% endif %}
        {% endfor %}
        {# {%endwith%} #}

        {% for psc, main, sub in mtables %}
        {% set mtable=(main, sub)%}
        self.{{ mtable[0][0]}}_{{ mtable[1][0]}} : List[List[float]] = [[v1 * {{mtable[0][4]}}, v2 * {{mtable[1][4]}}] for v1, v2 in 设备信息.{{ mtable[0][0]}}_{{ mtable[1][0]}}]
        """
        {{ mtable[0][0]}}: {{ mtable[0][1]}}
        单位: {{ mtable[0][3]}} <- {{ mtable[0][2]}}

        {{ mtable[1][0]}}: {{ mtable[1][1]}}
        单位: {{ mtable[1][3]}} <- {{ mtable[1][2]}}
        """
        self.{{ mtable[0][0]}}_{{ mtable[1][0]}}.sort(key=lambda x: x[1])


        {% endfor %}

{{ port_variable_define(class_name)}}
        
        # 设备特有约束（变量）
        {% if class_name in ['光伏发电','风力发电','柴油发电']%}
        self.电输出 = self.电接口
            {% if class_name in ["柴油发电"]%}
        self.柴油输入 = self.燃料接口
            {% elif class_name in ['风力发电']%}
        self.单台发电功率 = ...
            {% endif%}
        {% endif%}

        {% if class_name in ['变压器']%}
        if self.计算参数.计算类型 == "设计规划": # 在变压器和负荷的交换节点处做处理
            self.最大允许的负载总功率 = self.DeviceCount*(self.RatedPower*self.Efficiency)*self.PowerParameter/self.LoadRedundancyParameter # type: ignore
        {% endif%}
        {% if class_name in ['光伏发电']%}
        if self.计算参数.计算类型 == "设计规划":
            # TODO：标准光照下出力
            self.MaxDeviceCount = math.floor(self.MaxInstallArea/self.Area)
            self.MinDeviceCount = math.ceil(self.MinInstallArea/self.Area)
            assert self.MinDeviceCount>=0
            assert self.MaxDeviceCount>=self.MinDeviceCount
        {% elif class_name == "柴油发电" %}
        self.电功率中转 = self.变量列表_带指示变量("电功率中转")
        
        self.单台发电功率 = self.变量列表("单台发电功率", within=NonNegativeReals)
        self.单台柴油输入 = self.变量列表("单台柴油输入", within=NonPositiveReals)

        if self.计算参数.计算类型 == "设计规划":
            self.最大油耗率 = max([x[0] for x in self.DieselToPower_Load])

            self.原电输出 = self.Multiply(dict(var=self.单台发电功率,max=self.RatedPower, min=0), dict(var=self.单变量转列表(self.DeviceCount),max=self.MaxDeviceCount, min=self.MinDeviceCount), "原电输出", within = NonNegativeReals)

            self.柴油输入_ = self.Multiply(dict(var=self.单台柴油输入, max=0, min=-self.RatedPower*self.最大油耗率), dict(var=self.单变量转列表(self.DeviceCount),max=self.MaxDeviceCount, min=self.MinDeviceCount), "柴油输入_", within = NonPositiveReals)
            self.RangeConstraint(self.柴油输入_, self.柴油输入, lambda x,y: x == y)
        else:
            self.原电输出 = self.变量列表("原电输出",within = NonNegativeReals)
            self.RangeConstraint(self.原电输出, self.单台发电功率, lambda x,y: x == y*self.DeviceCount)
            # change #1: add line to define "self.柴油输入"
            self.RangeConstraint(
            # self.RangeConstraintMulti(
                self.柴油输入,
                self.单台柴油输入,
                # self.单变量转列表(self.DeviceCount),
                # expression=lambda x, y, z: x == y * z,
                expression=lambda x, y: x == y * self.DeviceCount,
            )
        {% elif class_name  == '锂电池' %}

        self.needStorageDecayCompensation:bool = self.设备信息.needStorageDecayCompensation

        """
        开启后存储衰减补偿将可变，反之存储衰减补偿等于存储衰减
        """

        assert self.InitSOC >= self.MinSOC
        assert self.InitSOC <= self.MaxSOC
        {# self.InitActualCapacityPerUnit = (self.InitSOC - self.MinSOC) * self.RatedCapacity #}
        self.InitCapacityPerUnit = self.InitSOC * self.RatedCapacity

        if self.计算参数.计算类型 == "设计规划":
            #  初始SOC
            self.MaxDeviceCount = math.floor(self.MaxTotalCapacity / self.RatedCapacity)
            self.MinDeviceCount = math.ceil(self.MinTotalCapacity / self.RatedCapacity)

            self.TotalCapacity = self.DeviceCount * self.RatedCapacity # type: ignore

        assert self.MaxSOC >= self.MinSOC
        assert self.MaxSOC < 1
        {# assert self.MaxSOC <= 1 #}
        {# assert self.MinSOC >= 0 #}
        assert self.MinSOC > 0 # to ensure that battery will not be drained.

        self.原电接口 = self.变量列表_带指示变量("原电接口") # 正 放电 负 充电

        {# self.ActualCapacityPerUnit = self.RatedCapacity * (self.MaxSOC - self.MinSOC) #}

        self.CurrentTotalCapacity = self.变量列表('CurrentTotalCapacity', within=NonNegativeReals)

        # reserved expression list. do not use it in any constraints.
        self.SOC = [self.CurrentTotalCapacity[i]/self.TotalCapacity for i in self.CurrentTotalCapacity]

        if self.计算参数.计算类型 == '设计规划':
            self.CurrentTotalCapacity.setlb(self.MinDeviceCount*self.MinSOC*self.RatedCapacity)
            self.CurrentTotalCapacity.setub(self.MaxDeviceCount*self.MaxSOC*self.RatedCapacity)
            
            self.RangeConstraintMulti(self.CurrentTotalCapacity, expression = lambda x: x >= self.TotalCapacity * self.MinSOC)
            self.RangeConstraintMulti(self.CurrentTotalCapacity, expression = lambda x: x <= self.TotalCapacity * self.MaxSOC)
        else:
            self.CurrentTotalCapacity.setlb(self.DeviceCount*self.MinSOC*self.RatedCapacity)
            self.CurrentTotalCapacity.setub(self.DeviceCount*self.MaxSOC*self.RatedCapacity)

        {# self.CurrentTotalActualCapacity = self.变量列表('CurrentTotalActualCapacity', within=NonNegativeReals) #}

        {# self.TotalActualCapacity = self.DeviceCount * self.ActualCapacityPerUnit # type: ignore #}

        self.MaxTotalCapacityDeltaPerStep = self.BatteryDeltaLimit * self.TotalCapacity / ({{时间步长参数}})
        """
        单位: kWh
        """

        self.TotalStoragePowerOfDecay = (self.BatteryStorageDecay / 100) * self.TotalCapacity
        """
        单位: kW
        """

            {# {% if needStorageDecayCompensation%} #}
        if self.needStorageDecayCompensation: 
            # TODO: Verify if "compensated decay rate" works.
            if self.计算参数.计算类型 == "设计规划":

                self.CurrentTotalPowerOfDecayCompensated = self.变量列表('总补偿衰减率', bounds = (0,(self.BatteryStorageDecay/100)*self.MaxTotalCapacity), within=NonNegativeReals) # the greater the value, the less our compensation is, the greater the real discharge by decay is (will not emit to external ports).
                # constraint.
                self.RangeConstraintMulti(self.CurrentTotalPowerOfDecayCompensated, expression=lambda x: x<=self.TotalStoragePowerOfDecay)
            else:
                self.CurrentTotalPowerOfDecayCompensated = self.变量列表('总补偿衰减率', bounds = (0,self.TotalStoragePowerOfDecay), within=NonNegativeReals)
            {# {% endif%} #}

        {%elif class_name in ['双向变流器']%}
        self.线路端_ = self.变量列表_带指示变量("线路端_") 
        self.储能端_ = self.变量列表_带指示变量("储能端_")
        {% elif class_name in ['传输线']%}
        self.电输入_去除损耗 = self.变量列表_带指示变量('电输入_去除损耗') 
        {%endif%}

        {% if class_name not in ["传输线"]%}
        self.POSNEG_是否购买 = self.单表达式生成指示变量('POSNEG_是否购买', self.DeviceCount - 0.5)
        self.是否购买 = self.POSNEG_是否购买.b_pos

        if isinstance(self.DeviceCount, Var): # 设备台数约束
            self.DeviceCount.setlb(self.MinDeviceCount)
            self.DeviceCount.setub(self.MaxDeviceCount)
        {% endif%}

    def constraints_register(self):
        super().constraints_register()
        # 设备特有约束（非变量）
        {# 检验解析时参数是否填写完全 #}
        {% if class_name in ['柴油发电']%}
        assert self.燃料热值!=0
        assert type(self.燃料热值) in [int,float]
        {% endif%}
        {% if class_name == "风力发电" %}
        # define a single-variate piecewise function
        # 
        #         ____
        #        /    |
        #       /     | ax^3
        #  ----/      |______
        #
        assert self.RatedWindSpeed >=self.MinWindSpeed
        assert self.MaxWindSpeed >=self.RatedWindSpeed

        发电曲线参数 = self.RatedPower / ( (self.RatedWindSpeed - self.MinWindSpeed) ** 3)

        # windspeed (m/s) -> current power per device (kW)
        WS = np.array(self.计算参数.风速, dtype=np.float64) # BUG: before that it was "np.int64", which introduce errors.
        self.单台发电功率 = 单台发电功率 = np.piecewise(WS, [WS<=self.MinWindSpeed, np.logical_and(WS >self.MinWindSpeed,WS <= self.RatedWindSpeed) , np.logical_and(WS >self.RatedWindSpeed, WS <=self.MaxWindSpeed) , WS > self.MaxWindSpeed], [0,
        lambda x: 发电曲线参数 * ((x - self.MinWindSpeed) ** 3), 
        {# lambda x: ((发电曲线参数 * (x - self.MinWindSpeed)) ** 3),  #}
        self.RatedPower, 0])
        单台发电功率 = 单台发电功率.tolist()
        {% endif %}

        {# 
        # 设备台数约束
        {% if class_name not in ['传输线'] %}
        if self.计算参数.计算类型 == "规划设计":
            self.mw.Constraint(self.DeviceCount <= self.MaxDeviceCount)
            self.mw.Constraint(self.DeviceCount >= self.MinDeviceCount)
        {% endif %}
        #}
        
        # 输出输入功率约束

        {%if class_name in ['传输线']%}
        TotalDecayPerStep = self.Length * self.PowerTransferDecay / {{时间步长参数}}
        self.RangeConstraint(self.电输入_去除损耗.x, self.电输入, lambda x,y: x == y+TotalDecayPerStep )
        self.RangeConstraint(self.电输入_去除损耗.x_neg, self.电输出,lambda x,y:x == y )
        {%elif class_name in ['双向变流器']%}

        self.RangeConstraint(self.线路端_.x , self.线路端, lambda x,y: x==y)
        self.RangeConstraint(self.储能端_.x , self.储能端, lambda x,y: x==y)

        # wrong! negative is input.
        {# self.RangeConstraint(self.线路端_.x_neg, self.储能端_.x_pos,lambda x,y: x == y*self.Efficiency)
        self.RangeConstraint(self.储能端_.x_neg, self.线路端_.x_pos,lambda x,y: x == y*self.Efficiency) #}

        self.RangeConstraint(self.线路端_.x_neg, self.储能端_.x_pos,lambda x,y: y == x *self.Efficiency)
        self.RangeConstraint(self.储能端_.x_neg, self.线路端_.x_pos,lambda x,y: y == x *self.Efficiency)

        {% elif class_name in 单向变电器列表 %}
        # TODO: figure out what "PowerParameter" does
        # TODO: fix efficiency issue
        self.RangeConstraint(self.电输入, self.电输出, lambda x,y: x * self.Efficiency {{"* self.PowerParameter" if class_name in ['变压器'] else ""}} == -y)
        self.RangeConstraintMulti(self.电输入, expression=lambda x: -x<=self.RatedPower * self.DeviceCount )
        {% elif class_name in ['光伏发电'] %}
        光电转换效率 = self.MaxPower / self.Area # 1kW/m2光照下能产生的能量 省略除以1 单位: one
        assert 光电转换效率<=1, f"光电转换效率数值不正常: {光电转换效率} (应当在0-1之间)\n光电转换效率 = 单块最大功率 / 单块面积"
        总最大功率 = self.MaxPower * self.DeviceCount
        总面积 = self.Area * self.DeviceCount

        # 光照强度 * 总面积 * 光电转换效率 * 电电转换效率
        # (kW/m2) * m2 * one * one -> kW
        self.RangeConstraint(self.计算参数.光照, self.电输出, lambda x,y: x*总面积*光电转换效率*self.PowerConversionEfficiency >= y)

        # BUG: 限制最大功率输出（标准光照下）
        self.RangeConstraintMulti(self.电输出, expression = lambda x: x<= self.MaxPower*self.DeviceCount*self.PowerConversionEfficiency)

        {% elif class_name in ['风力发电'] %}
        self.RangeConstraint(单台发电功率, self.电输出, lambda x,y: x*self.DeviceCount >= y)

        {% elif class_name in ['柴油发电'] %}
        总最小启动功率 = self.RatedPower * self.PowerStartupLimit * self.DeviceCount
        {# 总最大输出功率 = self.RatedPower * self.DeviceCount #}

        self.RangeConstraintMulti(self.单台发电功率, expression = lambda x: x <= self.RatedPower)
        self.RangeConstraint(self.原电输出, self.电功率中转.x ,lambda x,y: x == y + 总最小启动功率)

        self.Piecewise(y_var = self.单台柴油输入, x_var = self.单台发电功率, y_vals = [-x[0]*self.RatedPower*x[1] for x in self.DieselToPower_Load], x_vals = [self.RatedPower*x[1] for x in self.DieselToPower_Load])
        # 柴油输入率: L/h

        self.RangeConstraintMulti(self.电功率中转.x_pos, self.电输出, self.电功率中转.b_pos, expression = lambda x,y,z: x + self.BinVarMultiplySingle(z,总最小启动功率) == y)

        {%elif class_name in ['锂电池'] %}
        {# self.RangeConstraintMulti(self.CurrentTotalActualCapacity, expression = lambda x: x <= self.TotalActualCapacity) #}

        self.mw.Constraint(self.CurrentTotalCapacity[0] == self.InitCapacityPerUnit * self.DeviceCount)
        {# self.mw.Constraint(self.CurrentTotalActualCapacity[0] == self.InitActualCapacityPerUnit * self.DeviceCount) #}


            {# {% if needStorageDecayCompensation%} #}
        if self.needStorageDecayCompensation:
            self.CustomRangeConstraintMulti(
                self.原电接口.x,
                self.CurrentTotalCapacity,
                self.CurrentTotalPowerOfDecayCompensated,
                customRange = range(self.计算参数.迭代步数 - 1),
                expression = 
                lambda x, y, z, i: x[i] - z[i] == (y[i] - y[i + 1]) * self.计算参数.时间参数,
            )
            self.RangeConstraintMulti(
                self.原电接口.x_pos,
                self.原电接口.x_neg,
                self.电接口,
                self.CurrentTotalPowerOfDecayCompensated, 
                expression=lambda x_pos, x_neg, y, z: x_pos * self.DischargeEfficiency
                - (x_neg + (self.TotalStoragePowerOfDecay - z)) / self.ChargeEfficiency
                == y,
            )
            {# {% else%} #}
        else:
            self.CustomRangeConstraint( self.原电接口.x, self.CurrentTotalCapacity, customRange = range(self.计算参数.迭代步数-1),expression =  lambda x,y,i: x[i] == (y[i] - y[i+1]) * {{时间步长参数}})
            self.RangeConstraintMulti(self.原电接口.x_pos, self.原电接口.x_neg, self.电接口,expression = lambda x_pos, x_neg, y: x_pos * self.DischargeEfficiency - (x_neg + self.TotalStoragePowerOfDecay)/self.ChargeEfficiency == y) 
            {# {% endif%} #}
        {# power = delta(capacity)/delta(time)#}
            {# {% if needStorageDecayCompensation%} #}
            {# {%else%} #}
            {# {% endif%} #}
        for i in range(self.计算参数.迭代步数-1):
            self.mw.Constraint(self.CurrentTotalCapacity[i+1] - self.CurrentTotalCapacity[i] <=self.MaxTotalCapacityDeltaPerStep)
            self.mw.Constraint(self.CurrentTotalCapacity[i+1] - self.CurrentTotalCapacity[i] >=-self.MaxTotalCapacityDeltaPerStep)

        if self.计算参数.计算类型 == "设计规划":
            if self.设备信息.循环边界条件 == '日间独立':
                {# self.mw.Constraint(self.原电接口.x[0] == self.EPS) #}
                {# BUG: override suspicious constraints with init values. #}
                self.原电接口.x[0].set_value(self.EPS)
            elif self.设备信息.循环边界条件 == '日间连接':
                self.mw.Constraint(self.CurrentTotalCapacity[0] - self.CurrentTotalCapacity[self.计算参数.迭代步数-1] <=self.MaxTotalCapacityDeltaPerStep)

                self.mw.Constraint(self.CurrentTotalCapacity[0] - self.CurrentTotalCapacity[self.计算参数.迭代步数-1] >=-self.MaxTotalCapacityDeltaPerStep)
                if self.needStorageDecayCompensation:
            {# {% if needStorageDecayCompensation%} #}
                    self.mw.Constraint(
                        self.原电接口.x[0] - self.CurrentTotalPowerOfDecayCompensated[0]
                        == (
                            self.CurrentTotalCapacity[self.计算参数.迭代步数 - 1]
                            - self.CurrentTotalCapacity[0]
                        )
                        * self.计算参数.时间参数
                    )
            {# {%else%} #}
                else:
                    self.mw.Constraint(self.原电接口.x[0] == (self.CurrentTotalCapacity[self.计算参数.迭代步数-1] - self.CurrentTotalCapacity[0]) * {{时间步长参数}} )
            {# {% endif%} #}
            else:
                raise Exception("未知循环边界条件:", self.设备信息.循环边界条件)
        elif self.计算参数.计算类型 == "仿真模拟":
            {# self.mw.Constraint(self.原电接口.x[0] == self.EPS) #}
            self.原电接口.x[0].set_value(self.EPS)

        {% endif %}

        {# 秒级功率变化限制，有特定的变量限制 #}
        {% if class_name in ['光伏发电', '风力发电', '柴油发电'] %}
        if self.计算参数.计算步长 == "秒":
            总最大功率 = {{'self.MaxPower' if class_name in ['光伏发电'] else 'self.RatedPower'}} * self.DeviceCount
            最大功率变化 = 总最大功率 *self.PowerDeltaLimit / 100
            self.CustomRangeConstraintMulti(self.{{'原电输出' if class_name in ['柴油发电'] else '电输出'}} , customRange = range(self.计算参数.迭代步数-1),expression = lambda x,i: x[i+1] - x[i] <= 最大功率变化)
            self.CustomRangeConstraintMulti(self.{{'原电输出' if class_name in ['柴油发电'] else '电输出'}} , customRange =  range(self.计算参数.迭代步数-1),expression = lambda x,i: x[i+1] - x[i] >= -最大功率变化)
        {% endif %}
        {# elif self.计算参数.计算步长 == "小时":
            ... # skip it.
        else:
            raise Exception("未知计算步长:", self.计算参数.计算步长) #}
        
        # 计算年化
        # unit: one
        {# if 计算参数.计算类型 == "规划设计": #}
        {# 规划设计和仿真模拟都需要计算年化 #}
        {%with%}
        {% if class_name in ['锂电池'] %} 

        # TODO: to get LifetimeDischargeCapacityPerUnit working
        self.LifetimeDischargeCapacityPerUnit = self.LifetimeCycleCount * self.RatedCapacity
        """
        单块电池生命周期总放电量
        单位: kWh
        """

        计算范围内总平均功率 = (self.SumRange(self.原电接口.x_abs)/self.计算参数.迭代步数)+ self.TotalStoragePowerOfDecay # kW
        # avg power

        一小时总电变化量 = 计算范围内总平均功率 # 省略乘1
        # kWh

        一年总电变化量 = 一小时总电变化量 * 8760
        
        self.mw.Constraint(一年总电变化量 * self.BatteryLife <= self.DeviceCount * self.LifetimeDischargeCapacityPerUnit * 0.85)
        assert self.BatteryLife >=1
        assert self.Life >= self.BatteryLife
        Life = self.BatteryLife
        {%else%}
        Life = self.Life
        {%endif%}

        self.年化率 = ((1+(self.计算参数.年利率/100))** Life) / Life
        {% if class_name in ['光伏发电'] %}
            {% set m='总最大功率'%}
            {% set vi = 'Kilowatt' %}
            {% set vm = 'Kilowatt' %}
            {% set vb = 'Kilowatt' %}
            {% set vv = 'Work' %}
        {%elif class_name in ['风力发电']+单向变电器列表+ ['双向变流器']%}
            {% set m='self.DeviceCount * self.RatedPower'%}
            {% set vi = 'Kilowatt' %}
            {% set vm = 'Kilowatt' %}
            {% set vb = 'Kilowatt' %}
            {% set vv = 'Work' %}
        {% elif class_name in ['柴油发电']%}
            {% set m='self.DeviceCount'%}
            {% set vi = 'Machine' %}
            {% set vm = 'Machine' %}
            {% set vb = 'Machine' %}
            {% set vv = 'Work' %}
        {% elif class_name in ["锂电池"]%}
            {% set m='self.DeviceCount * self.RatedCapacity'%}
            {% set vi = 'Capacity' %}
            {% set vm = 'Capacity' %}
            {% set vb = 'Capacity' %}
            {% set vv = 'Work' %}
        {% elif class_name in ['传输线'] %}
            {% set m='self.Length'%}
            {% set vi = 'Kilometer' %}
            {% set vm = 'Kilometer' %}
            {% set vb = 'Kilometer' %}
        {% else%}
            {% error("不支持的设备类型:", class_name) %}
        {% endif %}

        self.总采购成本 = self.CostPer{{vi}} * ({{ m}}) 
        self.总固定维护成本 = self.CostPerYearPer{{vm}} * ({{ m}})
        self.总建设费用 = self.BuildCostPer{{vb}} * ({{ m}}) + self.BuildBaseCost

        self.总固定成本年化 = (self.总采购成本 + self.总建设费用) * self.年化率 + self.总固定维护成本 
        {# self.总固定成本年化 = (self.总采购成本 + self.总固定维护成本 + self.总建设费用) * self.年化率 #}

        {% if class_name in ['光伏发电','风力发电','柴油发电']%}
            {% set m1="self.SumRange(self.电输出)"%}
        {% elif class_name in ['锂电池']%}
            {% set m1="计算范围内总平均功率*self.计算参数.迭代步数"%}
        {% elif class_name in 单向变电器列表+['传输线']%}
            {% set m1='-self.SumRange(self.电输入)'%}
        {% elif class_name in ['双向变流器']%}
            {% set m1='(self.SumRange(self.储能端_.x_neg)+self.SumRange(self.线路端_.x_neg))'%}
        {%elif class_name in ['传输线'] %}
            {% set m1='0'%}
        {% else%}
            {% error("不支持的类型:", class_name) %}
        {% endif %}
        {% if class_name not in ['传输线']%}
        {# 总可变维护成本年化 = ({{m1}}) * (8760 / self.计算参数.迭代步数) * ({{时间步长参数}}) *self.VariationalCostPer{{vv}} #}
        self.总可变维护成本年化 = (({{m1}}) / self.计算参数.迭代步数) * 8760 * self.VariationalCostPer{{vv}} 
        # avg_power * 8760 = annual_work

        self.总成本年化 = self.总固定成本年化 + self.总可变维护成本年化
        {% else%}
        self.总成本年化 = self.总固定成本年化
        {% endif%}
        {% endwith%}

        {% if class_name != "传输线" %}
        {# 忽略传输线 #}
        self.处理最终财务输出(self)
        {% endif%}

        return self.总成本年化
{% endfor %}

{% set load_class_names = [] %}
{% for v in load_types%}
    {% do load_class_names.append(v+"负荷")%}
{% endfor%}
{% set input_class_names = input_types%}
{% set special_classes = {"load_class": load_class_names, "input_class": input_class_names}%}

{# check for coverage #}
{% for class_name in 设备接口集合.keys() %}
    {% if class_name not in NonLoadDeviceDict.keys() %}
        {% if class_name not in input_class_names+load_class_names%}
            {% error("未覆盖的非设备类型:", class_name)%}
        {% endif%}
    {% endif%}
{% endfor%}

{% for k,clist in special_classes.items() %}
    {% for class_name in clist%}
class {{class_name}}模型(设备模型):
{{ init_super_class(class_name)}}

{{ port_variable_define(class_name)}}

    {% if k == "load_class"%}
        {% if not class_name.endswith('负荷')%}
            {% error("错误的负荷类名:", class_name)%}
        {% else%}
            {% set v = class_name.strip("负荷")%}
        {% endif%}
        assert len(self.设备信息.EnergyConsumption) == self.计算参数.迭代步数

        {% if v in ['电'] %}
        MaxEnergyConsumptionDefault = max(self.设备信息.EnergyConsumption)
        if self.设备信息.MaxEnergyConsumption is None:
            self.MaxEnergyConsumption = MaxEnergyConsumptionDefault
        else:
            assert self.设备信息.MaxEnergyConsumption >= MaxEnergyConsumptionDefault
            self.MaxEnergyConsumption = self.设备信息.MaxEnergyConsumption
        {% endif %}

        self.IncomeRates = ...
        self.PriceModel = self.设备信息.PriceModel

    {% elif k == 'input_class' %}

        class _Units(BaseModel):
        {% for attrName, defaultUnit in 燃料能源相关数据默认单位[class_name].items() %}
            {{attrName}}: str
        {% endfor%}

        UnitsDict = {}

        {% for attrName, defaultUnit in 燃料能源相关数据默认单位[class_name].items() %}
        ## PROCESSING: {{attrName}}
        ### UNIT COMPATIBILITY CHECK ###
        default_unit = self.设备信息.DefaultUnits.{{attrName}}
        val_unit = self.设备信息.{{attrName}}[1]

        has_exception, _ = getSingleUnitConverted(default_unit = default_unit, val_unit =val_unit)

        if has_exception:
            raise Exception(f"Unit '{val_unit}' is not compatible with default unit '{default_unit}'")
        ### UNIT COMPATIBILITY CHECK ###

        
        ### UNIT CONVERSION ###
        ConversionRate, StandardUnit = unitFactorCalculator(ureg, standard_units, val_unit)
        ### UNIT CONVERSION ###
        
        self.{{attrName}} = self.设备信息.{{attrName}}[0] * ConversionRate
        """
        单位: 标准单位 <- 现用单位
        """
        UnitsDict.update(dict({{attrName}}= str(StandardUnit)))
        {% endfor%}

        self.Units = _Units.parse_obj(UnitsDict)
    {% else%}
        {% error("Unknown special class:", k)%}
    {% endif%}
    
    def constraints_register(self):
        super().constraints_register()
    {% if k == "load_class"%}
        {% if v in ['电'] %}
            {% set port_name = '电接口' %}
        {% else %}
            {% error("未知负荷类型:",class_name) %}
        {% endif %}
        getTimeInDay = lambda index: index if self.计算参数.计算步长 == '小时' else self.计算参数.分时计价开始时间点 + 24*convertMonthToDays(self.计算参数.分时计价开始月份) + (index/3600)

        self.IncomeRates = [self.PriceModel.getFee(power, getTimeInDay(index)) for index, power in enumerate(self.{{port_name}}.values())] # positive?

        self.RangeConstraint(self.{{port_name}}, self.设备信息.EnergyConsumption, lambda x,y: x == -y)

        年化费用 = (sum(self.IncomeRates)/len(self.IncomeRates)) * 8760
        # 已经是负数了

        {# 计价模型 #}
    {% elif k == "input_class"%}
        {% if class_name in ['柴油']%}
        平均消耗率 = self.SumRange(self.燃料接口) / self.计算参数.迭代步数
        {% else%}
            {% error('未知能源类型:', class_name)%}
        {% endif%}

        年化费用 = 平均消耗率 * self.Price * 8760 

    {% else%}
        {% error("未知特殊类型:", k)%}
    {% endif%}
        self.总成本年化 = 年化费用
        return 年化费用

{% endfor %}
{% endfor %}

class ModelWrapperContext:
    def __init__(self):
        mw = ModelWrapper()
        self.mw = mw

    def __enter__(self):
        print("ENTER MODEL WRAPPER CONTEXT")
        return self.mw

    def __exit__(self, exc_type, exc_value, exc_traceback):
        # we don't have to take care of this.
        if exc_type == None:
            print("NO ERROR IN MODEL WRAPPER CONTEXT")
        else:
            print("ERROR IN MODEL WRAPPER CONTEXT")
        {# del self.mw.model #}
        del self.mw
        {# self.mw.exit() #}
        print("EXITING MODEL WRAPPER CONTEXT")

{% for e in ["Inst", "ID", 'Info'] %}
{% set class_types = {}%}
{% set type_suffix = ("模型" if e == "Inst" else ("信息" if e == 'Info' else e)) %}
{% for class_name in 设备接口集合.keys() %}
{% do class_types.update({class_name:class_name+type_suffix}) %}
{% endfor %}
dev{{e}}ClassMap : Dict[str, {{"设备"+type_suffix if type_suffix != "信息" else "BaseModel"}}]= {
    {% for class_name in 设备接口集合.keys() %}
    "{{class_name}}": {{class_types[class_name]}},
    {% endfor %}
} # type: ignore

{% endfor %}


{% macro iterate_input_output_limit(io_type, attr, type_annotation)%}
    {% set devInstVarName = "m_devInst{}".format(io_type.title())%}
                # IO TYPE: {{io_type}}
                m_limit_list = []
                for m_id in {{io_type}}_indexs:
                    m_anchor = G.nodes[m_id]
                    m_node_id = m_anchor['device_id']
                    {{devInstVarName}} : {{type_annotation}} = devInstDict[m_node_id]
                    m_limit_list.append({{devInstVarName}}.{{attr}})
                {{io_type}}_limit = {{- sum_reduce('m_limit_list') }}
{% endmacro %}

class 仿真结果(BaseModel):
    {% for chineseName, englishName in frontend_translation_table.items()%}
    {% if chineseName in ['元件名称', '设备型号']%}
        {% set mtype = 'str'%}
    {% elif chineseName in ["设备台数"]%}
        {% set mtype = 'int'%}
    {% else %}
        {% set mtype  = 'float'%}
    {% endif%}
    {{englishName}} : {{mtype if mtype !='int' else 'float'}} = Field(title = "{{chineseName}}")
    {# {% if mtype in ['int', 'float']%} #}

    {# {%if mtype == 'int'%}
    @validator('{{englishName}}')
    def convert_number_{{englishName}}(cls, v):
        try: 
            val = int(v)
        except:
            val = v
        return val
    {% endif%} #}

    {% endfor %}

class 节点基类(BaseModel):
    {# type:{{normal_str}} = Field(title = "节点类型") #}
    subtype:{{normal_str}} = Field(title = "节点次类型")
    id:int = Field(title = "节点ID")

class 连线节点(节点基类):
    type: Literal['连接线','合并线']

class 锚点节点(节点基类):
    type: Literal['锚点']
    port_name:{{normal_str}} = Field(title = '锚点名称')
    device_id:{{non_neg_int}} = Field(title = '锚点所对应设备ID')
    
class 母线节点(节点基类):
    type: Literal['母线']
    conn: conlist({{normal_str}}, min_items=2)  = Field(title = '母线连接线类型列表', description = '包括连接到母线上的连接线和合并线类型')# connection/merge types to literal.

class 设备接口映射(BaseModel):
    subtype: {{normal_str}} = Field(title = "接口类型")
    id: {{non_neg_int}} = Field(title = "接口ID", description = "拓扑图上与设备、母线、连接线的ID相比较具有唯一性的ID")

{% set infoClassList = []%}
{% for class_name in 设备接口集合.keys() %}
    {% do infoClassList.append(class_name+"信息")%}
{% endfor %}
class 设备节点(节点基类):
    type: Literal['设备']
    ports:Dict[{{normal_str}},设备接口映射] = Field(title = "设备接口映射", description = "描述设备所对应接口的类型和接口ID")
    param:Union[{{",".join(infoClassList)}}] = Field(title = '设备信息', description = "不同设备有不同的信息格式")

class mDict(BaseModel):
    directed:bool=Field(default = False, title='保留字段')
    multigraph:bool=Field(default = False, title='保留字段')
    graph:计算参数 = Field(
        title="能流拓扑图的附加属性",
        description="仿真和优化所需的模型参数字典", example = {
            "计算步长": "小时",
            "典型日": False,
            "典型日代表的日期": [],
            "计算类型": "设计规划",
            "风速": [], "光照":[],"气温":[] ,"年利率":0.1})
    nodes:conlist(Union[锚点节点,设备节点,母线节点,连线节点], min_items=5) = Field(
        title="节点",
        description="由所有节点ID和属性字典组成的列表", example =[ {
                "type": "锚点",
                "port_name": "电接口",
                "subtype": "供电端输出",
                "device_id": 2,
                "id": 3
            }])
    links:conlist(Dict[Union[Literal['source','target']], int], min_items=4) = Field(
        title="边",
        description="由能流图中节点互相连接的边组成的列表", example = [
            {
                "source": 0,
                "target": 1
            },
            {
                "source": 1,
                "target": 31
            }])

class EnergyFlowGraph(BaseModel):
    mDictList: List[mDict]

from networkx import Graph

# partial if typical day mode is on.
def compute(devs:List[dict], adders:Dict[int,dict], graph_data:dict, G: Graph, mw: ModelWrapper):
    PD = {}
    algoParam = 计算参数.parse_obj(graph_data)

    devInstDict = {}

    for dev in devs:
        devSubtype = dev['subtype']
        {# devParam = {k:v for k,v in dev.items() if k not in {"subtype","type","ports"} } #}
        devParam = dev['param']
        devPorts = dev['ports']

        devID_int = dev['id']

        devIDClass = devIDClassMap[devSubtype]

        devIDInstInit = {"ID": devID_int}
        for port_name, port_info in devPorts.items():
            port_id = port_info['id']
            devIDInstInit.update({port_name:port_id})
        devIDInst = devIDClass.parse_obj(devIDInstInit)

        devInfoInstInit = devParam
        devInfoClass = devInfoClassMap[devSubtype]
        devInfoInst = devInfoClass.parse_obj(devInfoInstInit)

        devInstClass = devInstClassMap[devSubtype]
        devInst = devInstClass(PD = PD, mw=mw, 计算参数实例=algoParam, 设备ID= devIDInst, 设备信息=devInfoInst) # type: ignore

        devInstDict.update({ devID_int: devInst})
    for adder_index, adder in adders.items():
        input_indexs, output_indexs, io_indexs = adder['input'], adder['output'], adder['IO']

        # fill in missing params
        if len(input_indexs) >= 1:
            if G.nodes[input_indexs[0]]['subtype'] == "柴油输出":
                assert len(input_indexs) == 1, "柴油元件只能一对多连接"
                diesel_node_id = G.nodes[input_indexs[0]]['device_id']
                {# 热值 = devInstDict[diesel_node_id].设备信息.热值 #}
                热值 = devInstDict[diesel_node_id].热值
                for output_index in output_indexs:
                    output_node_index = G.nodes[output_index]['device_id']
                    devInstDict[output_node_index].燃料热值 = 热值

        # add them all.

        print("_"*20)
        display_var_names = lambda indexs: '\n    '.join([str(PD[i]) for i in indexs])
        print(f"INPUTS:{display_var_names(input_indexs)}")
        print()
        print(f"OUTPUTS:{display_var_names(output_indexs)}")
        print()
        print(f"IO:{display_var_names(io_indexs)}")
        print("_"*20)

        for j in range(algoParam.迭代步数):
            seqsum = {{- sum_reduce('[PD[i][j] for i in input_indexs + output_indexs + io_indexs]') }}
            mw.Constraint(seqsum >=0)
        
        if algoParam.计算类型 == '设计规划':
            cnt = 0
            if len(input_indexs)==0:
                continue
            input_anchor_0 = G.nodes[input_indexs[0]]
            if input_anchor_0['subtype'] == '变压器输出':
                print(f"Building Converter Constraint #{cnt}")
                cnt+=1
                assert io_indexs == []

{{ iterate_input_output_limit("input","最大允许的负载总功率", "变压器模型") }}

{{ iterate_input_output_limit("output","MaxEnergyConsumption", "电负荷模型") }}

                mw.Constraint(input_limit + output_limit >= 0)

    financial_obj_expr = {{- sum_reduce('[e.constraints_register() for e in devInstDict.values()]') }}

    financial_dyn_obj_expr = sum([(e.总可变维护成本年化) for e in devInstDict.values()])

    environment_obj_exprs = [] # annual CO2 emission
    
    for e in devInstDict.values():
        {# if type(e) == 柴油模型: #}
        if isinstance(e, 柴油模型):
            environment_obj_exprs.append((sum(e.燃料接口.values())/e.计算参数.迭代步数)*8760 * e.CO2)

    environment_obj_expr = sum(environment_obj_exprs)
    
    obj_exprs = (financial_obj_expr,
                financial_dyn_obj_expr,
                environment_obj_expr,
)
    return obj_exprs, devInstDict, PD
    # always minimize the objective.

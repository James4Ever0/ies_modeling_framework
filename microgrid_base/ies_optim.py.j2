# TODO: 典型日 最终输出结果需要展开为8760
from typing import Dict, List, Tuple, Union
try:
    from typing import Literal
except:
    from typing_extensions import Literal

import rich
from pydantic import BaseModel, Field, validator
# the main code for computing.
# currently just compute microgrid
# three computation modes:
{# from functools import lru_cache #}

### 计价模型 ###
import math
# 函数参数: (power, time_in_day)
# 阶梯电价: 容量下限从0开始

class 常数电价(BaseModel):
    Price:float = Field("电价", description = "单位： kWh/元")

    def getFee(self, power:float, time_in_day:float) -> float:
        return power*self.Price

class 分时电价(BaseModel):
    PriceList: List[float] = Field("长度为24的价格数组", description = "单位： kWh/元")

    @validator("PriceList")
    def checkPriceList(cls, val):
        assert len(val) == 24
        return val

    def getFee(self, power:float, time_in_day:float) -> float:
        current_time = math.floor(time_in_day%24)
        price = self.PriceList[current_time]
        return price*power

class 计价阶梯(常数电价):
    LowerLimit : float = Field("功率下限")

class 阶梯电价(BaseModel):
    PriceStruct: List[计价阶梯] = Field("长度不定的计价阶梯列表", description = "单位： kWh/元")

    @validator("PriceStruct")
    def checkPriceStruct(cls, v: List[计价阶梯]):
        v.sort(key = lambda x: x.LowerLimit)
        assert v[0].LowerLimit == 0
        return v
    
    def getFee(self, power:float, time_in_day:float) -> float:
        for index, elem in enumerate(self.PriceStruct):
            if elem.LowerLimit <= power:
                if index+1 == len(self.PriceStruct) or self.PriceStruct[index+1].LowerLimit >= power:
                    return elem.Price * power
        rich.print(self)
        raise Exception("Unable to get electricity price with power:", power)

class 分时阶梯电价(BaseModel):
    PriceStructList: List[阶梯电价] = Field("长度为24的阶梯电价列表", description = "单位： kWh/元")

    def getFee(self, power:float, time_in_day:float) -> float:
        current_time = math.floor(time_in_day%24)
        mPriceStruct = self.PriceStructList[current_time]
        result = mPriceStruct.getFee(power, time_in_day)
        return result

{% set load_types = ['电']%}
{% set load_class_names = []%}
{% for load_type in load_types%}
{% do load_class_names.append(load_type+"负荷")%}
{% endfor%}
{% set input_types = ['柴油'] %}

{% macro sum_reduce(seq)%}
 sum({{seq}})
{# functools.reduce(sequence={{seq}}, function = lambda x,y: x+y) #}
{% endmacro%}

{% macro init_super_class(class_name)%}
    def __init__(self, PD:dict, mw: ModelWrapper, 计算参数实例: 计算参数, 设备ID: {{ class_name }}ID, 设备信息: {{ class_name }}信息):
        super().__init__(PD=PD, mw=mw, 计算参数实例=计算参数实例, ID = 设备ID.ID)
        self.设备ID = 设备ID
        self.设备信息 = 设备信息
{% endmacro %}

{%macro port_variable_define(class_name)%}
        ##### PORT VARIABLE DEFINITION ####

        self.ports = {}
        
        {% for port_name, port_type in 设备接口集合[class_name] %}
        {% if port_type.endswith("输入输出") %}
        {% set mt = "Reals" %}
        {% elif port_type.endswith("输入") %}
        {% set mt = "NegativeReals"%}
        {% elif port_type.endswith("输出") %}
        {% set mt = "NonNegativeReals"%}
        {% endif %}
        self.PD[self.设备ID.{{port_name}}] = self.ports['{{port_name}}'] = self.{{port_name}} = self.变量列表("{{port_name}}", within={{mt}})
        """
        类型: {{port_type}}
        """

        {% endfor %}
{% endmacro %}

{%macro expand_unit_conversion(mdigit, exceptionList=[])%}
        {% if mdigit[4] == 1 or mdigit[0] in exceptionList%}
        self.{{ mdigit[0] }}: float = 设备信息.{{ mdigit[0] }}
        """
        名称: {{ mdigit[1] }}
        单位: {{ mdigit[2] }}
        """
        {%else%}
        self.{{ mdigit[0] }}: float = 设备信息.{{ mdigit[0] }} * {{ mdigit[4]}}
        """
        名称: {{ mdigit[1] }}
        单位: {{ mdigit[3] }} <- {{ mdigit[2] }}
        """
        {% endif %}
        assert self.{{ mdigit[0] }} >=0
{%endmacro%}


{% set 时间步长参数='self.计算参数.时间参数'%}
{# {% set 时间步长参数='self.计算参数.时间参数()'%} #}
{# {% set 时间步长参数='(1 if self.计算参数.计算步长 == "小时" else 3600)'%} #}

{% set 单向变电器列表 = ['变压器', '变流器']%}

{%set 设备参数例外列表 = ["PowerDeltaLimit", "RatedWindSpeed", "MaxWindSpeed", "MinWindSpeed", "BatteryDeltaLimit", "BatteryStorageDecay", 'BatteryDeltaLimit']%}
# 8760 hours of data
# several days of data to compute a year

# 7200 seconds. simulation

# device parameters would be the same.

# load and environment might change.

# so for every device the will change.

# iterate through all device-port pairs, then retrieve attributes from another dict.

# string, digits, tables.
# you can dump and load from json.
{# 
class 加法器ID(BaseModel):
    输入:int
    输出:int
    输入输出: int #}

{# {% for super_class, class_name, mstrs, mdigits, mtables in 设备库 %} #}

#############
# Device ID #
#############
from pydantic import validator
class 设备ID(BaseModel):
    ID: int = Field(title = "设备ID", description = '从拓扑图节点ID获取')

{% for class_name in 设备接口集合.keys()%}

class {{class_name}}ID(设备ID):
    {% for port_name, port_type in 设备接口集合[class_name]%}
    {{ port_name }}: int = Field(title = "{{ port_name }}ID", description = "接口类型: {{ port_type }}")
    """
    类型: {{ port_type }}
    """
    {% endfor %}

{% endfor %}

###############
# Device Info #
###############

{% set deviceBaseIdentifiers = [
    "设备名称",
]%}
{% set deviceOptionalIdentifiers = [
    "生产厂商",
    "设备型号",
]%}
{% set deviceIdentifiers =deviceBaseIdentifiers + deviceOptionalIdentifiers %}

class 设备基础信息(BaseModel):
{% for i in deviceBaseIdentifiers%}
    {{i}}: str = Field(title = "{{i}}")

{% endfor %}

class 设备信息(设备基础信息):
{% for i in deviceOptionalIdentifiers%}
    {{i}}: str = Field(title = "{{i}}")

{% endfor %}

{% set NonLoadDeviceDict = {}%}

{# 不是标准单位 #}
{% set 燃料能源相关数据默认单位 = {
    '柴油':{
        "Price": "L/万元",
        "热值": "kWh/L",
        "CO2": "kg/L"
    }
}%}
{% for super_class, class_name, mstrs, mdigits, mtables in 设备库 %}
    {% do NonLoadDeviceDict.update({class_name: (super_class, mstrs, mdigits, mtables)})%}
{% endfor %}
{% for class_name in 设备接口集合.keys() %}

class {{class_name}}信息({{"设备基础信息" if class_name not in NonLoadDeviceDict.keys() else "设备信息"}}):
    {% if class_name not in NonLoadDeviceDict.keys() %}
        {% if class_name in load_class_names %}
    # 正数
    EnergyConsumption: List[float] = Field(title = '耗能功率表', description='单位: kW')
    """
    单位: kW
    {# In this way it will be timescale independent. #}
    """

    MaxEnergyConsumption: Union[None, float] = Field(default = None, title = "最大消耗功率", description = '单位: kW\n用于典型日下计算变压器容量')
    """
    单位: kW
    {# 用于电负荷 典型日计算 #}
    """

    {% if class_name in ["电负荷"]%}
    PriceModel: Union[常数电价, 阶梯电价, 分时电价, 分时阶梯电价] = Field(title = '计价模型', description='单位: kWh/元')
    {% else%}
        {% error("未找到'{}'的计价模型".format(class_name))%}
    {% endif%}
        {% else %}
            {% if class_name in 燃料能源相关数据默认单位.keys()%}
                {% for attrName, defaultUnit in 燃料能源相关数据默认单位[class_name].items()%}
    {{ attrName}} : Tuple[float, str] = Field(title = "{{attrName}}", description="格式: [数值,单位]")
    """
    格式: [数值,单位]
    """
                {% endfor%}

    class DefaultUnits:
                {% for attrName, defaultUnit in 燃料能源相关数据默认单位[class_name].items()%}
        {{attrName }} = "{{defaultUnit}}"
                {%endfor%}
            {% else%}
                {% error("未知负荷信息类型:", class_name)%}
            {% endif%}
        {% endif%}
    {% else %}
        {% set super_class, mstrs, mdigits, mtables = NonLoadDeviceDict[class_name] %}
        {% for psc, mstr in mstrs %}
            {%if mstr not in deviceIdentifiers%}
    {{ mstr }}: str = Field(title = "{{mstr}}")
            {% endif%}

        {% endfor %}
    
        {% for psc, mdigit in mdigits %}
    {{ mdigit[0] }}: float = Field(title = "{{mdigit[1]}}", description =     "名称: {{ mdigit[1] }}\n单位: {{ mdigit[2] }}")
    """
    名称: {{ mdigit[1] }}
    单位: {{ mdigit[2] }}
    """

        {% endfor %}

        {% for psc, main, sub in mtables %}
            {% set mtable=(main, sub)%}
    {{ mtable[0][0]}}_{{ mtable[1][0]}} : List[List[float]] = Field(title = "{{ mtable[0][1]}}_{{ mtable[1][1]}}", description=   "{{ mtable[0][0]}}: {{ mtable[0][1]}}\n单位: {{ mtable[0][2]}}\n{{ mtable[1][0]}}: {{ mtable[1][1]}}\n单位: {{ mtable[1][2]}}")
    """
    {{ mtable[0][0]}}: {{ mtable[0][1]}}
    单位: {{ mtable[0][2]}}

    {{ mtable[1][0]}}: {{ mtable[1][1]}}
    单位: {{ mtable[1][2]}}
    """

        {% endfor %}
    {% endif %}
{% endfor %}

####################
# model definition #
####################

from pyomo.environ import *

class ModelWrapper:
    def __init__(self):
        self.model = ConcreteModel()
        self.clock = {}
    def getSpecialName(self, key:str):
        val = self.clock.get(key,0)
        name = f"{key}_{val}"
        self.clock[key] = val+1
        return name
    {% for k in ['Constraint', 'Var','Objective']%}
    {% set mv = "*args, **kwargs"%}
    def {{k}}(self, {{ "name:str," if k == "Var" else ""}} {{ mv}}):
        {% if k !="Var" %}
        expr = kwargs.pop('expr',args[0] if len(args) >0 else None)
        if expr is None:
            print("ARGS:", args)
            print("KWARGS:", kwargs)
            raise Exception("Not passing expression to method '{{k}}'")
        deg = expr.polynomial_degree()
        if deg != 1:
            print("EXPR DEG:", deg)
            raise Exception(f"{{k}}: Unacceptable polynomial degree for expression '{str(expr)}'")
        name = self.getSpecialName("{{k[:3].upper()}}")
        {% endif %}
        ret = {{k}}({{mv if k == "Var" else "expr = expr, *args[1:], **kwargs"}})
        self.model.__setattr__(name, ret)
        return ret
    {% endfor%}


# first convert the unit.
# assign variables.

# shall you assign port with variables.

# 风、光照

# 需要明确单位
class 计算参数(BaseModel):
    典型日ID: Union[int, None] = None # increse by external loop
    计算步长: Union[Literal["小时"], Literal['秒']]
    典型日: bool

    分时计价开始时间点: float = Field(default=0)

    @validator('分时计价开始时间点')
    def validate_starting_time(cls, v):
        assert v>=0, f"开始时间点大于等于0\n实际: {v}"
        assert v<=24, f"开始时间点小于等于24\n实际: {v}"
        return v
    
    {# 典型日权重: int = 0 #}
    典型日代表的日期: List[int] = []
    @validator('典型日代表的日期')
    def validate_typical_day(cls, v, values):
        if values['典型日']:
            assert len(v) >0
            assert len(v) <=365
        return v
    计算类型: Union[Literal['仿真模拟'],Literal['设计规划']]
    计算目标: Union[Literal['经济'], Literal['环保'], Literal['经济_环保']]
    风速: List[float]
    """
    单位: m/s
    """
    光照: List[float]
    """
    单位: kW/m2
    """
    气温: List[float]
    """
    单位: 摄氏度
    """
    年利率: float
    """
    单位: percent
    """
    @property
    def 迭代步数(self):
        {# steps = None #}
        if self.计算步长 == "秒":
            steps = 7200
        elif self.计算步长 == "小时" and self.典型日 is False:
            steps = 8760
        elif self.计算步长 == "小时" and self.典型日 is True:
            steps = 24
        else:
            rich.print(self)
            raise Exception("未知计算参数")
        assert len(self.风速) == steps
        assert len(self.光照) == steps
        assert len(self.气温) == steps
        return steps
    
    {# @lru_cache(maxsize=1) #}
    @property
    def 时间参数(self):
        return (1 if self.计算步长 == "小时" else 3600)
    {# @property # 提前计算好了
    def 典型日列表(self): # 
        ... #}
    {# # like: (tday_index, tday_data, tday_count) #}

class POSNEG:
    def __init__(self, x, x_pos, x_neg, b_pos, b_neg, x_abs):
        {%for f in ["x", "x_pos", "x_neg", "b_pos", "b_neg", "x_abs"]%}
        self.{{f}} = {{f}}
        {%endfor%}

{# from functools import reduce #}
{# import functools #}
class 设备模型:
    def __init__(self, PD: dict, mw: ModelWrapper, 计算参数实例: 计算参数, ID):
        print("Building Device Model:", self.__class__.__name__)
        self.mw = mw
        self.PD = PD
        self.计算参数 = 计算参数实例
        self.ID = ID
        self.SID = 0
        self.BigM = 1e+20
        {# self.BigM = 1e+12 #}
        """
        一个极大数
        """
        self.EPS = 1e-4
        """
        一个极小数
        """
        {% for e0 in [
            "总采购成本",
            "总建设费用",
            "总固定维护成本",
            "总固定成本年化",
            "总成本年化",
            "总可变维护成本年化"
        ]
        %}
        self.{{e0}} = 0
        {% endfor %}
        self.年化率 = 1
    
    def constraints_register(self):
        print("REGISTERING: ", self.__class__.__name__)
        {# raise NotImplementedError("Must be implemented by subclasses.") #}

    def getVarName(self, varName: str):
        VN = f"DI_{self.ID}_VN_{varName}" # use underscore.
        if self.计算参数.典型日ID:
            VN = f"TD_{self.计算参数.典型日ID}_"+VN
        return VN
    
    def getSpecialVarName(self, varName:str):
        specialVarName = f"SP_{self.SID}_{varName}"
        self.SID +=1
        return specialVarName

    def 单变量(self, varName: str, **kwargs):
        var = self.mw.Var(self.getVarName(varName) ,**kwargs)
        return var

    def 变量列表(self, varName: str,**kwargs):
        var = self.mw.Var(self.getVarName(varName) ,range(self.计算参数.迭代步数), **kwargs)
        return var

    def RangeConstraint(self,var_1, var_2, expression):
        for i in range(self.计算参数.迭代步数):
            self.mw.Constraint(expression(var_1[i], var_2[i]))

    def RangeConstraintMulti(self, *vars, expression=...): # keyword argument now.
        assert expression is not ...
        for i in range(self.计算参数.迭代步数):
            self.mw.Constraint(expression(*[var[i] for var in vars]))

    def CustomRangeConstraint(self, var_1, var_2, customRange:range, expression):
        for i in customRange:
            self.mw.Constraint(expression(var_1, var_2, i))
    
    def CustomRangeConstraintMulti(self, *vars, customRange:range=..., expression=...):
        assert expression is not ...
        assert customRange is not ...
        for i in customRange:
            self.mw.Constraint(expression(*vars, i))
    
    def SumRange(self,var_1):
        return {{- sum_reduce('[var_1[i] for i in range(self.计算参数.迭代步数)]')}}
    
    def 单变量转列表(self, var, dup=None):
        if dup is None:
            dup = self.计算参数.迭代步数
        return [var for _ in range(dup)]
    
    def 变量列表_带指示变量(self, varName:str, within = Reals) -> POSNEG:
        x = self.变量列表(varName,within=within)

        {% for flag in ['pos', 'neg'] %}
        b_{{flag}} = self.变量列表(self.getSpecialVarName(varName), within = Boolean)
        x_{{flag}} = self.变量列表(self.getSpecialVarName(varName), within = NonNegativeReals)

        self.RangeConstraint(b_{{flag}}, x_{{flag}}, lambda x,y: x*self.BigM >= y)
        {% endfor %}

        self.RangeConstraint(b_pos, b_neg, lambda x,y: x+y == 1)

        self.RangeConstraintMulti(x, x_pos, x_neg, expression = lambda x,y,z: x == y-z )

        x_abs = self.变量列表(self.getSpecialVarName(varName), within = NonNegativeReals)

        self.RangeConstraintMulti(x_pos, x_neg, x_abs, expression = lambda x,y,z : z == x+y)

        posneg = POSNEG(x, x_pos, x_neg, b_pos, b_neg, x_abs)

        return posneg
    
    def Piecewise(self, 
        x_var, # x_var
        y_var, # y_var
        x_vals: List[float],
        y_vals: List[float],
     range_list:Union[List[int], None]=None, pw_repn='SOS2', pw_constr_type='EQ', unbounded_domain_var=True):
        if range_list is None:
            range_list = list(range(self.计算参数.迭代步数))
        PWL = []
        for i in range_list:
            piecewise_name = self.getSpecialVarName("PW")
            PW = Piecewise(
            y_var[i],
            x_var[i],
            pw_pts=x_vals,
            f_rule=y_vals,
            pw_repn=pw_repn,
            pw_constr_type=pw_constr_type,
            unbounded_domain_var=unbounded_domain_var,
            warn_domain_coverage=False, # to suppress warning
        )
            self.mw.model.__setattr__(piecewise_name, PW)
            PWL.append(PW)
        return PWL
    
    def BinVarMultiplySingle(self, b_var, x_var):
        assert b_var.is_binary()
        {# assert x_var.is_continuous()  #}
        {# x_var can be binary. #}
        h = self.单变量(self.getSpecialVarName("BVM"))

        self.mw.Constraint(h<=b_var* self.BigM)
        self.mw.Constraint(h>= -b_var*self.BigM)
        self.mw.Constraint(h <= x_var+(1-b_var)*self.BigM)
        self.mw.Constraint(h >= x_var-(1-b_var)*self.BigM)

        return h
    def Multiply(self,dict_mx:dict, dict_my:dict, varName:str, precision = 10, within = Reals): # two continuous multiplication
        #  (x+y)^2 - (x-y)^2 = 4xy
        mx, max_mx, min_mx = dict_mx['var'], dict_mx['max'], dict_mx['min']
        my, max_my, min_my = dict_my['var'], dict_my['max'], dict_my['min']
        assert not mx[0].is_binary()
        assert not my[0].is_binary()

        m1posneg = self.变量列表_带指示变量(self.getSpecialVarName(varName))
        self.RangeConstraintMulti(m1posneg.x, mx, my , expression = lambda x,y,z: x == y+z)
        mx_my_sum_var = m1posneg.x_abs
        mx_my_sum_pow2_var = self.变量列表(self.getSpecialVarName(varName))

        m2posneg = self.变量列表_带指示变量(self.getSpecialVarName(varName))
        self.RangeConstraintMulti(m2posneg.x, mx, my, expression = lambda x,y,z: x == y-z)
        mx_my_minus_var = m2posneg.x_abs
        mx_my_minus_pow2_var = self.变量列表(self.getSpecialVarName(varName))

        l0, r0 = min_mx + min_my, max_mx+max_my
        l1, r1 = min_mx - max_my, max_mx-min_my
        def getBound(l0, r0):
            if l0*r0 >=0:
                l0,r0 = abs(l0), abs(r0)
                l, r = min([l0, r0]), max([l0, r0])
            else:
                l0, r0 = abs(l0), abs(r0)
                l, r = 0, max([l0, r0])
            return l, r

        mx_my_sum = np.linspace(*getBound(l0, r0), precision).tolist()

        mx_my_sum_pow2 = [x**2 for x in mx_my_sum]

        mx_my_minus = np.linspace(*getBound(l1, r1), precision).tolist()

        mx_my_minus_pow2 = [x**2 for x in mx_my_minus]

        self.Piecewise(x_var = mx_my_sum_var, y_var = mx_my_sum_pow2_var, x_vals = mx_my_sum, y_vals = mx_my_sum_pow2) # assume it is absolute.

        self.Piecewise(x_var = mx_my_minus_var, y_var = mx_my_minus_pow2_var, x_vals = mx_my_minus, y_vals = mx_my_minus_pow2)

        mx_my_multiply = self.变量列表(varName, within=within)

        self.RangeConstraintMulti(mx_my_sum_pow2_var, mx_my_minus_pow2_var, mx_my_multiply, expression =  lambda x,y,z:(x-y)/4 == z)

        return mx_my_multiply

# input: negative
# output: positive
# IO: Real
import numpy as np
import math

{% for super_class, class_name, mstrs, mdigits, mtables in 设备库 %}

class {{class_name}}模型(设备模型):
{{ init_super_class(class_name)}}

        {% set mflag = namespace(val="")%}
        {% if class_name in ['柴油发电']%}
        self.燃料热值:float = 0 # 需要拓扑解析之后进行赋值
        {% endif%}
        {% for psc, mdigit in mdigits %}
        {% if psc in ["仿真模拟","设计规划"] %}
        {# # psc: {{psc}} mflag: {{mflag}} #}
        {% if mflag.val != psc %}
        {% set mflag.val = psc%}
        {# # after: psc: {{psc}} mflag: {{mflag}} #}
        if self.计算参数.计算类型 == "{{psc}}":
        {% if psc == "设计规划" %}
            self.DeviceCount = self.单变量('DeviceCount', within=NonNegativeIntegers) # type: ignore
            """
            单位： 个
            """
        {% elif psc == "仿真模拟"%}
            {% if class_name == '锂电池'%}
            self.DeviceCount = math.floor(self.设备信息.TotalCapacity / self.设备信息.RatedCapacity)
            {% endif%}
        {% endif %}
        {%endif%}
{{expand_unit_conversion(mdigit) | indent(4, True)}}
        {# {{expand_unit_conversion(mdigit) | indent(4, True)}} #}
        {% else %}
{{expand_unit_conversion(mdigit,设备参数例外列表) }}
        {% endif %}
        {% endfor %}
        {# {%endwith%} #}

        {% for psc, main, sub in mtables %}
        {% set mtable=(main, sub)%}
        self.{{ mtable[0][0]}}_{{ mtable[1][0]}} : List[List[float]] = [[v1 * {{mtable[0][4]}}, v2 * {{mtable[1][4]}}] for v1, v2 in 设备信息.{{ mtable[0][0]}}_{{ mtable[1][0]}}]
        self.{{ mtable[0][0]}}_{{ mtable[1][0]}}.sort(key=lambda x: x[1])
        """
        {{ mtable[0][0]}}: {{ mtable[0][1]}}
        单位: {{ mtable[0][3]}} <- {{ mtable[0][2]}}

        {{ mtable[1][0]}}: {{ mtable[1][1]}}
        单位: {{ mtable[1][3]}} <- {{ mtable[1][2]}}
        """

        {% endfor %}

{{ port_variable_define(class_name)}}
        
        # 设备特有约束（变量）
        {% if class_name in ['光伏发电','风力发电','柴油发电']%}
        self.电输出 = self.电接口
        {% if class_name in ["柴油发电"]%}
        self.柴油输入 = self.燃料接口
        {% endif%}
        {% endif%}

        {% if class_name in ['变压器']%}
        if self.计算参数.计算类型 == "设计规划": # 在变压器和负荷的交换节点处做处理
            self.最大允许的负载总功率 = self.DeviceCount*(self.RatedPower*self.Efficiency)*self.PowerParameter/self.LoadRedundancyParameter # type: ignore
        {% endif%}
        {% if class_name in ['光伏发电']%}
        if self.计算参数.计算类型 == "设计规划":
            self.MaxDeviceCount = math.floor(self.MaxInstallArea/self.Area)
            self.MinDeviceCount = math.ceil(self.MinInstallArea/self.Area)
            assert self.MinDeviceCount>=0
            assert self.MaxDeviceCount>=self.MinDeviceCount
        {% elif class_name == "柴油发电" %}
        self.电功率中转 = self.变量列表_带指示变量("电功率中转")
        
        self.单台发电功率 = self.变量列表("单台发电功率", within=NonNegativeReals)
        self.单台柴油输入 = self.变量列表("单台柴油输入", within=NonPositiveReals)

        if self.计算参数.计算类型 == "设计规划":
            self.最大油耗率 = max([x[0] for x in self.DieselToPower_Load])

            self.原电输出 = self.Multiply(dict(var=self.单台发电功率,max=self.RatedPower, min=0), dict(var=self.单变量转列表(self.DeviceCount),max=self.MaxDeviceCount, min=self.MinDeviceCount), "原电输出", within = NonNegativeReals)

            self.柴油输入_ = self.Multiply(dict(var=self.单台柴油输入, max=0, min=-self.RatedPower*self.最大油耗率), dict(var=self.单变量转列表(self.DeviceCount),max=self.MaxDeviceCount, min=self.MinDeviceCount), "柴油输入_", within = NonPositiveReals)
            self.RangeConstraint(self.柴油输入_, self.柴油输入, lambda x,y: x == y)
        else:
            self.原电输出 = self.变量列表("原电输出",within = NonNegativeReals)
            self.RangeConstraint(self.原电输出 ,self.单台发电功率, lambda x,y: x == y*self.DeviceCount)
        {% elif class_name  == '锂电池' %}

        assert self.InitSOC >= self.MinSOC
        assert self.InitSOC <= self.MaxSOC
        self.InitActualCapacityPerUnit = (self.InitSOC - self.MinSOC) * self.RatedCapacity

        if self.计算参数.计算类型 == "设计规划":
            #  初始SOC
            self.MaxDeviceCount = math.floor(self.MaxTotalCapacity / self.RatedCapacity)
            self.MinDeviceCount = math.ceil(self.MinTotalCapacity / self.RatedCapacity)

            self.TotalCapacity = self.DeviceCount * self.RatedCapacity # type: ignore

        assert self.MaxSOC >= self.MinSOC
        assert self.MaxSOC <= 1
        assert self.MinSOC >= 0

        self.原电接口 = self.变量列表_带指示变量("原电接口") # 正 放电 负 充电

        self.ActualCapacityPerUnit = self.RatedCapacity * (self.MaxSOC - self.MinSOC)

        self.CurrentTotalActualCapacity = self.变量列表('CurrentTotalActualCapacity', within=NonNegativeReals)

    

        self.TotalActualCapacity = self.DeviceCount * self.ActualCapacityPerUnit # type: ignore

        self.MaxTotalCapacityDeltaPerStep = self.BatteryDeltaLimit * self.TotalCapacity / ({{时间步长参数}})
        """
        单位: kWh
        """

        self.TotalStorageDecayRate = (self.BatteryStorageDecay / 100) * self.TotalCapacity
        """
        单位: kW
        """

        {%elif class_name in ['双向变流器']%}
        self.线路端_ = self.变量列表_带指示变量("线路端_") 
        self.储能端_ = self.变量列表_带指示变量("储能端_")
        {% elif class_name in ['传输线']%}
        self.电输入_去除损耗 = self.变量列表_带指示变量('电输入_去除损耗') 
        {%endif%}

    def constraints_register(self):
        super().constraints_register()
        # 设备特有约束（非变量）
        {# 检验解析时参数是否填写完全 #}
        {% if class_name in ['柴油发电']%}
        assert self.燃料热值!=0
        assert type(self.燃料热值) in [int,float]
        {% endif%}
        {% if class_name == "风力发电" %}
        # define a single-variate piecewise function
        # 
        #         ____
        #        /    |
        #       /     | ax^3
        #  ----/      |______
        #
        assert self.RatedWindSpeed >=self.MinWindSpeed
        assert self.MaxWindSpeed >=self.RatedWindSpeed

        发电曲线参数 = self.RatedPower / ( (self.RatedWindSpeed - self.MinWindSpeed) ** 3)

        # windspeed (m/s) -> current power per device (kW)
        WS = np.array(self.计算参数.风速)
        单台发电功率 = np.piecewise(WS, [WS<=self.MinWindSpeed, WS >self.MinWindSpeed and WS <= self.RatedWindSpeed , WS >self.RatedWindSpeed and WS <=self.MaxWindSpeed, WS > self.MaxWindSpeed], [0,lambda x: 发电曲线参数 * ((x - self.MinWindSpeed) ** 3),self.RatedPower,0])
        单台发电功率 = 单台发电功率.tolist()
        {% endif %}

        # 设备台数约束
        {% if class_name not in ['传输线'] %}
        if self.计算参数.计算类型 == "规划设计":
            self.mw.Constraint(self.DeviceCount <= self.MaxDeviceCount)
            self.mw.Constraint(self.DeviceCount >= self.MinDeviceCount)
        {% endif %}
        
        # 输出输入功率约束
        {%if class_name in ['传输线']%}
        TotalDecayPerStep = self.Length * self.PowerTransferDecay / {{时间步长参数}}
        self.RangeConstraint(self.电输入_去除损耗.x, self.电输入, lambda x,y: x == y+TotalDecayPerStep )
        self.RangeConstraint(self.电输入_去除损耗.x_neg, self.电输出,lambda x,y:x == y )
        {%elif class_name in ['双向变流器']%}

        self.RangeConstraint(self.线路端_.x , self.线路端, lambda x,y: x==y)
        self.RangeConstraint(self.储能端_.x , self.储能端, lambda x,y: x==y)

        self.RangeConstraint(self.线路端_.x_neg, self.储能端_.x_pos,lambda x,y: x == y*self.Efficiency)
        self.RangeConstraint(self.储能端_.x_neg, self.线路端_.x_pos,lambda x,y: x == y*self.Efficiency)

        {% elif class_name in 单向变电器列表%}
        self.RangeConstraint(self.电输入, self.电输出, lambda x,y: x == -y* self.Efficiency {{"* self.PowerParameter" if class_name in ['变压器'] else ""}})
        self.RangeConstraintMulti(self.电输入, expression=lambda x: -x<=self.RatedPower * self.DeviceCount )
        {% elif class_name in ['光伏发电'] %}
        光电转换效率 = self.MaxPower / self.Area # 1kW/m2光照下能产生的能量 省略除以1 单位: one
        总最大功率 = self.MaxPower * self.DeviceCount
        总面积 = self.Area * self.DeviceCount

        # 光照强度 * 总面积 * 光电转换效率 * 电电转换效率
        # (kW/m2) * m2 * one * one -> kW
        self.RangeConstraint(self.计算参数.光照, self.电输出, lambda x,y: x*总面积*光电转换效率*self.PowerConversionEfficiency >= y)

        {% elif class_name in ['风力发电'] %}
        self.RangeConstraint(单台发电功率, self.电输出, lambda x,y: x*self.DeviceCount >= y)

        {% elif class_name in ['柴油发电'] %}
        总最小启动功率 = self.RatedPower * self.PowerStartupLimit * self.DeviceCount
        总最大输出功率 = self.RatedPower * self.DeviceCount

        self.RangeConstraintMulti(self.单台发电功率, expression = lambda x: x <= self.RatedPower)
        self.RangeConstraint(self.原电输出, self.电功率中转.x ,lambda x,y: x == y + 总最小启动功率)

        self.Piecewise(y_var = self.单台柴油输入, x_var = self.单台发电功率, y_vals = [-x[0]*self.RatedPower*x[1] for x in self.DieselToPower_Load], x_vals = [self.RatedPower*x[1] for x in self.DieselToPower_Load])
        # 柴油输入率: L/h

        self.RangeConstraintMulti(self.电功率中转.x_pos, self.电输出, self.电功率中转.b_pos, expression = lambda x,y,z: x + self.BinVarMultiplySingle(z,总最小启动功率) == y)

        {%elif class_name in ['锂电池'] %}
        self.RangeConstraintMulti(self.CurrentTotalActualCapacity, expression = lambda x: x <= self.TotalActualCapacity)

        self.mw.Constraint(self.CurrentTotalActualCapacity[0] == self.InitActualCapacityPerUnit * self.DeviceCount)

        self.CustomRangeConstraint( self.原电接口.x, self.CurrentTotalActualCapacity, range(self.计算参数.迭代步数-1), lambda x,y,i: x[i] == (y[i] - y[i+1]) * {{时间步长参数}})
        {# power = delta(capacity)/delta(time)#}
        
        self.RangeConstraintMulti(self.原电接口.x_pos, self.原电接口.x_neg, self.电接口,expression = lambda x_pos, x_neg, y: x_pos * self.DischargeEfficiency - (x_neg + self.TotalStorageDecayRate)/self.ChargeEfficiency == y)

        for i in range(self.计算参数.迭代步数-1):
            self.mw.Constraint(self.CurrentTotalActualCapacity[i+1] - self.CurrentTotalActualCapacity[i] <=self.MaxTotalCapacityDeltaPerStep)
            self.mw.Constraint(self.CurrentTotalActualCapacity[i+1] - self.CurrentTotalActualCapacity[i] >=-self.MaxTotalCapacityDeltaPerStep)

        if self.计算参数.计算类型 == "设计规划":
            if self.设备信息.循环边界条件 == '日间独立':
                self.mw.Constraint(self.原电接口.x[0] == self.EPS)
            elif self.设备信息.循环边界条件 == '日间连接':
                self.mw.Constraint(self.CurrentTotalActualCapacity[0] - self.CurrentTotalActualCapacity[self.计算参数.迭代步数-1] <=self.MaxTotalCapacityDeltaPerStep)

                self.mw.Constraint(self.CurrentTotalActualCapacity[0] - self.CurrentTotalActualCapacity[self.计算参数.迭代步数-1] >=-self.MaxTotalCapacityDeltaPerStep)

                self.mw.Constraint(self.原电接口.x[0] == (self.CurrentTotalActualCapacity[self.计算参数.迭代步数-1] - self.CurrentTotalActualCapacity[0]) * {{时间步长参数}} )
            else:
                raise Exception("未知循环边界条件:", self.设备信息.循环边界条件)
        elif self.计算参数.计算类型 == "仿真模拟":
            self.mw.Constraint(self.原电接口.x[0] == self.EPS)

        {% endif %}

        {# 秒级功率变化限制，有特定的变量限制 #}
        {% if class_name in ['光伏发电', '风力发电', '柴油发电'] %}
        if self.计算参数.计算步长 == "秒":
            总最大功率 = {{'self.MaxPower' if class_name in ['光伏发电'] else 'self.RatedPower'}} * self.DeviceCount
            最大功率变化 = 总最大功率 *self.PowerDeltaLimit / 100
            self.CustomRangeConstraintMulti(self.{{'原电输出' if class_name in ['柴油发电'] else '电输出'}} , customRange = range(self.计算参数.迭代步数-1),expression = lambda x,i: x[i+1] - x[i] <= 最大功率变化)
            self.CustomRangeConstraintMulti(self.{{'原电输出' if class_name in ['柴油发电'] else '电输出'}} , customRange =  range(self.计算参数.迭代步数-1),expression = lambda x,i: x[i+1] - x[i] >= -最大功率变化)
        {% endif %}
        {# elif self.计算参数.计算步长 == "小时":
            ... # skip it.
        else:
            raise Exception("未知计算步长:", self.计算参数.计算步长) #}
        
        # 计算年化
        # unit: one
        {# if 计算参数.计算类型 == "规划设计": #}
        {# 规划设计和仿真模拟都需要计算年化 #}
        {%with%}
        {% if class_name in ['锂电池'] %} 
        计算范围内总平均功率 = (self.SumRange(self.原电接口.x_abs)/self.计算参数.迭代步数)+self.TotalStorageDecayRate # kW
        # avg power

        一小时总电变化量 = 计算范围内总平均功率 # 省略乘1
        # kWh

        一年总电变化量 = 一小时总电变化量 * 8760
        
        self.mw.Constraint(一年总电变化量 * self.BatteryLife <= self.DeviceCount * self.TotalDischargeCapacity * 0.85)
        assert self.BatteryLife >=1
        assert self.Life >= self.BatteryLife
        Life = self.BatteryLife
        {%else%}
        Life = self.Life
        {%endif%}

        self.年化率 = ((1+(self.计算参数.年利率/100))** Life) / Life
        {% if class_name in ['光伏发电'] %}
            {% set m='总最大功率'%}
            {% set vi = 'Kilowatt' %}
            {% set vm = 'Kilowatt' %}
            {% set vb = 'Kilowatt' %}
            {% set vv = 'Work' %}
        {%elif class_name in ['风力发电']+单向变电器列表+ ['双向变流器']%}
            {% set m='self.DeviceCount * self.RatedPower'%}
            {% set vi = 'Kilowatt' %}
            {% set vm = 'Kilowatt' %}
            {% set vb = 'Kilowatt' %}
            {% set vv = 'Work' %}
        {% elif class_name in ['柴油发电']%}
            {% set m='self.DeviceCount'%}
            {% set vi = 'Machine' %}
            {% set vm = 'Machine' %}
            {% set vb = 'Machine' %}
            {% set vv = 'Work' %}
        {% elif class_name in ["锂电池"]%}
            {% set m='self.DeviceCount * self.RatedCapacity'%}
            {% set vi = 'Capacity' %}
            {% set vm = 'Capacity' %}
            {% set vb = 'Capacity' %}
            {% set vv = 'Work' %}
        {% elif class_name in ['传输线'] %}
            {% set m='self.Length'%}
            {% set vi = 'Kilometer' %}
            {% set vm = 'Kilometer' %}
            {% set vb = 'Kilometer' %}
        {% else%}
            {% error("不支持的设备类型:", class_name) %}
        {% endif %}

        self.总采购成本 = self.CostPer{{vi}} * ({{ m}}) 
        self.总固定维护成本 = self.CostPerYearPer{{vm}} * ({{ m}})
        self.总建设费用 = self.BuildCostPer{{vb}} * ({{ m}}) + self.BuildBaseCost

        self.总固定成本年化 = (self.总采购成本 + self.总固定维护成本 + self.总建设费用) * self.年化率

        {% if class_name in ['光伏发电','风力发电','柴油发电']%}
            {% set m1="self.SumRange(self.电输出)"%}
        {% elif class_name in ['锂电池']%}
            {% set m1="计算范围内总平均功率*self.计算参数.迭代步数"%}
        {% elif class_name in 单向变电器列表+['传输线']%}
            {% set m1='-self.SumRange(self.电输入)'%}
        {% elif class_name in ['双向变流器']%}
            {% set m1='(self.SumRange(self.储能端_.x_neg)+self.SumRange(self.线路端_.x_neg))'%}
        {%elif class_name in ['传输线'] %}
            {% set m1='0'%}
        {% else%}
            {% error("不支持的类型:", class_name) %}
        {% endif %}
        {% if class_name not in ['传输线']%}
        {# 总可变维护成本年化 = ({{m1}}) * (8760 / self.计算参数.迭代步数) * ({{时间步长参数}}) *self.VariationalCostPer{{vv}} #}
        self.总可变维护成本年化 = (({{m1}}) / self.计算参数.迭代步数) * 8760 * self.VariationalCostPer{{vv}} 
        # avg_power * 8760 = annual_work

        self.总成本年化 = self.总固定成本年化 + self.总可变维护成本年化
        {% else%}
        self.总成本年化 = self.总固定成本年化
        {% endif%}
        {% endwith%}

        return self.总成本年化
{% endfor %}

{# ##########[PINT START]########## #}

{# import pint #}

from unit_utils import (
    unitFactorCalculator,
    ureg,
    standard_units,
    getSingleUnitConverted,
)

{# ##########[PINT END]########## #}

{% set load_class_names = [] %}
{% for v in load_types%}
    {% do load_class_names.append(v+"负荷")%}
{% endfor%}
{% set input_class_names = input_types%}
{% set special_classes = {"load_class": load_class_names, "input_class": input_class_names}%}

{# check for coverage #}
{% for class_name in 设备接口集合.keys() %}
    {% if class_name not in NonLoadDeviceDict.keys() %}
        {% if class_name not in input_class_names+load_class_names%}
            {% error("未覆盖的非设备类型:", class_name)%}
        {% endif%}
    {% endif%}
{% endfor%}

{% for k,clist in special_classes.items() %}
    {% for class_name in clist%}
class {{class_name}}模型(设备模型):
{{ init_super_class(class_name)}}

{{ port_variable_define(class_name)}}

    {% if k == "load_class"%}
        {% if not class_name.endswith('负荷')%}
            {% error("错误的负荷类名:", class_name)%}
        {% else%}
            {% set v = class_name.strip("负荷")%}
        {% endif%}
        assert len(self.设备信息.EnergyConsumption) == self.计算参数.迭代步数

        {% if v in ['电'] %}
        MaxEnergyConsumptionDefault = max(self.设备信息.EnergyConsumption)
        if self.设备信息.MaxEnergyConsumption is None:
            self.MaxEnergyConsumption = MaxEnergyConsumptionDefault
        else:
            assert self.设备信息.MaxEnergyConsumption >= MaxEnergyConsumptionDefault
            self.MaxEnergyConsumption = self.设备信息.MaxEnergyConsumption
        {% endif %}

        self.IncomeRates = ...
        self.PriceModel = self.设备信息.PriceModel

    {% elif k == 'input_class' %}

        class _Units(BaseModel):
        {% for attrName, defaultUnit in 燃料能源相关数据默认单位[class_name].items() %}
            {{attrName}}: str
        {% endfor%}

        UnitsDict = {}

        {% for attrName, defaultUnit in 燃料能源相关数据默认单位[class_name].items() %}
        ## PROCESSING: {{attrName}}
        ### UNIT COMPATIBILITY CHECK ###
        default_unit = self.设备信息.DefaultUnits.{{attrName}}
        val_unit = self.设备信息.{{attrName}}[1]

        has_exception, _ = getSingleUnitConverted(default_unit = default_unit, val_unit =val_unit)

        if has_exception:
            raise Exception(f"Unit '{val_unit}' is not compatible with default unit '{default_unit}'")
        ### UNIT COMPATIBILITY CHECK ###

        
        ### UNIT CONVERSION ###
        ConversionRate, StandardUnit = unitFactorCalculator(ureg, standard_units, val_unit)
        ### UNIT CONVERSION ###
        
        self.{{attrName}} = self.设备信息.{{attrName}}[0] * ConversionRate
        """
        单位: 标准单位 <- 现用单位
        """
        UnitsDict.update(dict({{attrName}}= str(StandardUnit)))
        {% endfor%}

        self.Units = _Units.parse_obj(UnitsDict)
    {% else%}
        {% error("Unknown special class:", k)%}
    {% endif%}
    
    def constraints_register(self):
        super().constraints_register()
    {% if k == "load_class"%}
        {% if v in ['电'] %}
            {% set port_name = '电接口' %}
        {% else %}
            {% error("未知负荷类型:",class_name) %}
        {% endif %}
        getTimeInDay = lambda index: index if self.计算参数.计算步长 == '小时' else self.计算参数.分时计价开始时间点 + (index/3600)

        self.IncomeRates = [self.PriceModel.getFee(power, getTimeInDay(index)) for index, power in enumerate(self.{{port_name}})] # positive?

        self.RangeConstraint(self.{{port_name}}, self.设备信息.EnergyConsumption, lambda x,y: x == -y)

        年化费用 = -(sum(self.IncomeRates)/len(self.IncomeRates)) * 8760
        # 根据年化费用反算

        {# 计价模型 #}
    {% elif k == "input_class"%}
        {% if class_name in ['柴油']%}
        平均消耗率 = self.SumRange(self.燃料接口) / self.计算参数.迭代步数
        {% else%}
            {% error('未知能源类型:', class_name)%}
        {% endif%}

        年化费用 = 平均消耗率 * self.Price * 8760 

    {% else%}
        {% error("未知特殊类型:", k)%}
    {% endif%}
        self.总成本年化 = 年化费用
        return 年化费用

{% endfor %}
{% endfor %}

class ModelWrapperContext:
    def __init__(self):
        mw = ModelWrapper()
        self.mw = mw

    def __enter__(self):
        print("ENTER MODEL WRAPPER CONTEXT")
        return self.mw

    def __exit__(self, exc_type, exc_value, exc_traceback):
        # we don't have to take care of this.
        if exc_type == None:
            print("NO ERROR IN MODEL WRAPPER CONTEXT")
        else:
            print("ERROR IN MODEL WRAPPER CONTEXT")
        del self.mw.model
        del self.mw
        print("EXITING MODEL WRAPPER CONTEXT")

{% for e in ["Inst", "ID", 'Info'] %}
{% set class_types = {}%}
{% set type_suffix = ("模型" if e == "Inst" else ("信息" if e == 'Info' else e)) %}
{% for class_name in 设备接口集合.keys() %}
{% do class_types.update({class_name:class_name+type_suffix}) %}
{% endfor %}
dev{{e}}ClassMap : Dict[str, {{"设备"+type_suffix if type_suffix != "信息" else "BaseModel"}}]= {
    {% for class_name in 设备接口集合.keys() %}
    "{{class_name}}": {{class_types[class_name]}},
    {% endfor %}
} # type: ignore

{% endfor %}


{% macro iterate_input_output_limit(io_type, attr)%}
                # IO TYPE: {{io_type}}
                m_limit_list = []
                for m_id in {{io_type}}_indexs:
                    m_anchor = G.nodes[m_id]
                    m_node_id = m_anchor['device_id']
                    m_devInst = devInstDict[m_node_id]
                    m_limit_list.append(m_devInst.{{attr}})
                {{io_type}}_limit = {{- sum_reduce('m_limit_list') }}
{% endmacro %}

class 仿真结果(BaseModel):
    {% for chineseName, englishName in frontend_translation_table.items()%}
    {% if chineseName in ['元件名称', '设备型号']%}
        {% set mtype = 'str'%}
    {% elif chineseName in ["设备台数"]%}
        {% set mtype = 'int'%}
    {% else %}
        {% set mtype  = 'float'%}
    {% endif%}
    {{englishName}} : {{mtype if mtype !='int' else 'float'}} = Field(title = "{{chineseName}}")
    {% if mtype in ['int', 'float']%}

    @validator('{{englishName}}')
    def convert_number_{{englishName}}(cls, v):
        try: 
            val = int(v)
        except:
            val = 0
        {%if mtype == 'int'%}
        return val
        {% else %}
        return val if val == 0 else v
        {% endif%}
    {% endif%}

    {% endfor %}

class 节点基类(BaseModel):
    type:str = Field(title = "节点类型")
    subtype:str = Field(title = "节点次类型")
    id:int = Field(title = "节点ID")

class 锚点节点(节点基类):
    port_name:str = Field(title = '锚点名称')
    device_id:int = Field(title = '锚点所对应设备ID')
    
class 母线节点(节点基类):
    conn: List[str]  = Field(title = '母线连接线类型列表', description = '包括连接到母线上的连接线和合并线类型')# connection/merge types to literal.

class 设备接口映射(BaseModel):
    subtype: str = Field(title = "接口类型")
    id: int = Field(title = "接口ID", description = "拓扑图上与设备、母线、连接线的ID相比较具有唯一性的ID")

{% set infoClassList = []%}
{% for class_name in 设备接口集合.keys() %}
    {% do infoClassList.append(class_name+"信息")%}
{% endfor %}
class 设备节点(节点基类):
    ports:Dict[str,设备接口映射] = Field(title = "设备接口映射", description = "描述设备所对应接口的类型和接口ID")
    param:Union[{{",".join(infoClassList)}}] = Field(title = '设备信息', description = "不同设备有不同的信息格式")

class mDict(BaseModel):
    directed:bool=Field(default = False, title='保留字段')
    multigraph:bool=Field(default = False, title='保留字段')
    graph:计算参数 = Field(
        title="能流拓扑图的附加属性",
        description="仿真和优化所需的模型参数字典", example = {
            "计算步长": "小时",
            "典型日": False,
            "典型日代表的日期": [],
            "计算类型": "设计规划",
            "风速": [], "光照":[],"气温":[] ,"年利率":0.1})
    nodes:List[Union[锚点节点,设备节点,母线节点,节点基类]] = Field(
        title="节点",
        description="由所有节点ID和属性字典组成的列表", example =[ {
                "type": "锚点",
                "port_name": "电接口",
                "subtype": "供电端输出",
                "device_id": 2,
                "id": 3
            }])
    links:List[Dict[Union[Literal['source'],Literal['target']], int]] = Field(
        title="边",
        description="由能流图中节点互相连接的边组成的列表", example = [
            {
                "source": 0,
                "target": 1
            },
            {
                "source": 1,
                "target": 31
            }])

class EnergyFlowGraph(BaseModel):
    mDictList: List[mDict]

from networkx import Graph

# partial if typical day mode is on.
def compute(devs:List[dict], adders:Dict[int,dict], graph_data:dict, G: Graph, mw: ModelWrapper):
    PD = {}
    algoParam = 计算参数.parse_obj(graph_data)

    devInstDict = {}

    for dev in devs:
        devSubtype = dev['subtype']
        {# devParam = {k:v for k,v in dev.items() if k not in {"subtype","type","ports"} } #}
        devParam = dev['param']
        devPorts = dev['ports']

        devID_int = dev['id']

        devIDClass = devIDClassMap[devSubtype]

        devIDInstInit = {"ID": devID_int}
        for port_name, port_info in devPorts.items():
            port_id = port_info['id']
            devIDInstInit.update({port_name:port_id})
        devIDInst = devIDClass.parse_obj(devIDInstInit)

        devInfoInstInit = devParam
        devInfoClass = devInfoClassMap[devSubtype]
        devInfoInst = devInfoClass.parse_obj(devInfoInstInit)

        devInstClass = devInstClassMap[devSubtype]
        devInst = devInstClass(PD = PD, mw=mw, 计算参数实例=algoParam, 设备ID= devIDInst, 设备信息=devInfoInst) # type: ignore

        devInstDict.update({ devID_int: devInst})
    for adder_index, adder in adders.items():
        input_indexs, output_indexs, io_indexs = adder['input'], adder['output'], adder['IO']

        # fill in missing params
        if len(input_indexs) >= 1:
            if G.nodes[input_indexs[0]]['subtype'] == "柴油输出":
                assert len(input_indexs) == 1, "柴油元件只能一对多连接"
                diesel_node_id = G.nodes[input_indexs[0]]['device_id']
                {# 热值 = devInstDict[diesel_node_id].设备信息.热值 #}
                热值 = devInstDict[diesel_node_id].热值
                for output_index in output_indexs:
                    output_node_index = G.nodes[output_index]['device_id']
                    devInstDict[output_node_index].燃料热值 = 热值

        # add them all.
        for j in range(algoParam.迭代步数):
            seqsum = {{- sum_reduce('[PD[i][j] for i in input_indexs + output_indexs + io_indexs]') }}

            mw.Constraint(seqsum >=0)
        
        if algoParam.计算类型 == '设计规划':
            cnt = 0
            if len(input_indexs)==0:
                continue
            input_anchor_0 = G.nodes[input_indexs[0]]
            if input_anchor_0['subtype'] == '变压器输出':
                print(f"Building Converter Constraint #{cnt}")
                cnt+=1
                assert io_indexs == []

{{ iterate_input_output_limit("input","最大允许的负载总功率") }}

{{ iterate_input_output_limit("output","MaxEnergyConsumption") }}

                mw.Constraint(input_limit + output_limit >= 0)

    financial_obj_expr = {{- sum_reduce('[e.constraints_register() for e in devInstDict.values()]') }}

    financial_dyn_obj_expr = sum([(e.总可变维护成本年化) for e in devInstDict.values()])

    environment_obj_exprs = [] # annual CO2 emission
    
    for e in devInstDict.values():
        if type(e) == 柴油模型:
            environment_obj_exprs.append((sum(e.燃料接口)/e.计算参数.迭代步数)*8760 * e.CO2 )

    environment_obj_expr = sum(environment_obj_exprs)
    
    obj_exprs = (financial_obj_expr,
                financial_dyn_obj_expr,
                environment_obj_expr,
)
    return obj_exprs, devInstDict, PD
    # always minimize the objective.

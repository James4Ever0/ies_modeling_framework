# TODO: å…¸å‹æ—¥ æœ€ç»ˆè¾“å‡ºç»“æœéœ€è¦å±•å¼€ä¸º8760
from typing import Dict, List, Union
try:
    from typing import Literal
except:
    from typing_extensions import Literal
    
import rich
from pydantic import BaseModel
# the main code for computing.
# currently just compute microgrid
# three computation modes:
{# from functools import lru_cache #}

{% set load_types = ['ç”µ']%}
{% set load_class_names = []%}
{% for load_type in load_types%}
{% do load_class_names.append(load_type+"è´Ÿè·")%}
{% endfor%}
{% set input_types = ['æŸ´æ²¹'] %}

{% macro sum_reduce(seq)%}
 sum({{seq}})
{# functools.reduce(sequence={{seq}}, function = lambda x,y: x+y) #}
{% endmacro%}

{% macro init_super_class(class_name)%}
    def __init__(self, PD:dict, mw: ModelWrapper, è®¡ç®—å‚æ•°å®ä¾‹: è®¡ç®—å‚æ•°, è®¾å¤‡ID: {{ class_name }}ID, è®¾å¤‡ä¿¡æ¯: {{ class_name }}ä¿¡æ¯):
        super().__init__(PD=PD, mw=mw, è®¡ç®—å‚æ•°å®ä¾‹=è®¡ç®—å‚æ•°å®ä¾‹, ID = è®¾å¤‡ID.ID)
        self.è®¾å¤‡ID = è®¾å¤‡ID
        self.è®¾å¤‡ä¿¡æ¯ = è®¾å¤‡ä¿¡æ¯
{% endmacro %}

{%macro port_variable_define(class_name)%}
        ##### PORT VARIABLE DEFINITION ####

        self.ports = {}
        
        {% for port_name, port_type in è®¾å¤‡æ¥å£é›†åˆ[class_name] %}
        {% if port_type.endswith("è¾“å…¥è¾“å‡º") %}
        {% set mt = "Reals" %}
        {% elif port_type.endswith("è¾“å…¥") %}
        {% set mt = "NegativeReals"%}
        {% elif port_type.endswith("è¾“å‡º") %}
        {% set mt = "NonNegativeReals"%}
        {% endif %}
        self.PD[self.è®¾å¤‡ID.{{port_name}}] = self.ports['{{port_name}}'] = self.{{port_name}} = self.å˜é‡åˆ—è¡¨("{{port_name}}", within={{mt}})
        """
        ç±»å‹: {{port_type}}
        """


        {% endfor %}
{% endmacro %}

{%macro expand_unit_conversion(mdigit, exceptionList=[])%}
        {% if mdigit[4] == 1 or mdigit[0] in exceptionList%}
        self.{{ mdigit[0] }}: float = è®¾å¤‡ä¿¡æ¯.{{ mdigit[0] }}
        """
        åç§°: {{ mdigit[1] }}
        å•ä½: {{ mdigit[2] }}
        """
        {%else%}
        self.{{ mdigit[0] }}: float = è®¾å¤‡ä¿¡æ¯.{{ mdigit[0] }} * {{ mdigit[4]}}
        """
        åç§°: {{ mdigit[1] }}
        å•ä½: {{ mdigit[3] }} <- {{ mdigit[2] }}
        """
        {% endif %}
        assert self.{{ mdigit[0] }} >=0
{%endmacro%}


{% set æ—¶é—´æ­¥é•¿å‚æ•°='self.è®¡ç®—å‚æ•°.æ—¶é—´å‚æ•°'%}
{# {% set æ—¶é—´æ­¥é•¿å‚æ•°='self.è®¡ç®—å‚æ•°.æ—¶é—´å‚æ•°()'%} #}
{# {% set æ—¶é—´æ­¥é•¿å‚æ•°='(1 if self.è®¡ç®—å‚æ•°.è®¡ç®—æ­¥é•¿ == "å°æ—¶" else 3600)'%} #}

{% set å•å‘å˜ç”µå™¨åˆ—è¡¨ = ['å˜å‹å™¨', 'å˜æµå™¨']%}

{%set è®¾å¤‡å‚æ•°ä¾‹å¤–åˆ—è¡¨ = ["PowerDeltaLimit", "RatedWindSpeed", "MaxWindSpeed", "MinWindSpeed", "BatteryDeltaLimit", "BatteryStorageDecay", 'BatteryDeltaLimit']%}
# 8760 hours of data
# several days of data to compute a year

# 7200 seconds. simulation

# device parameters would be the same.

# load and environment might change.

# so for every device the will change.

# iterate through all device-port pairs, then retrieve attributes from another dict.

# string, digits, tables.
# you can dump and load from json.
{# 
class åŠ æ³•å™¨ID(BaseModel):
    è¾“å…¥:int
    è¾“å‡º:int
    è¾“å…¥è¾“å‡º: int #}

{# {% for super_class, class_name, mstrs, mdigits, mtables in è®¾å¤‡åº“ %} #}

#############
# Device ID #
#############

class è®¾å¤‡ID(BaseModel):
    ID: int

{% for class_name in è®¾å¤‡æ¥å£é›†åˆ.keys()%}

class {{class_name}}ID(è®¾å¤‡ID):
    {% for port_name, port_type in è®¾å¤‡æ¥å£é›†åˆ[class_name]%}
    {{ port_name }}: int
    """
    ç±»å‹: {{ port_type }}
    """
    {% endfor %}

{% endfor %}

###############
# Device Info #
###############

{% set NonLoadDeviceDict = {}%}
{% for super_class, class_name, mstrs, mdigits, mtables in è®¾å¤‡åº“ %}
{% do NonLoadDeviceDict.update({class_name: (super_class, mstrs, mdigits, mtables)})%}
{% endfor %}
{% for class_name in è®¾å¤‡æ¥å£é›†åˆ.keys()%}

class {{class_name}}ä¿¡æ¯(BaseModel):
    {% if class_name not in NonLoadDeviceDict.keys() %}
    {% if class_name in load_class_names%}
    # æ­£æ•°
    EnergyConsumption: List[float]
    """
    å•ä½: kW
    {# In this way it will be timescale independent. #}
    """

    MaxEnergyConsumption: Union[None, float] = None
    """
    å•ä½: kW
    {# ç”¨äºç”µè´Ÿè· å…¸å‹æ—¥è®¡ç®— #}
    """
    {% else %}
    Price: float
    {% if class_name == "æŸ´æ²¹"%}
    {% set m1="L/ä¸‡å…ƒ"%}
    {# just to make it standard. #}
    {% else%}
    {% error("æœªçŸ¥è´Ÿè·ä¿¡æ¯ç±»å‹:", class_name)%}
    {% endif%}
    Unit: str
    DefaultUnit: str = "{{m1}}"
    {% endif%}
    {% else %}
    {% set super_class, mstrs, mdigits, mtables = NonLoadDeviceDict[class_name] %}
    {% for psc, mstr in mstrs %}
    {{ mstr }}: str

    {% endfor %}
    
    {% for psc, mdigit in mdigits %}
    {{ mdigit[0] }}: float
    """
    åç§°: {{ mdigit[1]}}
    å•ä½: {{mdigit[2]}}
    """

    {% endfor %}

    {% for psc, main, sub in mtables %}
    {% set mtable=(main, sub)%}
    {{ mtable[0][0]}}_{{ mtable[1][0]}} : List[List[float]]
    """
    {{ mtable[0][0]}}: {{ mtable[0][1]}}
    å•ä½: {{ mtable[0][2]}}

    {{ mtable[1][0]}}: {{ mtable[1][1]}}
    å•ä½: {{ mtable[1][2]}}
    """

    {% endfor %}
    {% endif %}
{% endfor %}

####################
# model definition #
####################

from pyomo.environ import *

class ModelWrapper:
    def __init__(self):
        self.model = ConcreteModel()
        self.clock = {}
    def getSpecialName(self, key:str):
        val = self.clock.get(key,0)
        name = f"{key}_{val}"
        self.clock[key] = val+1
        return name
    {% for k in ['Constraint', 'Var','Objective']%}
    {% set mv = "*args, **kwargs"%}
    def {{k}}(self, {{ "name:str," if k == "Var" else ""}} {{ mv}}):
        {% if k !="Var" %}
        expr = kwargs.pop('expr',args[0] if len(args) >0 else None)
        if expr is None:
            print("ARGS:", args)
            print("KWARGS:", kwargs)
            raise Exception("Not passing expression to method '{{k}}'")
        deg = expr.polynomial_degree()
        if deg != 1:
            print("EXPR DEG:", deg)
            raise Exception(f"{{k}}: Unacceptable polynomial degree for expression '{str(expr)}'")
        name = self.getSpecialName("{{k[:3].upper()}}")
        {% endif %}
        ret = {{k}}({{mv if k == "Var" else "expr = expr, *args[1:], **kwargs"}})
        self.model.__setattr__(name, ret)
        return ret
    {% endfor%}


# first convert the unit.
# assign variables.

# shall you assign port with variables.

# é£ã€å…‰ç…§

# éœ€è¦å•ä½æ˜ç¡®
class è®¡ç®—å‚æ•°(BaseModel):
    å…¸å‹æ—¥ID: Union[int, None] = None
    è®¡ç®—æ­¥é•¿: Union[Literal["å°æ—¶"], Literal['ç§’']]
    å…¸å‹æ—¥: bool
    è®¡ç®—ç±»å‹: Union[Literal['ä»¿çœŸæ¨¡æ‹Ÿ'],Literal['è®¾è®¡è§„åˆ’']]
    é£é€Ÿ: List[float]
    """
    å•ä½: m/s
    """
    å…‰ç…§: List[float]
    """
    å•ä½: kW/m2
    """
    æ°”æ¸©: List[float]
    """
    å•ä½: æ‘„æ°åº¦
    """
    å¹´åˆ©ç‡: float
    """
    å•ä½: percent
    """
    @property
    def è¿­ä»£æ­¥æ•°(self):
        {# steps = None #}
        if self.è®¡ç®—æ­¥é•¿ == "ç§’":
            steps = 7200
        elif self.è®¡ç®—æ­¥é•¿ == "å°æ—¶" and self.å…¸å‹æ—¥ is False:
            steps = 8760
        elif self.è®¡ç®—æ­¥é•¿ == "å°æ—¶" and self.å…¸å‹æ—¥ is True:
            steps = 24
        else:
            rich.print(self)
            raise Exception("æœªçŸ¥è®¡ç®—å‚æ•°")
        assert len(self.é£é€Ÿ) == steps
        assert len(self.å…‰ç…§) == steps
        assert len(self.æ°”æ¸©) == steps
        return steps
    
    {# @lru_cache(maxsize=1) #}
    @property
    def æ—¶é—´å‚æ•°(self):
        return (1 if self.è®¡ç®—æ­¥é•¿ == "å°æ—¶" else 3600)
    {# @property # æå‰è®¡ç®—å¥½äº†
    def å…¸å‹æ—¥åˆ—è¡¨(self): # 
        ... #}
    {# # like: (tday_index, tday_data, tday_count) #}

class POSNEG:
    def __init__(self, x, x_pos, x_neg, b_pos, b_neg, x_abs):
        {%for f in ["x", "x_pos", "x_neg", "b_pos", "b_neg", "x_abs"]%}
        self.{{f}} = {{f}}
        {%endfor%}

{# from functools import reduce #}
{# import functools #}
class è®¾å¤‡æ¨¡å‹:
    def __init__(self, PD: dict, mw: ModelWrapper, è®¡ç®—å‚æ•°å®ä¾‹: è®¡ç®—å‚æ•°, ID):
        print("Building Device Model:", self.__class__.__name__)
        self.mw = mw
        self.PD = PD
        self.è®¡ç®—å‚æ•° = è®¡ç®—å‚æ•°å®ä¾‹
        self.ID = ID
        self.SID = 0
        self.BigM = 1e+20
        """
        ä¸€ä¸ªæå¤§æ•°
        """
        self.EPS = 1e-4
        """
        ä¸€ä¸ªæå°æ•°
        """
    
    def constraints_register(self):
        print("REGISTERING: ", self.__class__.__name__)
        {# raise NotImplementedError("Must be implemented by subclasses.") #}

    def getVarName(self, varName: str):
        VN = f"DI_{self.ID}_VN_{varName}" # use underscore.
        if self.è®¡ç®—å‚æ•°.å…¸å‹æ—¥ID:
            VN = f"TD_{self.è®¡ç®—å‚æ•°.å…¸å‹æ—¥ID}_"+VN
        return VN
    
    def getSpecialVarName(self, varName:str):
        specialVarName = f"SP_{self.SID}_{varName}"
        self.SID +=1
        return specialVarName

    def å•å˜é‡(self, varName: str, **kwargs):
        var = self.mw.Var(self.getVarName(varName) ,**kwargs)
        return var

    def å˜é‡åˆ—è¡¨(self, varName: str,**kwargs):
        var = self.mw.Var(self.getVarName(varName) ,range(self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°), **kwargs)
        return var

    def RangeConstraint(self,var_1, var_2, expression):
        for i in range(self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°):
            self.mw.Constraint(expression(var_1[i], var_2[i]))

    def RangeConstraintMulti(self, *vars, expression=...): # keyword argument now.
        assert expression is not ...
        for i in range(self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°):
            self.mw.Constraint(expression(*[var[i] for var in vars]))

    def CustomRangeConstraint(self, var_1, var_2, customRange:range, expression):
        for i in customRange:
            self.mw.Constraint(expression(var_1, var_2, i))
    
    def CustomRangeConstraintMulti(self, *vars, customRange:range=..., expression=...):
        assert expression is not ...
        assert customRange is not ...
        for i in customRange:
            self.mw.Constraint(expression(*vars, i))
    
    def SumRange(self,var_1):
        return {{- sum_reduce('[var_1[i] for i in range(self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°)]')}}
    
    def å•å˜é‡è½¬åˆ—è¡¨(self, var, dup=None):
        if dup is None:
            dup = self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°
        return [var for _ in range(dup)]
    
    def å˜é‡åˆ—è¡¨_å¸¦æŒ‡ç¤ºå˜é‡(self, varName:str, within = Reals) -> POSNEG:
        x = self.å˜é‡åˆ—è¡¨(varName,within=within )

        {% for flag in ['pos', 'neg']%}
        b_{{flag}} = self.å˜é‡åˆ—è¡¨(self.getSpecialVarName(varName), within = Boolean)
        x_{{flag}} = self.å˜é‡åˆ—è¡¨(self.getSpecialVarName(varName), within = NonNegativeReals)

        self.RangeConstraint(b_{{flag}}, x_{{flag}}, lambda x,y: x*self.BigM >= y)
        {%endfor%}

        self.RangeConstraint(b_pos, b_neg, lambda x,y: x+y == 1)

        self.RangeConstraintMulti(x, x_pos, x_neg, expression = lambda x,y,z: x == y-z )

        x_abs = self.å˜é‡åˆ—è¡¨(self.getSpecialVarName(varName), within = NonNegativeReals)

        self.RangeConstraintMulti(x_pos, x_neg, x_abs, expression = lambda x,y,z : z == x+y)

        posneg = POSNEG(x, x_pos, x_neg, b_pos, b_neg, x_abs)

        return posneg
    
    def Piecewise(self, 
        x_var, # x_var
        y_var, # y_var
        x_vals: List[float],
        y_vals: List[float],
     range_list:Union[List[int], None]=None, pw_repn='SOS2', pw_constr_type='EQ', unbounded_domain_var=True):
        if range_list is None:
            range_list = list(range(self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°))
        PWL = []
        for i in range_list:
            piecewise_name = self.getSpecialVarName("PW")
            PW = Piecewise(
            y_var[i],
            x_var[i],
            pw_pts=x_vals,
            f_rule=y_vals,
            pw_repn=pw_repn,
            pw_constr_type=pw_constr_type,
            unbounded_domain_var=unbounded_domain_var,
            warn_domain_coverage=False, # to suppress warning
        )
            self.mw.model.__setattr__(piecewise_name, PW)
            PWL.append(PW)
        return PWL
    
    def BinVarMultiplySingle(self, b_var, x_var):
        h = self.å•å˜é‡()
        â„â‰¤b_varğ‘€â‰¥âˆ’ğ‘ğ‘€â‰¤ğ‘¦+(1âˆ’ğ‘)ğ‘€â‰¥ğ‘¦âˆ’(1âˆ’ğ‘)ğ‘€(1)(2)(3)(4)

    def Multiply(self,dict_mx:dict, dict_my:dict, varName:str, precision = 10, within = Reals): # two continuous multiplication
        #  (x+y)^2 - (x-y)^2 = 4xy
        mx, max_mx, min_mx = dict_mx['var'], dict_mx['max'], dict_mx['min']
        my, max_my, min_my = dict_my['var'], dict_my['max'], dict_my['min']

        m1posneg = self.å˜é‡åˆ—è¡¨_å¸¦æŒ‡ç¤ºå˜é‡(self.getSpecialVarName(varName))
        self.RangeConstraintMulti(m1posneg.x, mx, my , expression = lambda x,y,z: x == y+z)
        mx_my_sum_var = m1posneg.x_abs
        mx_my_sum_pow2_var = self.å˜é‡åˆ—è¡¨(self.getSpecialVarName(varName))

        m2posneg = self.å˜é‡åˆ—è¡¨_å¸¦æŒ‡ç¤ºå˜é‡(self.getSpecialVarName(varName))
        self.RangeConstraintMulti(m2posneg.x, mx, my, expression = lambda x,y,z: x == y-z)
        mx_my_minus_var = m2posneg.x_abs
        mx_my_minus_pow2_var = self.å˜é‡åˆ—è¡¨(self.getSpecialVarName(varName))

        l0, r0 = min_mx + min_my, max_mx+max_my
        l1, r1 = min_mx - max_my, max_mx-min_my
        def getBound(l0, r0):
            if l0*r0 >=0:
                l0,r0 = abs(l0), abs(r0)
                l, r = min([l0, r0]), max([l0, r0])
            else:
                l0, r0 = abs(l0), abs(r0)
                l, r = 0, max([l0, r0])
            return l, r

        mx_my_sum = np.linspace(*getBound(l0, r0), precision).tolist()

        mx_my_sum_pow2 = [x**2 for x in mx_my_sum]

        mx_my_minus = np.linspace(*getBound(l1, r1), precision).tolist()

        mx_my_minus_pow2 = [x**2 for x in mx_my_minus]

        self.Piecewise(x_var = mx_my_sum_var, y_var = mx_my_sum_pow2_var, x_vals = mx_my_sum, y_vals = mx_my_sum_pow2) # assume it is absolute.

        self.Piecewise(x_var = mx_my_minus_var, y_var = mx_my_minus_pow2_var, x_vals = mx_my_minus, y_vals = mx_my_minus_pow2)

        mx_my_multiply = self.å˜é‡åˆ—è¡¨(varName, within=within)

        self.RangeConstraintMulti(mx_my_sum_pow2_var, mx_my_minus_pow2_var, mx_my_multiply, expression =  lambda x,y,z:(x-y)/4 == z)

        return mx_my_multiply

# input: negative
# output: positive
# IO: Real
import numpy as np
import math

{% for super_class, class_name, mstrs, mdigits, mtables in è®¾å¤‡åº“ %}

class {{class_name}}æ¨¡å‹(è®¾å¤‡æ¨¡å‹):
{{ init_super_class(class_name)}}

        {% set mflag = namespace(val="")%}
        {% for psc, mdigit in mdigits %}
        {% if psc in ["ä»¿çœŸæ¨¡æ‹Ÿ","è®¾è®¡è§„åˆ’"] %}
        {# # psc: {{psc}} mflag: {{mflag}} #}
        {% if mflag.val != psc %}
        {% set mflag.val = psc%}
        {# # after: psc: {{psc}} mflag: {{mflag}} #}
        if self.è®¡ç®—å‚æ•°.è®¡ç®—ç±»å‹ == "{{psc}}":
        {% if psc == "è®¾è®¡è§„åˆ’" %}
            self.DeviceCount = self.å•å˜é‡('DeviceCount', within=NonNegativeIntegers) # type: ignore
            """
            å•ä½ï¼š ä¸ª
            """

        {% endif %}
        {%endif%}
{{expand_unit_conversion(mdigit) | indent(4, True)}}
        {# {{expand_unit_conversion(mdigit) | indent(4, True)}} #}
        {% else %}
{{expand_unit_conversion(mdigit,è®¾å¤‡å‚æ•°ä¾‹å¤–åˆ—è¡¨) }}
        {% endif %}
        {% endfor %}
        {# {%endwith%} #}

        {% for psc, main, sub in mtables %}
        {% set mtable=(main, sub)%}
        self.{{ mtable[0][0]}}_{{ mtable[1][0]}} : List[List[float]] = [[v1 * {{mtable[0][4]}}, v2 * {{mtable[1][4]}}] for v1, v2 in è®¾å¤‡ä¿¡æ¯.{{ mtable[0][0]}}_{{ mtable[1][0]}}]
        self.{{ mtable[0][0]}}_{{ mtable[1][0]}}.sort(key=lambda x: x[1])
        """
        {{ mtable[0][0]}}: {{ mtable[0][1]}}
        å•ä½: {{ mtable[0][3]}} <- {{ mtable[0][2]}}

        {{ mtable[1][0]}}: {{ mtable[1][1]}}
        å•ä½: {{ mtable[1][3]}} <- {{ mtable[1][2]}}
        """

        {% endfor %}

{{ port_variable_define(class_name)}}
        
        # è®¾å¤‡ç‰¹æœ‰çº¦æŸï¼ˆå˜é‡ï¼‰
        {% if class_name in ['å…‰ä¼å‘ç”µ','é£åŠ›å‘ç”µ','æŸ´æ²¹å‘ç”µ']%}
        self.ç”µè¾“å‡º = self.ç”µæ¥å£
        {% if class_name in ["æŸ´æ²¹å‘ç”µ"]%}
        self.æŸ´æ²¹è¾“å…¥ = self.ç‡ƒæ–™æ¥å£
        {% endif%}
        {% endif%}

        {% if class_name in ['å˜å‹å™¨']%}
        if self.è®¡ç®—å‚æ•°.è®¡ç®—ç±»å‹ == "è®¾è®¡è§„åˆ’": # åœ¨å˜å‹å™¨å’Œè´Ÿè·çš„äº¤æ¢èŠ‚ç‚¹å¤„åšå¤„ç†
            self.æœ€å¤§å…è®¸çš„è´Ÿè½½æ€»åŠŸç‡ = self.DeviceCount*(self.RatedPower*self.Efficiency)*self.PowerParameter/self.LoadRedundancyParameter # type: ignore
        {% endif%}
        {% if class_name in ['å…‰ä¼å‘ç”µ']%}
        if self.è®¡ç®—å‚æ•°.è®¡ç®—ç±»å‹ == "è®¾è®¡è§„åˆ’":
            self.MaxDeviceCount = math.floor(self.MaxInstallArea/self.Area)
            self.MinDeviceCount = math.ceil(self.MinInstallArea/self.Area)
            assert self.MinDeviceCount>=0
            assert self.MaxDeviceCount>=self.MinDeviceCount
        {% elif class_name == "æŸ´æ²¹å‘ç”µ" %}
        self.ç”µåŠŸç‡ä¸­è½¬ = self.å˜é‡åˆ—è¡¨_å¸¦æŒ‡ç¤ºå˜é‡("ç”µåŠŸç‡ä¸­è½¬")
        
        self.å•å°å‘ç”µåŠŸç‡ = self.å˜é‡åˆ—è¡¨("å•å°å‘ç”µåŠŸç‡", within=NonNegativeReals)
        self.å•å°æŸ´æ²¹è¾“å…¥ = self.å˜é‡åˆ—è¡¨("å•å°æŸ´æ²¹è¾“å…¥", within=NonPositiveReals)

        if self.è®¡ç®—å‚æ•°.è®¡ç®—ç±»å‹ == "è®¾è®¡è§„åˆ’":
            self.æœ€å¤§æ²¹è€—ç‡ = max([x[0] for x in self.DieselToPower_Load])

            self.åŸç”µè¾“å‡º = self.Multiply(dict(var=self.å•å°å‘ç”µåŠŸç‡,max=self.RatedPower, min=0), dict(var=self.å•å˜é‡è½¬åˆ—è¡¨(self.DeviceCount),max=self.MaxDeviceCount, min=self.MinDeviceCount), "åŸç”µè¾“å‡º", within = NonNegativeReals)

            self.æŸ´æ²¹è¾“å…¥_ = self.Multiply(dict(var=self.å•å°æŸ´æ²¹è¾“å…¥, max=0, min=-self.RatedPower*self.æœ€å¤§æ²¹è€—ç‡), dict(var=self.å•å˜é‡è½¬åˆ—è¡¨(self.DeviceCount),max=self.MaxDeviceCount, min=self.MinDeviceCount), "æŸ´æ²¹è¾“å…¥_", within = NonPositiveReals)
            self.RangeConstraint(self.æŸ´æ²¹è¾“å…¥_, self.æŸ´æ²¹è¾“å…¥, lambda x,y: x == y)
        else:
            self.åŸç”µè¾“å‡º = self.å˜é‡åˆ—è¡¨("åŸç”µè¾“å‡º",within = NonNegativeReals)
            self.RangeConstraint(self.åŸç”µè¾“å‡º ,self.å•å°å‘ç”µåŠŸç‡, lambda x,y: x == y*self.DeviceCount)
        {% elif class_name  == 'é”‚ç”µæ± ' %}
        if self.è®¡ç®—å‚æ•°.è®¡ç®—ç±»å‹ == "è®¾è®¡è§„åˆ’":
            #  åˆå§‹SOC
            assert self.InitSOC >= self.MinSOC
            assert self.InitSOC <= self.MaxSOC
            self.InitActualCapacityPerUnit = (self.InitSOC - self.MinSOC) * self.RatedCapacity

            self.MaxDeviceCount = math.floor(self.MaxTotalCapacity / self.RatedCapacity)
            self.MinDeviceCount = math.ceil(self.MinTotalCapacity / self.RatedCapacity)

        assert self.MaxSOC >=self.MinSOC
        assert self.MaxSOC <= 1
        assert self.MinSOC >= 0

        self.åŸç”µæ¥å£ = self.å˜é‡åˆ—è¡¨_å¸¦æŒ‡ç¤ºå˜é‡("åŸç”µæ¥å£") # æ­£ æ”¾ç”µ è´Ÿ å……ç”µ

        self.ActualCapacityPerUnit = self.RatedCapacity * (self.MaxSOC - self.MinSOC)

        self.CurrentTotalActualCapacity = self.å˜é‡åˆ—è¡¨('CurrentTotalActualCapacity', within=NonNegativeReals)

        self.TotalCapacity = self.DeviceCount * self.RatedCapacity # type: ignore

        self.TotalActualCapacity = self.DeviceCount * self.ActualCapacityPerUnit # type: ignore

        self.MaxTotalCapacityDeltaPerStep = self.BatteryDeltaLimit * self.TotalCapacity / ({{æ—¶é—´æ­¥é•¿å‚æ•°}})
        """
        å•ä½: kWh
        """

        self.TotalStorageDecayRate = (self.BatteryStorageDecay / 100) * self.TotalCapacity
        """
        å•ä½: kW
        """

        {%elif class_name in ['åŒå‘å˜æµå™¨']%}
        self.çº¿è·¯ç«¯_ = self.å˜é‡åˆ—è¡¨_å¸¦æŒ‡ç¤ºå˜é‡("çº¿è·¯ç«¯_") 
        self.å‚¨èƒ½ç«¯_ = self.å˜é‡åˆ—è¡¨_å¸¦æŒ‡ç¤ºå˜é‡("å‚¨èƒ½ç«¯_")
        {% elif class_name in ['ä¼ è¾“çº¿']%}
        self.ç”µè¾“å…¥_å»é™¤æŸè€— = self.å˜é‡åˆ—è¡¨_å¸¦æŒ‡ç¤ºå˜é‡('ç”µè¾“å…¥_å»é™¤æŸè€—') 
        {%endif%}

    def constraints_register(self):
        super().constraints_register()
        # è®¾å¤‡ç‰¹æœ‰çº¦æŸï¼ˆéå˜é‡ï¼‰
        {% if class_name == "é£åŠ›å‘ç”µ" %}
        # define a single-variate piecewise function
        # 
        #         ____
        #        /    |
        #       /     | ax^3
        #  ----/      |______
        #
        assert self.RatedWindSpeed >=self.MinWindSpeed
        assert self.MaxWindSpeed >=self.RatedWindSpeed

        å‘ç”µæ›²çº¿å‚æ•° = self.RatedPower / ( (self.RatedWindSpeed - self.MinWindSpeed) ** 3)

        # windspeed (m/s) -> current power per device (kW)
        WS = np.array(self.è®¡ç®—å‚æ•°.é£é€Ÿ)
        å•å°å‘ç”µåŠŸç‡ = np.piecewise(WS, [WS<=self.MinWindSpeed, WS >self.MinWindSpeed and WS <= self.RatedWindSpeed , WS >self.RatedWindSpeed and WS <=self.MaxWindSpeed, WS > self.MaxWindSpeed], [0,lambda x: å‘ç”µæ›²çº¿å‚æ•° * ((x - self.MinWindSpeed) ** 3),self.RatedPower,0])
        å•å°å‘ç”µåŠŸç‡ = å•å°å‘ç”µåŠŸç‡.tolist()
        {% endif %}

        # è®¾å¤‡å°æ•°çº¦æŸ
        {% if class_name not in ['ä¼ è¾“çº¿'] %}
        if self.è®¡ç®—å‚æ•°.è®¡ç®—ç±»å‹ == "è§„åˆ’è®¾è®¡":
            self.mw.Constraint(self.DeviceCount <= self.MaxDeviceCount)
            self.mw.Constraint(self.DeviceCount >= self.MinDeviceCount)
        {% endif %}
        
        # è¾“å‡ºè¾“å…¥åŠŸç‡çº¦æŸ
        {%if class_name in ['ä¼ è¾“çº¿']%}
        TotalDecayPerStep = self.Length * self.PowerTransferDecay / {{æ—¶é—´æ­¥é•¿å‚æ•°}}
        self.RangeConstraint(self.ç”µè¾“å…¥_å»é™¤æŸè€—.x, self.ç”µè¾“å…¥, lambda x,y: x == y+TotalDecayPerStep )
        self.RangeConstraint(self.ç”µè¾“å…¥_å»é™¤æŸè€—.x_neg, self.ç”µè¾“å‡º,lambda x,y:x == y )
        {%elif class_name in ['åŒå‘å˜æµå™¨']%}

        self.RangeConstraint(self.çº¿è·¯ç«¯_.x , self.çº¿è·¯ç«¯, lambda x,y: x==y)
        self.RangeConstraint(self.å‚¨èƒ½ç«¯_.x , self.å‚¨èƒ½ç«¯, lambda x,y: x==y)

        self.RangeConstraint(self.çº¿è·¯ç«¯_.x_neg, self.å‚¨èƒ½ç«¯_.x_pos,lambda x,y: x == y*self.Efficiency)
        self.RangeConstraint(self.å‚¨èƒ½ç«¯_.x_neg, self.çº¿è·¯ç«¯_.x_pos,lambda x,y: x == y*self.Efficiency)

        {% elif class_name in å•å‘å˜ç”µå™¨åˆ—è¡¨%}
        self.RangeConstraint(self.ç”µè¾“å…¥, self.ç”µè¾“å‡º, lambda x,y: x == -y* self.Efficiency)
        self.RangeConstraintMulti(self.ç”µè¾“å…¥, expression=lambda x: -x<=self.RatedPower * self.DeviceCount)
        {% elif class_name in ['å…‰ä¼å‘ç”µ'] %}
        å…‰ç”µè½¬æ¢æ•ˆç‡ = self.MaxPower / self.Area # 1kW/m2å…‰ç…§ä¸‹èƒ½äº§ç”Ÿçš„èƒ½é‡ çœç•¥é™¤ä»¥1 å•ä½: one
        æ€»æœ€å¤§åŠŸç‡ = self.MaxPower * self.DeviceCount
        æ€»é¢ç§¯ = self.Area * self.DeviceCount

        # å…‰ç…§å¼ºåº¦ * æ€»é¢ç§¯ * å…‰ç”µè½¬æ¢æ•ˆç‡ * ç”µç”µè½¬æ¢æ•ˆç‡
        # (kW/m2) * m2 * one * one -> kW
        self.RangeConstraint(self.è®¡ç®—å‚æ•°.å…‰ç…§, self.ç”µè¾“å‡º, lambda x,y: x*æ€»é¢ç§¯*å…‰ç”µè½¬æ¢æ•ˆç‡*self.PowerConversionEfficiency >= y)

        {% elif class_name in ['é£åŠ›å‘ç”µ'] %}
        self.RangeConstraint(å•å°å‘ç”µåŠŸç‡, self.ç”µè¾“å‡º, lambda x,y: x*self.DeviceCount >= y)

        {% elif class_name in ['æŸ´æ²¹å‘ç”µ'] %}
        æ€»æœ€å°å¯åŠ¨åŠŸç‡ = self.RatedPower * self.PowerStartupLimit * self.DeviceCount
        æ€»æœ€å¤§è¾“å‡ºåŠŸç‡ = self.RatedPower * self.DeviceCount

        self.RangeConstraintMulti(self.å•å°å‘ç”µåŠŸç‡, expression = lambda x: x <= self.RatedPower)
        self.RangeConstraint(self.åŸç”µè¾“å‡º, self.ç”µåŠŸç‡ä¸­è½¬.x ,lambda x,y: x == y + æ€»æœ€å°å¯åŠ¨åŠŸç‡)

        self.Piecewise(y_var = self.å•å°æŸ´æ²¹è¾“å…¥, x_var = self.å•å°å‘ç”µåŠŸç‡, y_vals = [-x[0]*self.RatedPower*x[1] for x in self.DieselToPower_Load], x_vals = [self.RatedPower*x[1] for x in self.DieselToPower_Load])
        # æŸ´æ²¹è¾“å…¥ç‡: L/h

        self.RangeConstraintMulti(self.ç”µåŠŸç‡ä¸­è½¬.x_pos, self.ç”µè¾“å‡º, self.ç”µåŠŸç‡ä¸­è½¬.b_pos, expression = lambda x,y,z: x + æ€»æœ€å°å¯åŠ¨åŠŸç‡*z == y)

        {%elif class_name in ['é”‚ç”µæ± '] %}
        self.RangeConstraintMulti(self.CurrentTotalActualCapacity, expression = lambda x: x <= self.TotalActualCapacity)

        self.mw.Constraint(self.CurrentTotalActualCapacity[0] == self.InitActualCapacityPerUnit * self.DeviceCount)

        self.CustomRangeConstraint( self.åŸç”µæ¥å£.x, self.CurrentTotalActualCapacity, range(self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°-1), lambda x,y,i: x[i] == (y[i] - y[i+1]) * {{æ—¶é—´æ­¥é•¿å‚æ•°}})
        {# power = delta(capacity)/delta(time)#}
        
        self.RangeConstraintMulti(self.åŸç”µæ¥å£.x_pos, self.åŸç”µæ¥å£.x_neg, self.ç”µæ¥å£,expression = lambda x_pos, x_neg, y: x_pos * self.DischargeEfficiency - (x_neg + self.TotalStorageDecayRate)/self.ChargeEfficiency == y)

        for i in range(self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°-1):
            self.mw.Constraint(self.CurrentTotalActualCapacity[i+1] - self.CurrentTotalActualCapacity[i] <=self.MaxTotalCapacityDeltaPerStep)
            self.mw.Constraint(self.CurrentTotalActualCapacity[i+1] - self.CurrentTotalActualCapacity[i] >=-self.MaxTotalCapacityDeltaPerStep)

        if self.è®¡ç®—å‚æ•°.è®¡ç®—ç±»å‹ == "è®¾è®¡è§„åˆ’":
            if self.è®¾å¤‡ä¿¡æ¯.å¾ªç¯è¾¹ç•Œæ¡ä»¶ == 'æ—¥é—´ç‹¬ç«‹':
                self.mw.Constraint(self.åŸç”µæ¥å£.x[0] == self.EPS)
            elif self.è®¾å¤‡ä¿¡æ¯.å¾ªç¯è¾¹ç•Œæ¡ä»¶ == 'æ—¥é—´è¿æ¥':
                self.mw.Constraint(self.CurrentTotalActualCapacity[0] - self.CurrentTotalActualCapacity[self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°-1] <=self.MaxTotalCapacityDeltaPerStep)

                self.mw.Constraint(self.CurrentTotalActualCapacity[0] - self.CurrentTotalActualCapacity[self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°-1] >=-self.MaxTotalCapacityDeltaPerStep)

                self.mw.Constraint(self.åŸç”µæ¥å£.x[0] == (self.CurrentTotalActualCapacity[self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°-1] - self.CurrentTotalActualCapacity[0]) * {{æ—¶é—´æ­¥é•¿å‚æ•°}} )
            else:
                raise Exception("æœªçŸ¥å¾ªç¯è¾¹ç•Œæ¡ä»¶:", self.è®¾å¤‡ä¿¡æ¯.å¾ªç¯è¾¹ç•Œæ¡ä»¶)
        elif self.è®¡ç®—å‚æ•°.è®¡ç®—ç±»å‹ == "ä»¿çœŸæ¨¡æ‹Ÿ":
            self.mw.Constraint(self.åŸç”µæ¥å£.x[0] == self.EPS)

        {% endif %}

        {# ç§’çº§åŠŸç‡å˜åŒ–é™åˆ¶ï¼Œæœ‰ç‰¹å®šçš„å˜é‡é™åˆ¶ #}
        {% if class_name in ['å…‰ä¼å‘ç”µ', 'é£åŠ›å‘ç”µ', 'æŸ´æ²¹å‘ç”µ'] %}
        if self.è®¡ç®—å‚æ•°.è®¡ç®—æ­¥é•¿ == "ç§’":
            æ€»æœ€å¤§åŠŸç‡ = {{'self.MaxPower' if class_name in ['å…‰ä¼å‘ç”µ'] else 'self.RatedPower'}} * self.DeviceCount
            æœ€å¤§åŠŸç‡å˜åŒ– = æ€»æœ€å¤§åŠŸç‡ *self.PowerDeltaLimit / 100
            self.CustomRangeConstraintMulti(self.{{'åŸç”µè¾“å‡º' if class_name in ['æŸ´æ²¹å‘ç”µ'] else 'ç”µè¾“å‡º'}} , customRange = range(self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°-1),expression = lambda x,i: x[i+1] - x[i] <= æœ€å¤§åŠŸç‡å˜åŒ–)
            self.CustomRangeConstraintMulti(self.{{'åŸç”µè¾“å‡º' if class_name in ['æŸ´æ²¹å‘ç”µ'] else 'ç”µè¾“å‡º'}} , customRange =  range(self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°-1),expression = lambda x,i: x[i+1] - x[i] >= -æœ€å¤§åŠŸç‡å˜åŒ–)
        {% endif %}
        {# elif self.è®¡ç®—å‚æ•°.è®¡ç®—æ­¥é•¿ == "å°æ—¶":
            ... # skip it.
        else:
            raise Exception("æœªçŸ¥è®¡ç®—æ­¥é•¿:", self.è®¡ç®—å‚æ•°.è®¡ç®—æ­¥é•¿) #}
        
        # è®¡ç®—å¹´åŒ–
        # unit: one
        {# if è®¡ç®—å‚æ•°.è®¡ç®—ç±»å‹ == "è§„åˆ’è®¾è®¡": #}
        {# è§„åˆ’è®¾è®¡å’Œä»¿çœŸæ¨¡æ‹Ÿéƒ½éœ€è¦è®¡ç®—å¹´åŒ– #}
        {%with%}
        {% if class_name in ['é”‚ç”µæ± '] %} 
        è®¡ç®—èŒƒå›´å†…æ€»å¹³å‡åŠŸç‡ = (self.SumRange(self.åŸç”µæ¥å£.x_abs)/self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°)+self.TotalStorageDecayRate # kW
        # avg power

        ä¸€å°æ—¶æ€»ç”µå˜åŒ–é‡ = è®¡ç®—èŒƒå›´å†…æ€»å¹³å‡åŠŸç‡ # çœç•¥ä¹˜1
        # kWh

        ä¸€å¹´æ€»ç”µå˜åŒ–é‡ = ä¸€å°æ—¶æ€»ç”µå˜åŒ–é‡ * 8760
        
        self.mw.Constraint(ä¸€å¹´æ€»ç”µå˜åŒ–é‡ * self.BatteryLife <= self.DeviceCount * self.TotalDischargeCapacity * 0.85)
        assert self.BatteryLife >=1
        assert self.Life >= self.BatteryLife
        Life = self.BatteryLife
        {%else%}
        Life = self.Life
        {%endif%}

        å¹´åŒ–ç‡ = ((1+(self.è®¡ç®—å‚æ•°.å¹´åˆ©ç‡/100))** Life) / Life
        {% if class_name in ['å…‰ä¼å‘ç”µ'] %}
            {% set m='æ€»æœ€å¤§åŠŸç‡'%}
            {% set vi = 'Kilowatt' %}
            {% set vm = 'Kilowatt' %}
            {% set vb = 'Kilowatt' %}
            {% set vv = 'Work' %}
        {%elif class_name in ['é£åŠ›å‘ç”µ']+å•å‘å˜ç”µå™¨åˆ—è¡¨+ ['åŒå‘å˜æµå™¨']%}
            {% set m='self.DeviceCount * self.RatedPower'%}
            {% set vi = 'Kilowatt' %}
            {% set vm = 'Kilowatt' %}
            {% set vb = 'Kilowatt' %}
            {% set vv = 'Work' %}
        {% elif class_name in ['æŸ´æ²¹å‘ç”µ']%}
            {% set m='self.DeviceCount'%}
            {% set vi = 'Machine' %}
            {% set vm = 'Machine' %}
            {% set vb = 'Machine' %}
            {% set vv = 'Work' %}
        {% elif class_name in ["é”‚ç”µæ± "]%}
            {% set m='self.DeviceCount * self.RatedCapacity'%}
            {% set vi = 'Capacity' %}
            {% set vm = 'Capacity' %}
            {% set vb = 'Capacity' %}
            {% set vv = 'Work' %}
        {% elif class_name in ['ä¼ è¾“çº¿'] %}
            {% set m='self.Length'%}
            {% set vi = 'Kilometer' %}
            {% set vm = 'Kilometer' %}
            {% set vb = 'Kilometer' %}
        {% else%}
            {% error("ä¸æ”¯æŒçš„è®¾å¤‡ç±»å‹:", class_name) %}
        {% endif %}

        æ€»é‡‡è´­æˆæœ¬ = self.CostPer{{vi}} * ({{ m}}) 
        æ€»å›ºå®šç»´æŠ¤æˆæœ¬ = self.CostPerYearPer{{vm}} * ({{ m}})
        æ€»å»ºè®¾è´¹ç”¨ = self.BuildCostPer{{vb}} * ({{ m}}) + self.BuildBaseCost

        æ€»å›ºå®šæˆæœ¬å¹´åŒ– = (æ€»é‡‡è´­æˆæœ¬ + æ€»å›ºå®šç»´æŠ¤æˆæœ¬ + æ€»å»ºè®¾è´¹ç”¨) * å¹´åŒ–ç‡

        {% if class_name in ['å…‰ä¼å‘ç”µ','é£åŠ›å‘ç”µ','æŸ´æ²¹å‘ç”µ']%}
            {% set m1="self.SumRange(self.ç”µè¾“å‡º)"%}
        {% elif class_name in ['é”‚ç”µæ± ']%}
            {% set m1="è®¡ç®—èŒƒå›´å†…æ€»å¹³å‡åŠŸç‡*self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°"%}
        {% elif class_name in å•å‘å˜ç”µå™¨åˆ—è¡¨+['ä¼ è¾“çº¿']%}
            {% set m1='-self.SumRange(self.ç”µè¾“å…¥)'%}
        {% elif class_name in ['åŒå‘å˜æµå™¨']%}
            {% set m1='(self.SumRange(self.å‚¨èƒ½ç«¯_.x_neg)+self.SumRange(self.çº¿è·¯ç«¯_.x_neg))'%}
        {%elif class_name in ['ä¼ è¾“çº¿'] %}
            {% set m1='0'%}
        {% else%}
            {% error("ä¸æ”¯æŒçš„ç±»å‹:", class_name) %}
        {% endif %}
        {% if class_name not in ['ä¼ è¾“çº¿']%}
        {# æ€»å¯å˜ç»´æŠ¤æˆæœ¬å¹´åŒ– = ({{m1}}) * (8760 / self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°) * ({{æ—¶é—´æ­¥é•¿å‚æ•°}}) *self.VariationalCostPer{{vv}} #}
        æ€»å¯å˜ç»´æŠ¤æˆæœ¬å¹´åŒ– = (({{m1}}) / self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°) * 8760 * self.VariationalCostPer{{vv}} 
        # avg_power * 8760 = annual_work

        æ€»æˆæœ¬å¹´åŒ– = æ€»å›ºå®šæˆæœ¬å¹´åŒ– + æ€»å¯å˜ç»´æŠ¤æˆæœ¬å¹´åŒ–
        {% else%}
        æ€»æˆæœ¬å¹´åŒ– = æ€»å›ºå®šæˆæœ¬å¹´åŒ–
        {% endif%}
        {% endwith%}

        return æ€»æˆæœ¬å¹´åŒ–
{% endfor %}

{# ##########[PINT START]########## #}

import pint

from unit_utils import (
    unitFactorCalculator,
    ureg,
    standard_units,
    getSingleUnitConverted,
    translateUnit
)

{# ##########[PINT END]########## #}

{% set load_class_names = [] %}
{% for v in load_types%}
    {% do load_class_names.append(v+"è´Ÿè·")%}
{% endfor%}
{% set input_class_names = input_types%}
{% set special_classes = {"load_class": load_class_names, "input_class": input_class_names}%}

{# check for coverage #}
{% for class_name in è®¾å¤‡æ¥å£é›†åˆ.keys() %}
    {% if class_name not in NonLoadDeviceDict.keys() %}
        {% if class_name not in input_class_names+load_class_names%}
            {% error("æœªè¦†ç›–çš„éè®¾å¤‡ç±»å‹:", class_name)%}
        {% endif%}
    {% endif%}
{% endfor%}

{% for k,clist in special_classes.items() %}
    {% for class_name in clist%}
class {{class_name}}æ¨¡å‹(è®¾å¤‡æ¨¡å‹):
{{ init_super_class(class_name)}}

{{ port_variable_define(class_name)}}

    {% if k == "load_class"%}
        {% if not class_name.endswith('è´Ÿè·')%}
            {% error("é”™è¯¯çš„è´Ÿè·ç±»å:", class_name)%}
        {% else%}
            {% set v = class_name.strip("è´Ÿè·")%}
        {% endif%}
        assert len(self.è®¾å¤‡ä¿¡æ¯.EnergyConsumption) == self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°

        {% if v in ['ç”µ'] %}
        MaxEnergyConsumptionDefault = max(self.è®¾å¤‡ä¿¡æ¯.EnergyConsumption)
        if self.è®¾å¤‡ä¿¡æ¯.MaxEnergyConsumption is None:
            self.MaxEnergyConsumption = MaxEnergyConsumptionDefault
        else:
            assert self.è®¾å¤‡ä¿¡æ¯.MaxEnergyConsumption >= MaxEnergyConsumptionDefault
            self.MaxEnergyConsumption = self.è®¾å¤‡ä¿¡æ¯.MaxEnergyConsumption
        {% endif %}
    {% elif k == 'input_class' %}

        ### UNIT COMPATIBILITY CHECK ###
        default_unit= self.è®¾å¤‡ä¿¡æ¯.DefaultUnit
        val_unit = self.è®¾å¤‡ä¿¡æ¯.Unit

        has_exception, _ = getSingleUnitConverted(default_unit = default_unit, val_unit =val_unit)

        if has_exception:
            raise Exception(f"Unit '{val_unit}' is not compatible with default unit '{default_unit}'")
        ### UNIT COMPATIBILITY CHECK ###

        
        ### UNIT CONVERSION ###
        self.ConversionRate, self.StandardUnit = unitFactorCalculator(ureg, standard_units, val_unit)
        ### UNIT CONVERSION ###
        
        self.Price = self.è®¾å¤‡ä¿¡æ¯.Price * self.ConversionRate
        self.Unit = str(self.StandardUnit)
    {% else%}
        {% error("Unknown special class:", k)%}
    {% endif%}
    
    def constraints_register(self):
        super().constraints_register()
    {% if k == "load_class"%}
        {% if v in ['ç”µ'] %}
            {% set port_name = 'ç”µæ¥å£' %}
        {% else %}
            {% error("æœªçŸ¥è´Ÿè·ç±»å‹:",class_name) %}
        {% endif %}
        self.RangeConstraint(self.{{port_name}}, self.è®¾å¤‡ä¿¡æ¯.EnergyConsumption, lambda x,y: x == -y)
        å¹´åŒ–è´¹ç”¨ = 0
        {# è®¡ä»·æ¨¡å‹ #}
    {% elif k == "input_class"%}
        {% if class_name in ['æŸ´æ²¹']%}
        å¹³å‡æ¶ˆè€—ç‡ = self.SumRange(self.ç‡ƒæ–™æ¥å£) / self.è®¡ç®—å‚æ•°.è¿­ä»£æ­¥æ•°
        {% else%}
            {% error('æœªçŸ¥èƒ½æºç±»å‹:', class_name)%}
        {% endif%}

        å¹´åŒ–è´¹ç”¨ = å¹³å‡æ¶ˆè€—ç‡ * self.Price * 8760 

    {% else%}
        {% error("æœªçŸ¥ç‰¹æ®Šç±»å‹:", k)%}
    {% endif%}
        return å¹´åŒ–è´¹ç”¨

{% endfor %}
{% endfor %}

class ModelWrapperContext:
    def __init__(self):
        mw = ModelWrapper()
        self.mw = mw

    def __enter__(self):
        print("ENTER MODEL WRAPPER CONTEXT")
        return self.mw

    def __exit__(self, exc_type, exc_value, exc_traceback):
        # we don't have to take care of this.
        if exc_type == None:
            print("NO ERROR IN MODEL WRAPPER CONTEXT")
        else:
            print("ERROR IN MODEL WRAPPER CONTEXT")
        del self.mw.model
        del self.mw
        print("EXITING MODEL WRAPPER CONTEXT")

{% for e in ["Inst", "ID", 'Info'] %}
{% set class_types = {}%}
{% set type_suffix = ("æ¨¡å‹" if e == "Inst" else ("ä¿¡æ¯" if e == 'Info' else e)) %}
{% for class_name in è®¾å¤‡æ¥å£é›†åˆ.keys() %}
{% do class_types.update({class_name:class_name+type_suffix}) %}
{% endfor %}
dev{{e}}ClassMap : Dict[str, {{"è®¾å¤‡"+type_suffix if type_suffix != "ä¿¡æ¯" else "BaseModel"}}]= {
    {% for class_name in è®¾å¤‡æ¥å£é›†åˆ.keys() %}
    "{{class_name}}": {{class_types[class_name]}},
    {% endfor %}
} # type: ignore

{% endfor %}


{% macro iterate_input_output_limit(io_type, attr)%}
                # IO TYPE: {{io_type}}
                m_limit_list = []
                for m_id in {{io_type}}_indexs:
                    m_anchor = G.nodes[m_id]
                    m_node_id = m_anchor['device_id']
                    m_devInst = devInstDict[m_node_id]
                    m_limit_list.append(m_devInst.{{attr}})
                {{io_type}}_limit = {{- sum_reduce('m_limit_list') }}
{% endmacro %}

from networkx import Graph

# partial if typical day mode is on.
def compute(devs:List[dict], adders:Dict[int,dict], graph_data:dict, G: Graph, mw: ModelWrapper):
    PD = {}
    algoParam = è®¡ç®—å‚æ•°.parse_obj(graph_data)

    devInstDict = {}

    for dev in devs:
        devSubtype = dev['subtype']
        {# devParam = {k:v for k,v in dev.items() if k not in {"subtype","type","ports"} } #}
        devParam = dev['param']
        devPorts = dev['ports']

        devID_int = dev['id']

        devIDClass = devIDClassMap[devSubtype]

        devIDInstInit = {"ID": devID_int}
        for port_name, port_info in devPorts.items():
            port_id = port_info['id']
            devIDInstInit.update({port_name:port_id})
        devIDInst = devIDClass.parse_obj(devIDInstInit)

        devInfoInstInit = devParam
        devInfoClass = devInfoClassMap[devSubtype]
        devInfoInst = devInfoClass.parse_obj(devInfoInstInit)

        devInstClass = devInstClassMap[devSubtype]
        devInst = devInstClass(PD = PD, mw=mw, è®¡ç®—å‚æ•°å®ä¾‹=algoParam, è®¾å¤‡ID= devIDInst, è®¾å¤‡ä¿¡æ¯=devInfoInst) # type: ignore

        devInstDict.update({ devID_int: devInst})
    for adder_index, adder in adders.items():
        input_indexs, output_indexs, io_indexs = adder['input'], adder['output'], adder['IO']

        # add them all.
        for j in range(algoParam.è¿­ä»£æ­¥æ•°):
            seqsum = {{- sum_reduce('[PD[i][j] for i in input_indexs + output_indexs + io_indexs]') }}

            mw.Constraint(seqsum >=0)
        
        if algoParam.è®¡ç®—ç±»å‹ == 'è®¾è®¡è§„åˆ’':
            cnt = 0
            if len(input_indexs)==0:
                continue
            input_anchor_0 = G.nodes[input_indexs[0]]
            if input_anchor_0['subtype'] == 'å˜å‹å™¨è¾“å‡º':
                print(f"Building Converter Constraint #{cnt}")
                cnt+=1
                assert io_indexs == []

{{ iterate_input_output_limit("input","æœ€å¤§å…è®¸çš„è´Ÿè½½æ€»åŠŸç‡") }}

{{ iterate_input_output_limit("output","MaxEnergyConsumption") }}

                mw.Constraint(input_limit + output_limit >= 0)

    financial_obj_expr = {{- sum_reduce('[e.constraints_register() for e in devInstDict.values()]') }}

    environment_obj_expr = ...

    obj_expr = financial_obj_expr

    return obj_expr, devInstDict, PD
    # always minimize the objective.

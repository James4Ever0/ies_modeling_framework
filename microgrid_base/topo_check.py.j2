from pydantic import BaseModel
import networkx

# when to check topology:
# 	1.  Building topology <- which the frontend does the job
# 	2.  Importing topology <- where algorithm kicks in

# so here we only check topo when importing. we don't check validity during the building.

# 母线最多99个对接的接口

class 拓扑图(BaseModel):
    def __init__(self, **kwargs):
        self.node_count = 0
        self.graph = networkx.Graph(**kwargs)

    def add_node(self, **kwargs):
        self.graph.add_node(self.node_count,**kwargs)
        node_id = self.node_count
        self.node_count += 1
        return node_id
    # monotonically adding a node.
    def check_consistency(self) -> bool:
        for node in 
        return is_consistent
    def to_json(self) -> dict:
        return json_data
    @staticmethod
    def from_json(json_data) -> dict:
        # load data to graph
        kwargs = ...
        graph = 拓扑图(**kwargs)
        graph.add
        return graph
    # with checking.
    # iterate through all nodes.
# 下面的都需要传拓扑图进来

class 节点(BaseModel):
    def __init__(self, graph:拓扑图, **kwargs):
        self.graph = graph
        self.kwargs = kwargs
        self.id = self.graph.add_node(**kwargs)

class 母线(节点):
    def __init__(self, graph:拓扑图, **kwargs):
        super().__init__(graph, **kwargs)
        # infinite ports.

class 设备(节点):
    def __init__(self, graph:拓扑图, device_type:str, port_definition:dict,**kwargs):
        # check if device type is one of the common types.
        super().__init__(graph, **kwargs)
        self.ports = {}
        for port_name, port_type in port_definition.items():
            node_id = self.graph.add_node()
            self.ports.update({port_name: {"type": port_type, "id": node_id}})

class 连接线(节点): # you might want to check here.
    def __init__(self, graph:拓扑图, **kwargs):
        super().__init__(graph, **kwargs)
        self.graph.add_node(self.node_id, **kwargs)

class 合并线(节点): # how to merge this? to verify the validity?
# the graph needs to go through transformation, to check validity and generate info to compute.
# but we only save the graph before transformation.
    def __init__(self, graph:拓扑图, **kwargs):
        super().__init__(graph, **kwargs)
from pydantic import BaseModel
import networkx

# when to check topology:
# 	1.  Building topology <- which the frontend does the job
# 	2.  Importing topology <- where algorithm kicks in

# so here we only check topo when importing. we don't check validity during the building.

# 母线最多99个对接的接口

def getMainAndSubtype(data):
    mainType = data['type']
    subType = data['subtype']
    return mainType, subType

class 拓扑图:
    def __init__(self, **kwargs):
        self.node_count = 0
        self.graph = networkx.Graph(**kwargs)

    def add_node(self, **kwargs):
        self.graph.add_node(self.node_count,**kwargs)
        node_id = self.node_count
        self.node_count += 1
        return node_id
    # monotonically adding a node.
    def check_consistency(self) -> bool:
        #  use subgraph
        # 提取所有母线ID
        母线ID列表 = []
        for node_id, node_data in self.graph.nodes.items():
            node_type, node_subtype = getMainAndSubType(node_data)
            neighbors = self.graph.neighbors(node_id)
            if node_type == "母线":
                母线ID列表.append(node_id)
                assert len(neighbors) <= 99
                for n in neighbors:
                    ne_data = self.graph[n]
                    ne_type, ne_subtype = getMainAndSubtype(ne_data)
                    if ne_type == "合并线":
                        # just check type.
                        ...
                    elif ne_type == "连接线":
                        ...
                    else:
                        raise Exception("母线连接未知类型节点：",ne_type)
            elif node_type == "设备":
                ... 
            elif node_type == "连接线":
                ... 
            elif node_type == "合并线":
                ...
            else:
                raise Exception("unknown node type:", node_type)
            subgraph = self.graph.subgraph(母线ID列表) # check again.
        return is_consistent
    def to_json(self) -> dict:
        return json_data
    @staticmethod
    def from_json(json_data) -> dict:
        # load data to graph
        kwargs = ...
        graph = 拓扑图(**kwargs)
        graph.add
        return graph
    # with checking.
    # iterate through all nodes.

# 下面的都需要传拓扑图进来

class 节点(BaseModel):
    def __init__(self, topo:拓扑图, **kwargs):
        self.topo = topo
        self.kwargs = kwargs
        self.id = self.topo.add_node(**kwargs)

class 母线(节点):
    def __init__(self, topo:拓扑图, **kwargs):
        super().__init__(topo, type=self.__class__.__name__, conn = [],**kwargs)
        # infinite ports.
        

class 设备(节点):
    def __init__(self, topo:拓扑图, device_type:str, port_definition:dict,**kwargs):
        # check if device type is one of the common types.
        super().__init__(topo, type=self.__class__.__name__, subtype=device_type, **kwargs)
        self.ports = {}
        for port_name, port_type in port_definition.items():
            node_id = self.topo.add_node(type="锚点", subtype=port_type)
            self.ports.update({port_name: {"subtype": port_type,"id":node_id}})

class 连接节点(节点):
    def __init__(self, topo:拓扑图, type:str, subtype:str, conn_start_id:int, conn_end_id:int, **kwargs):
        super().__init__(topo, type=type, subtype = subtype, **kwargs)
        self.topo.graph.add_edge(conn_start_id, self.id)
        self.topo.graph.add_edge(self.id, conn_end_id)
        if self.topo.graph.nodes[conn_start_id]["type"] == "母线":
            self.topo.graph.nodes[conn_start_id]["conn"].append(subtype)
        if self.topo.graph.nodes[conn_end_id]["type"] == "母线":
            self.topo.graph.nodes[conn_end_id]["conn"].append(subtype)


{% macro makeConnNodeInstance(className) -%}

class {{className}}(连接节点)
    def __init__(self, topo:拓扑图, subtype:str, conn_start_id:int, conn_end_id:int, **kwargs):
        super().__init__(topo, type=self.__class__.__name__, subtype = subtype, conn_start_id= conn_start_id, conn_end_id=conn_end_id, **kwargs)

{% endmacro %}

{{ makeConnNodeInstance("连接线") }}

{{ makeConnNodeInstance("合并线") }}
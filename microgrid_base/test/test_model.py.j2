from common_fixtures import *

from typing import cast

try:
    from typing import Protocol
except:
    from typing_extensions import Protocol
from pyomo.environ import *

# may you hook arith methods to check expression (poly degree) on the way.

# render constraints as latex. use sigma notation.

EPS = 0.02

def check_solver_result(s_results):
    assert s_results, "no solver result."
    TC = s_results.solver.termination_condition
    SS = s_results.solver.status
    normalSSs = [SolverStatus.ok, SolverStatus.warning]
    normalTCs = [
        TerminationCondition.globallyOptimal,
        TerminationCondition.locallyOptimal,
        TerminationCondition.feasible,
        TerminationCondition.optimal,
        # TerminationCondition.maxTimeLimit,
    ]
    error_msg = []
    if TC not in normalTCs:
        error_msg.append(f"abnormal termination condition: {TC}")
    if SS not in normalSSs:
        error_msg.append(f"abnormal solver status: {TC}")
    if error_msg:
        raise Exception("\n".join(error_msg))

def test_convertMonthToDays():
    assert convertMonthToDays(1) == sum(month_days[:1])
    assert convertMonthToDays(2) == sum(month_days[:2])
    assert convertMonthToDays(11) == sum(month_days[:11])

import pytest
{% set paramStringList = []%}
{% macro parametrizeTestHelper(testName,_params)%}
{# shall you ensure no parameter is undefined.#}
{% do paramStringList.append(_params)%}
{{caller()}}
def test_{{testName}}({{",".join(paramStringList)}}):
{# def test_{{testName}}({{join(",",paramStringList)}}): #}
{% set paramStringList = []%}
{% endmacro%}
{% macro parametrize(mParamString) %}
    {% do paramStringList.append(mParamString) %}
@pytest.mark.parametrize({{repr(mParamString)}},{{caller()}})
{% endmacro%}
{% macro solveModel(objective, sense='sense')%}
    model_wrapper.Objective(expr={{objective}}, sense={{sense}})
    {# OBJ = model_wrapper.Objective(expr={{objective}}, sense={{sense}}) #}
    with SolverFactory("cplex") as solver:
        print(">>>SOLVING<<<")
        s_results = solver.solve(model_wrapper.model, tee=True)
        print("SOLVER RESULTS?")
        print(s_results)
        check_solver_result(s_results)

{% endmacro %}

# BUG: BigM <= 1e+8
{# {% call parametrizeTestHelper("BinVarMultiplySingle")%} #}
{% set commonDevTestParam ="model_wrapper: ModelWrapper, 测试设备模型: 设备模型" %}
{% call parametrizeTestHelper("BinVarMultiplySingle", commonDevTestParam)%}
    {% call parametrize("v0_is_constant")%}[False, True]{% endcall%}
    {% call parametrize("v0_within, min_v0, max_v0, sense, result")%}
    [
        (Reals, -1, 10, minimize, -1),
        (Reals, -1, 10, maximize, 10),
        (NonNegativeReals, 1, 10, minimize, 0),
        (NonNegativeReals, 1, 10, maximize, 10),
    ]
    {%endcall%}
    {% call parametrize("v1_init")%}[0, 1]{%endcall%}
    {% call parametrize("v0_init")%}[3]{%endcall%}
    {% call parametrize("v1_within")%}[Boolean, pytest.param(NonNegativeReals, marks=pytest.mark.xfail)]{% endcall%}
{% endcall %}
    assert min_v0 <= max_v0
    if v0_is_constant:
        v0 = v0_init
    else:
        v0 = 测试设备模型.单变量(
            "v0", within=v0_within, initialize=v0_init, bounds=(min_v0, max_v0)
        )
    v1 = 测试设备模型.单变量("v1", within=v1_within, initialize=v1_init)
    v_result = 测试设备模型.BinVarMultiplySingle(v1, v0)
{{solveModel('v_result')}}
        print(f"v0: {value(v0)}")
        print(f"v1: {value(v1)}")
        print(f"PROD: {value(v_result)}")
        print(f"EXPECTED: {result}")
        print(f"ACTUAL: {value(v0)*value(v1)}")
        if v0_is_constant:
            if sense == minimize:
                result = min(0, v0_init)
            elif sense == maximize:
                result = max(0, v0_init)
            else:
                assert False, f"Wrong sense: {sense}"
        assert abs(value(v_result) - result) <= EPS

{% call parametrizeTestHelper("VarMultiplySingle", commonDevTestParam)%}
    {% call parametrize("v0_min, v0_max, v1_min, v1_max, sense, expected, param")%}
    [
        (1, 5, 2, 4, minimize, 2, 0),
        (1, 5, 2, 4, maximize, 20, 0),
        (-1, 3, -2, 4, minimize, -10, -2),
        (-1, 3, -2, 4, maximize, 8, -2),
    ]
    {% endcall %}
{% endcall %}
    v0 = 测试设备模型.变量列表("v0", bounds=(v0_min, v0_max))
    v0_dict = dict(var=v0, max=v0_max, min=v0_min)

    v1 = 测试设备模型.变量列表("v1", bounds=(v1_min, v1_max))
    v1_dict = dict(var=v1, max=v1_max, min=v1_min)

    v0_v1 = 测试设备模型.Multiply(v0_dict, v1_dict, "v0_v1")
    obj_expr = v0_v1[0] + param * (v0[0] + v1[0])
{{solveModel('obj_expr')}}
        assert abs(value(obj_expr) - expected) <= EPS

{% call parametrizeTestHelper("单表达式生成指示变量", commonDevTestParam) %}
    {% call parametrize("v0_min, v0_max, sense, expected_v0, expected_v1_b_pos, expected_v1_x_pos, expected_v1_b_neg, expected_v1_x_neg, expected_v1_x_abs")%}
    [
        (-1, 5, maximize, 5, 1, 5, 0, 0, 5),
        (-1, 5, minimize, -1, 0, 0, 1, 1, 1),
        (-2, 5, minimize, -2, 0, 0, 1, 2, 2),
    ]
    {% endcall%}
{% endcall%}
    v0 = 测试设备模型.单变量("v0", bounds=(v0_min, v0_max))
    v1 = 测试设备模型.单表达式生成指示变量("v1", v0)
    # v1 = 测试设备模型.单表达式生成指示变量("v1", v0+0)
{{solveModel('v0')}}
        assert abs(expected_v0 - value(v0)) <= EPS
        assert abs(expected_v1_b_pos - value(v1.b_pos)) <= EPS
        assert abs(expected_v1_x_neg - value(v1.x_neg)) <= EPS
        assert abs(expected_v1_b_neg - value(v1.b_neg)) <= EPS
        assert abs(expected_v1_x_pos - value(v1.x_pos)) <= EPS
        assert abs(expected_v1_x_abs - value(v1.x_abs)) <= EPS


import numpy as np


@pytest.mark.parametrize(
    "x_init, y_expected, sense",
    [
        (0, 2, minimize),
        (0, 2, maximize),
        (0.3, 2.3, minimize),
        (0.3, 2.3, maximize),
        (0 - 1, 2, minimize),  # BUG: y = 0 if x is out of bound
        (0 - 1, 2, maximize),
        (0 + 3, 4, minimize),
        (0 + 3, 4, maximize),
    ],
)
def test_Piecewise(
    model_wrapper: ModelWrapper, 测试设备模型: 设备模型, x_init, y_expected, sense
):
    x = [测试设备模型.单变量("x", initialize=x_init, bounds=(x_init, x_init))]
    y = [测试设备模型.单变量("y")]
    x_vals = np.linspace(0, 2, 2)
    y_vals = x_vals + 2
    测试设备模型.Piecewise(x, y, x_vals.tolist(), y_vals.tolist(), range_list=[0])
    obj_expr = y[0]
    model_wrapper.Objective(expr=obj_expr, sense=sense)

    with SolverFactory("cplex") as solver:
        print(">>>SOLVING<<<")
        s_results = solver.solve(model_wrapper.model, tee=True)
        print("SOLVER RESULTS?")
        print(s_results)
        assert abs(value(obj_expr) - y_expected) <= EPS


# if use timeout as solver option, usually not so good.
# you will not get accurate results.


@pytest.mark.timeout(30)  # pip3 install pytest-timeout
@pytest.mark.parametrize(
    "power_output, expected_val, expected_diesel",
    [
        (10, 10, -3 * 0.001 * 10),
        (20, 20, -1 * 0.001 * 20),
    ],
)
def test_柴油发电(
    model_wrapper: ModelWrapper,
    测试柴油发电模型: 柴油发电模型,
    power_output,
    expected_val,
    expected_diesel,
):
    测试柴油发电模型.燃料热值 = 1
    测试柴油发电模型.constraints_register()
    测试柴油发电模型.RangeConstraintMulti(测试柴油发电模型.电输出, expression=lambda x: x == power_output)
    obj_expr = 测试柴油发电模型.总成本年化
    print("年化:", obj_expr)
    model_wrapper.Objective(obj_expr, sense=minimize)

    with SolverFactory("cplex") as solver:
        # solver.options['mipgap'] = 0.05 # to prevent too much iteration?
        solver.options["timelimit"] = 5  # use this instead.
        # print(solver.options.keys())
        # breakpoint()
        print(">>>SOLVING<<<")
        s_results = solver.solve(model_wrapper.model, tee=True)
        print("SOLVER RESULTS?")
        print(s_results)  # check solver status.

        assert s_results, "no solver result."
        TC = s_results.solver.termination_condition
        SS = s_results.solver.status
        normalSSs = [SolverStatus.ok, SolverStatus.warning]
        normalTCs = [
            TerminationCondition.globallyOptimal,
            TerminationCondition.locallyOptimal,
            TerminationCondition.feasible,
            TerminationCondition.optimal,
            # TerminationCondition.maxTimeLimit,
        ]
        error_msg = []
        if TC not in normalTCs:
            error_msg.append(f"abnormal termination condition: {TC}")
        if SS not in normalSSs:
            error_msg.append(f"abnormal solver status: {TC}")
        if error_msg:
            raise Exception("\n".join(error_msg))
        # TODO: can apply this to "solve_model.py"
        print("ELECTRICITY:", value(测试柴油发电模型.原电输出[0]), expected_val)
        print("DIESEL:", value(测试柴油发电模型.柴油输入[0]), expected_diesel)
        assert abs(value(测试柴油发电模型.原电输出[0]) - expected_val) <= EPS
        assert abs(value(测试柴油发电模型.柴油输入[0]) - expected_diesel) <= 0.0015
        # breakpoint()


def test_电价模型():
    from ies_optim import 电负荷信息, 分月电价

    mydata = dict(PriceList=[1] * 12)
    myInfo = 电负荷信息.parse_obj(
        dict(
            设备名称="Any",
            EnergyConsumption=[1, 2, 3],
            MaxEnergyConsumption=4,
            PriceModel=mydata,
        )
    )
    myPriceModel = 分月电价.parse_obj(mydata)
    print(myInfo)
    # breakpoint()
    assert myPriceModel == myInfo.PriceModel


@pytest.mark.parametrize(
    "day_index, expected_month",
    [
        (1, 0),
        pytest.param(365, 11, marks=pytest.mark.xfail),
        (364, 11),
        (363, 11),
        (333, 10),
    ],
)
def test_DayToMonth(day_index, expected_month):
    from ies_optim import convertDaysToMonth

    month_index = convertDaysToMonth(day_index)
    assert month_index == expected_month


@pytest.mark.parametrize(
    "hour_index, expected_price, power",
    [
        (2, 4 * 0.0001 * 1, 4),
        (24 * 40, 4 * 0.0001 * 2, 4),
        (24 * 30 * 2 + 10, 4 * 0.0001 * 3, 4),
        pytest.param(8760, 4 * 0.0001 * 12, 4, marks=pytest.mark.xfail),
        (8779, 4 * 0.0001 * 12, 4),
    ],
)
def test_分月电价(hour_index, expected_price, power):
    from ies_optim import 分月电价

    myPriceModel = 分月电价(PriceList=(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
    mprice = myPriceModel.getFee(power, time_in_day=hour_index)
    assert abs(mprice - expected_price) == 0


from ies_optim import 柴油模型, 计算参数, 柴油信息, 柴油ID


@fixture
def 测试柴油ID():
    devId = 柴油ID(ID=1, 燃料接口=2)
    return devId


@fixture
def 测试柴油信息():
    devInfo = 柴油信息(设备名称="Any", Price=(2, "万元/L"), 热值=(2, "kWh/L"), CO2=(2, "kg/L"))
    return devInfo


@fixture
def 测试柴油模型(model_wrapper: ModelWrapper, 测试计算参数: 计算参数, 测试柴油ID: 柴油ID, 测试柴油信息: 柴油信息):
    mDieselModel = 柴油模型(
        PD={}, mw=model_wrapper, 计算参数实例=测试计算参数, 设备ID=测试柴油ID, 设备信息=测试柴油信息
    )
    return mDieselModel


@pytest.mark.parametrize("diesel_rate, fee_rate_per_hour", [(1, 2), (3, 6)])
def test_柴油(model_wrapper: ModelWrapper, 测试柴油模型: 柴油模型, diesel_rate, fee_rate_per_hour):
    测试柴油模型.constraints_register()
    测试柴油模型.RangeConstraintMulti(
        测试柴油模型.燃料接口, expression=lambda x: x == diesel_rate
    )  # unit: m^3
    obj_expr = 测试柴油模型.燃料接口[0]
    测试柴油模型.mw.Objective(expr=obj_expr, sense=minimize)
    with SolverFactory("cplex") as solver:
        print(">>>SOLVING<<<")
        s_results = solver.solve(model_wrapper.model, tee=True)
        print("SOLVER RESULTS?")
        print(s_results)
        val_fee = value(测试柴油模型.总成本年化 / 1000) / 8760
        assert abs(val_fee - fee_rate_per_hour) < EPS


from ies_optim import 双向变流器ID, 双向变流器模型, 双向变流器信息


@fixture
def 测试双向变流器信息():
    devInfo = 双向变流器信息(
        设备名称="双向变流器",
        生产厂商="Any",
        设备型号="双向变流器1",
        RatedPower=100,
        Efficiency=98,
        CostPerKilowatt=2,
        CostPerYearPerKilowatt=2,
        VariationalCostPerWork=2,
        Life=10,
        BuildCostPerKilowatt=2,
        BuildBaseCost=2,
        MaxDeviceCount=1,
        MinDeviceCount=1,
        DeviceCount=1,
    )
    return devInfo


@fixture
def 测试双向变流器模型(
    测试双向变流器信息: 双向变流器信息, model_wrapper: ModelWrapper, 测试双向变流器ID: 双向变流器ID, 测试计算参数: 计算参数
):
    devModel = 双向变流器模型(
        PD={}, mw=model_wrapper, 计算参数实例=测试计算参数, 设备ID=测试双向变流器ID, 设备信息=测试双向变流器信息
    )
    return devModel


@pytest.mark.parametrize("input, output", [])
def test_双向变流器():
    ...


from ies_optim import 风力发电ID, 风力发电模型, 风力发电信息


@fixture
def 测试风力信息():
    devInfo = 风力发电信息(
        设备名称="风力发电",
        生产厂商="Any",
        设备型号="风力发电1",
        RatedPower=100,
        RatedWindSpeed=100,
        MinWindSpeed=10,
        MaxWindSpeed=200,
        PowerDeltaLimit=2,
        CostPerKilowatt=...,
        CostPerYearPerKilowatt=...,
        VariationalCostPerWork=...,
        Life=...,
        BuildCostPerKilowatt=...,
        BuildBaseCost=...,
        MaxDeviceCount=...,
        MinDeviceCount=...,
        DeviceCount=...,
    )


def test_风力发电():
    ...

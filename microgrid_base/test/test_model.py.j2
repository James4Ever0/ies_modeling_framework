from common_fixtures import *

from typing import cast

try:
    from typing import Protocol
except:
    from typing_extensions import Protocol
from pyomo.environ import *

# may you hook arith methods to check expression (poly degree) on the way.

# render constraints as latex. use sigma notation.

EPS = 0.02

def check_solver_result(s_results):
    assert s_results, "no solver result."
    TC = s_results.solver.termination_condition
    SS = s_results.solver.status
    normalSSs = [SolverStatus.ok, SolverStatus.warning]
    normalTCs = [
        TerminationCondition.globallyOptimal,
        TerminationCondition.locallyOptimal,
        TerminationCondition.feasible,
        TerminationCondition.optimal,
        # TerminationCondition.maxTimeLimit,
    ]
    error_msg = []
    if TC not in normalTCs:
        error_msg.append(f"abnormal termination condition: {TC}")
    if SS not in normalSSs:
        error_msg.append(f"abnormal solver status: {TC}")
    if error_msg:
        raise Exception("\n".join(error_msg))

def test_convertMonthToDays():
    assert convertMonthToDays(1) == sum(month_days[:1])
    assert convertMonthToDays(2) == sum(month_days[:2])
    assert convertMonthToDays(11) == sum(month_days[:11])

import pytest
{% set paramStringList = []%}
{% macro parametrizeTestHelper(testName,_params, autoRegister=true)%}
{# shall you ensure no parameter is undefined.#}
    {% if _params == "Device"%}
        {% set _params = "model_wrapper: ModelWrapper, 测试{testName}模型: {testName}模型".format(testName=testName) %}
    {% endif%}
    {% if _params != ""%}
        {% do paramStringList.append(_params)%}
    {% endif%}
{{caller()}}
def test_{{testName}}({{",".join(paramStringList)}}):
    {% if _params == 'Device'%}
    # {{_params}} {{autoRegister}}
        {% if autoRegister == true %}
    测试{{testName}}模型.constraints_register()
        {% endif%}
    {% endif%}
{# def test_{{testName}}({{join(",",paramStringList)}}): #}
    {% do paramStringList.clear() %}
    {# do not use "set" #}
{% endmacro%}
{% macro parametrize(mParamString) %}
    {% do paramStringList.append(mParamString) %}
@pytest.mark.parametrize({{repr(mParamString)}},{{caller()}})
{% endmacro%}
{% macro solveModel(objective, sense='sense')%}
    {# model_wrapper.Objective(expr={{objective}}, sense={{sense if sense == 'sense' else repr(sense)}}) #}
    model_wrapper.Objective(expr={{objective}}, sense={{sense}})
    with SolverFactory("cplex") as solver:
        print(">>>SOLVING<<<")
        solver.options["timelimit"] = 5 
        s_results = solver.solve(model_wrapper.model, tee=True)
        print("SOLVER RESULTS?")
        print(s_results)
        check_solver_result(s_results)

{% endmacro %}

# BUG: BigM <= 1e+8
{# {% call parametrizeTestHelper("BinVarMultiplySingle")%} #}
{% set commonDevTestParam ="model_wrapper: ModelWrapper, 测试设备模型: 设备模型" %}
{% call parametrizeTestHelper("BinVarMultiplySingle", commonDevTestParam)%}
    {% call parametrize("v0_is_constant")%}[False, True]{% endcall%}
    {% call parametrize("v0_within, min_v0, max_v0, sense, result")%}
    [
        (Reals, -1, 10, minimize, -1),
        (Reals, -1, 10, maximize, 10),
        (NonNegativeReals, 1, 10, minimize, 0),
        (NonNegativeReals, 1, 10, maximize, 10),
    ]
    {%endcall%}
    {% call parametrize("v1_init")%}[0, 1]{%endcall%}
    {% call parametrize("v0_init")%}[3]{%endcall%}
    {% call parametrize("v1_within")%}[Boolean, pytest.param(NonNegativeReals, marks=pytest.mark.xfail)]{% endcall%}
{% endcall %}
    assert min_v0 <= max_v0
    if v0_is_constant:
        v0 = v0_init
    else:
        v0 = 测试设备模型.单变量(
            "v0", within=v0_within, initialize=v0_init, bounds=(min_v0, max_v0)
        )
    v1 = 测试设备模型.单变量("v1", within=v1_within, initialize=v1_init)
    v_result = 测试设备模型.BinVarMultiplySingle(v1, v0)
{{solveModel('v_result')}}
        print(f"v0: {value(v0)}")
        print(f"v1: {value(v1)}")
        print(f"PROD: {value(v_result)}")
        print(f"EXPECTED: {result}")
        print(f"ACTUAL: {value(v0)*value(v1)}")
        if v0_is_constant:
            if sense == minimize:
                result = min(0, v0_init)
            elif sense == maximize:
                result = max(0, v0_init)
            else:
                assert False, f"Wrong sense: {sense}"
        assert abs(value(v_result) - result) <= EPS

{% call parametrizeTestHelper("VarMultiplySingle", commonDevTestParam)%}
    {% call parametrize("v0_min, v0_max, v1_min, v1_max, sense, expected, param")%}
    [
        (1, 5, 2, 4, minimize, 2, 0),
        (1, 5, 2, 4, maximize, 20, 0),
        (-1, 3, -2, 4, minimize, -10, -2),
        (-1, 3, -2, 4, maximize, 8, -2),
    ]
    {% endcall %}
{% endcall %}
    v0 = 测试设备模型.变量列表("v0", bounds=(v0_min, v0_max))
    v0_dict = dict(var=v0, max=v0_max, min=v0_min)

    v1 = 测试设备模型.变量列表("v1", bounds=(v1_min, v1_max))
    v1_dict = dict(var=v1, max=v1_max, min=v1_min)

    v0_v1 = 测试设备模型.Multiply(v0_dict, v1_dict, "v0_v1")
    obj_expr = v0_v1[0] + param * (v0[0] + v1[0])
{{solveModel('obj_expr')}}
        assert abs(value(obj_expr) - expected) <= EPS

{% call parametrizeTestHelper("单表达式生成指示变量", commonDevTestParam) %}
    {% call parametrize("v0_min, v0_max, sense, expected_v0, expected_v1_b_pos, expected_v1_x_pos, expected_v1_b_neg, expected_v1_x_neg, expected_v1_x_abs")%}
    [
        (-1, 5, maximize, 5, 1, 5, 0, 0, 5),
        (-1, 5, minimize, -1, 0, 0, 1, 1, 1),
        (-2, 5, minimize, -2, 0, 0, 1, 2, 2),
    ]
    {% endcall%}
{% endcall%}
    v0 = 测试设备模型.单变量("v0", bounds=(v0_min, v0_max))
    v1 = 测试设备模型.单表达式生成指示变量("v1", v0)
    # v1 = 测试设备模型.单表达式生成指示变量("v1", v0+0)
{{solveModel('v0')}}
        assert abs(expected_v0 - value(v0)) <= EPS
        assert abs(expected_v1_b_pos - value(v1.b_pos)) <= EPS
        assert abs(expected_v1_x_neg - value(v1.x_neg)) <= EPS
        assert abs(expected_v1_b_neg - value(v1.b_neg)) <= EPS
        assert abs(expected_v1_x_pos - value(v1.x_pos)) <= EPS
        assert abs(expected_v1_x_abs - value(v1.x_abs)) <= EPS


import numpy as np

{% call parametrizeTestHelper("Piecewise", commonDevTestParam) %}
    {%call parametrize("x_init, y_expected, sense")%}
    [
        (0, 2, minimize),
        (0, 2, maximize),
        (0.3, 2.3, minimize),
        (0.3, 2.3, maximize),
        (0 - 1, 2, minimize),  # BUG: y = 0 if x is out of bound
        (0 - 1, 2, maximize),
        (0 + 3, 4, minimize),
        (0 + 3, 4, maximize),
    ]
    {% endcall %}
{% endcall %}
    x = [测试设备模型.单变量("x", initialize=x_init, bounds=(x_init, x_init))]
    y = [测试设备模型.单变量("y")]
    x_vals = np.linspace(0, 2, 2)
    y_vals = x_vals + 2
    测试设备模型.Piecewise(x, y, x_vals.tolist(), y_vals.tolist(), range_list=[0])
    obj_expr = y[0]
{{solveModel("obj_expr")}}
        assert abs(value(obj_expr) - y_expected) <= EPS

# if use timeout as solver option, usually not so good.
# you will not get accurate results.


{% call parametrizeTestHelper("柴油", "Device")%}
    {% call parametrize("diesel_rate, fee_rate_per_hour")%}[(1, 2), (3, 6)]{%endcall%}
{%endcall%}
    {# 测试柴油模型.constraints_register() #}
    测试柴油模型.RangeConstraintMulti(
        测试柴油模型.燃料接口, expression=lambda x: x == diesel_rate
    )  # unit: m^3
    {# obj_expr = 测试柴油模型.总成本年化 #}
    obj_expr = 测试柴油模型.燃料接口[0]
{{ solveModel("obj_expr", "minimize")}}
        val_fee = value(测试柴油模型.总成本年化 / 1000) / 8760
        assert abs(val_fee - fee_rate_per_hour) < EPS

{% call parametrizeTestHelper("柴油发电", "Device", autoRegister=false) %}
@pytest.mark.timeout(30)  # pip3 install pytest-timeout
    {% call parametrize("power_output, expected_val, expected_diesel") %}
    [
        (10, 10, -3 * 0.001 * 10),
        (20, 20, -1 * 0.001 * 20),
    ]
    {% endcall %}
{% endcall %}
    测试柴油发电模型.燃料热值 = 1
    测试柴油发电模型.constraints_register()
    测试柴油发电模型.RangeConstraintMulti(测试柴油发电模型.电输出, expression=lambda x: x == power_output)
    obj_expr = 测试柴油发电模型.总成本年化
    print("年化:", obj_expr)
{{solveModel("obj_expr", "minimize")}}
        print("ELECTRICITY:", value(测试柴油发电模型.原电输出[0]), expected_val)
        print("DIESEL:", value(测试柴油发电模型.柴油输入[0]), expected_diesel)
        assert abs(value(测试柴油发电模型.原电输出[0]) - expected_val) <= EPS
        assert abs(value(测试柴油发电模型.柴油输入[0]) - expected_diesel) <= 0.0015
        # breakpoint()

def test_电价模型():
    {# from ies_optim import 电负荷信息, 分月电价 #}

    mydata = dict(PriceList=[1] * 12)
    myInfo = 电负荷信息.parse_obj(
        dict(
            设备名称="Any",
            EnergyConsumption=[1, 2, 3],
            MaxEnergyConsumption=4,
            PriceModel=mydata,
        )
    )
    myPriceModel = 分月电价.parse_obj(mydata)
    print(myInfo)
    # breakpoint()
    assert myPriceModel == myInfo.PriceModel

{% call parametrizeTestHelper("DayToMonth","")%}
    {% call parametrize("day_index, expected_month")%}
    [
        (1, 0),
        pytest.param(365, 11, marks=pytest.mark.xfail),
        (364, 11),
        (363, 11),
        (333, 10),
    ]
    {%endcall%}
{%endcall%}
    {# from ies_optim import convertDaysToMonth #}
    month_index = convertDaysToMonth(day_index)
    assert month_index == expected_month

{% call parametrizeTestHelper("分月电价","")%}
    {% call parametrize("hour_index, expected_price, power")%}
    [
        (2, 4 * 0.0001 * 1, 4),
        (24 * 40, 4 * 0.0001 * 2, 4),
        (24 * 30 * 2 + 10, 4 * 0.0001 * 3, 4),
        pytest.param(8760, 4 * 0.0001 * 12, 4, marks=pytest.mark.xfail),
        (8779, 4 * 0.0001 * 12, 4),
    ]
    {%endcall%}
{%endcall%}
    myPriceModel = 分月电价(PriceList=(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
    mprice = myPriceModel.getFee(power, time_in_day=hour_index)
    assert abs(mprice - expected_price) == 0


{# 
{% call parametrizeTestHelper("双向变流器", "Device")%}
    {% call parametrize("input, output")%}[]{% endcall%}
{% endcall%}
    ...

{% call parametrizeTestHelper("风力发电", "Device")%}
    {% call parametrize("input, output")%}[]{% endcall%}
{% endcall%}
    ...

{% call parametrizeTestHelper("传输线", "Device")%}
    {% call parametrize("input, output")%}[]{% endcall%}
{% endcall%}
    ...

#}

{% call parametrizeTestHelper("锂电池", "Device")%}
    {% call parametrize("device_count")%}[500/20]{% endcall%}
{% endcall%}
    测试锂电池模型.RangeConstraintMulti(测试锂电池模型.电接口, expression = lambda x: x == 500 * (10/100) / (50/100))
{{ solveModel("测试锂电池模型.总成本年化", "minimize")}}
        assert abs(value(测试锂电池模型.DeviceCount)) == device_count
        assert abs(value(测试锂电池模型.CurrentTotalActualCapacity[0]+ 500 * (测试锂电池模型.设备信息.MinSOC/100)) - 500 * (测试锂电池模型.设备信息.InitSOC/100)) < EPS